#![cfg_attr(feature="clippy", feature(plugin))]
#![cfg_attr(feature="clippy", plugin(clippy))]
#![cfg_attr(not(feature="clippy"), allow(unknown_lints))]

extern crate env_logger;
extern crate amqp_xmlgen as xmlgen;
extern crate amqp_xmlparse as xmlparse;
#[cfg(feature = "rustfmt")]
extern crate rustfmt;

#[macro_use]
extern crate log;

use std::env;
use std::fs::File;
use std::io::{self, BufWriter, Write};
use std::path::PathBuf;

use xmlparse::amqp0::{parse as parse0, ParseError};
use xmlgen::WriteRust;
use xmlgen::amqp0::Protocol as Pre1Protocol;

fn main() {
    ::env_logger::init().unwrap();

    let root_out = env::var_os("OUT_DIR").map(PathBuf::from).expect("Error: OUT_DIR not set");
    let cwd = env::current_dir().expect("Unable to get current directory");
    let protocols_dir = cwd.join("protocols");

    let amqp0_specs = vec![
        ("amqp0-9-1.stripped.xml",          "amqp-0.9.1"),
        ("amqp0-9.stripped.xml",            "amqp-0.9.0"),
        ("amqp0-8.stripped.xml",            "amqp-0.8.0"),
        ("amqp0-9-1.stripped.rabbitmq.xml", "rabbitmq-0.9.1"),
        ("amqp0-9-qpid.stripped.xml",       "qpid-0.9"),
        ("amqp0-8-qpid.stripped.xml",       "qpid-0.8"),
    ];

    println!("Iterating over amqp0_specs");
    let paths = amqp0_specs.into_iter()
        .map(|(spec_file, out)| -> Result<PathBuf, Error> {
            let spec_path = protocols_dir.join(spec_file);
            let out = root_out.join(out.to_string() + ".rs");

            println!("cargo:rerun-if-changed={}", spec_path.display());

            let parsed_result = parse0(&spec_path);
            let parsed = try!(parsed_result);
            let protocol = Pre1Protocol::new(parsed);

            {
                println!("Writing to {}", out.display());
                let file = File::create(&out)
                    .expect(&format!("Failed to open {}", out.display()));
                let mut writer = BufWriter::new(file);
                writer.write_all(b"// Generated by amqp-xmlspec-rs\n").unwrap();
                writer.write_all(b"// EDITORS BEWARE: Your modifications may be overridden\n").unwrap();
                write!(writer, "// Source: {}\n\n", spec_file).unwrap();

                protocol.write_rust(&protocol, &mut writer)
                    .expect(&format!("Failed to generate {}", spec_path.display()));
            }

            Ok(out)
        })
        .collect::<Result<Vec<_>, _>>()
        .expect("Failed to compile files");

        if cfg!(feature = "rustfmt") {
            format_files(paths.into_iter())
        }
}

#[cfg(not(feature = "rustfmt"))]
fn format_files<I>(_: I)
    where I: Iterator<Item = PathBuf>
{}

#[cfg(feature = "rustfmt")]
fn format_files<I>(paths: I)
    where I: Iterator<Item = PathBuf>,
{
    use rustfmt::Input;
    use rustfmt::config::{self as fmtconfig};

    let config = {
        let mut config = fmtconfig::Config::default();
        config.write_mode = fmtconfig::WriteMode::Overwrite;
        config
    };

    for path in paths {
        let _ = rustfmt::run(Input::File(path), &config);
    }
}


#[derive(Debug)]
enum Error {
    Parse(ParseError),
    Io(io::Error),
}

impl<'a> From<io::Error> for Error {
    fn from(error: io::Error) -> Self {
        Error::Io(error)
    }
}

impl<'a> From<ParseError> for Error {
    fn from(error: ParseError) -> Self {
        Error::Parse(error)
    }
}