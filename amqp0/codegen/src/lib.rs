// Copyright 2016 Alexander Reece
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

#![cfg_attr(feature="clippy", feature(plugin))]
#![cfg_attr(feature="clippy", plugin(clippy))]
#![cfg_attr(not(feature="clippy"), allow(unknown_lints))]

extern crate amqp0_specs as specs;
extern crate inflections;

#[cfg(feature = "rustfmt")]
extern crate rustfmt;

pub mod primalgen;
pub mod parsergen;

mod common;

use std::fs::{self, File};
use std::io::{self, BufWriter};
use std::path::{Path, PathBuf};

pub trait Builder {
    fn name(&self) -> &str;
    fn crates(&self) -> &[&str];
    fn rebuild_features(&self) -> &[&str];
    fn pregeneration_features(&self) -> &[&str];
}

pub trait CodeGenerator {
    fn write_rust_to<W>(&self, &mut W) -> io::Result<()>
        where W: io::Write;
}

pub struct CodeWriter<B: Builder, G: CodeGenerator> {
    builder: B,
    generator: G,
}

impl<B, G> CodeWriter<B, G>
    where B: Builder,
          G: CodeGenerator
{
    pub fn new(builder: B, generator: G) -> Self {
        CodeWriter {
            builder: builder,
            generator: generator,
        }
    }

    pub fn write_to_path<P>(&self, path: &P) -> io::Result<()>
        where P: AsRef<Path>
    {
        let path = path.as_ref();
        let parent = path.parent().unwrap();
        try!(fs::create_dir_all(parent));

        let file = try!(File::create(path));
        let mut writer = BufWriter::new(file);
        try!(self.write_header_to(&mut writer));
        try!(self.generator.write_rust_to(&mut writer));

        Ok(())
    }

    fn write_header_to<W>(&self, writer: &mut W) -> io::Result<()>
        where W: io::Write
    {
        writeln!(writer, "\
// Generated by build.rs script in {}
// Pre-generated files are used by default. Generation is done with the {} crate{}
//
// To regenerate, and not use pre-generated files, use: cargo --features=\"{}\"
// To format and replace the pre-generated files, use: cargo --features=\"{}\"
//
// EDITORS BEWARE: Your modifications may be overridden",
                 self.builder.name(),
                 self.builder.crates().join(", "),
                 if self.builder.crates().len() != 1 { "s" } else { "" },
                 self.builder.rebuild_features().join(" "),
                 self.builder.pregeneration_features().join(" ")
        )
    }
}

#[cfg(not(feature = "rustfmt"))]
pub fn format_files(_: Vec<PathBuf>) {}

#[cfg(feature = "rustfmt")]
#[doc(hidden)]
pub fn format_files(paths: Vec<PathBuf>) {
    use rustfmt::Input;
    use rustfmt::config::{self as fmtconfig};

    let config = {
    let mut config = fmtconfig::Config::default();
        config.write_mode = fmtconfig::WriteMode::Overwrite;
        config
    };

    for path in paths {
        println ! ("Formatting {}", path.display());
        let summary = rustfmt::run(Input::File(path), & config);
        println!("rustfmt Summary: {:?}", summary)
    }
}