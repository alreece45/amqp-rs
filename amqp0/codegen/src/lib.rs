// Copyright 2016 Alexander Reece
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

#![cfg_attr(feature="clippy", feature(plugin))]
#![cfg_attr(feature="clippy", plugin(clippy))]
#![cfg_attr(not(feature="clippy"), allow(unknown_lints))]

#[macro_use]
extern crate log;

extern crate amqp0_specs as specs;
extern crate inflections;
extern crate lazycell;
extern crate phf;

#[cfg(feature = "rustfmt")]
extern crate rustfmt;

pub mod primalgen;
pub mod parsergen;

mod common;

use std::fs::{self, File};
use std::io::{self, BufWriter};
use std::path::{Path, PathBuf};

pub use common::{Specs, Spec, Class, ClassMethod};

pub trait Source {
    fn name(&self) -> &str;
    fn crates(&self) -> &[&str];

    fn rebuild_features(&self) -> &[&str];
    fn pregeneration_features(&self) -> &[&str];

    fn base_dir(&self) -> &Path;
    fn should_format(&self) -> bool;

    fn write_header_to<W>(&self, writer: &mut W) -> io::Result<()>
        where W: io::Write
    {
        writeln!(writer, "\
// Generated by build.rs script in the {} crate.
// Pre-generated files are used by default. Generation is done with the {} crate{}.
//
// To regenerate, ignoring the pre-generated files, use: cargo --features=\"{}\"
// To format and replace the pre-generated files, use: cargo --features=\"{}\"
//
// EDITORS BEWARE: Your modifications may be overridden or removed.",
             self.name(),
             self.crates().join(", "),
             if self.crates().len() != 1 { "s" } else { "" },
             self.rebuild_features().join(" "),
             self.pregeneration_features().join(" ")
        )
    }
}

pub trait WriteRust {
    fn write_rust_to<W>(&self, &mut W) -> io::Result<()>
        where W: io::Write;

    fn write_rust_to_path<S, P>(&self, source: &S, path: &P) -> io::Result<()>
        where S: Source,
              P: AsRef<Path>
    {
        let path = path.as_ref();

        // create directory
        let parent = path.parent().unwrap();
        try!(fs::create_dir_all(parent));

        // create file and write contents
        let mut writer = BufWriter::new(try!(File::create(path)));
        try!(source.write_header_to(&mut writer));
        try!(self.write_rust_to(&mut writer));

        Ok(())
    }
}

#[cfg(not(feature = "rustfmt"))]
#[doc(hidden)]
fn format_files(_: Vec<PathBuf>) {}

#[cfg(feature = "rustfmt")]
#[doc(hidden)]
fn format_files(paths: Vec<PathBuf>) {
    use rustfmt::Input;
    use rustfmt::config::{self as fmtconfig};

    let config = {
    let mut config = fmtconfig::Config::default();
        config.write_mode = fmtconfig::WriteMode::Overwrite;
        config
    };

    for path in paths {
        println!("Formatting {}", path.display());
        let summary = rustfmt::run(Input::File(path), &config);
        println!("rustfmt Summary: {:?}", summary)
    }
}