// Copyright 2016 Alexander Reece
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

#![cfg_attr(feature="clippy", feature(plugin))]
#![cfg_attr(feature="clippy", plugin(clippy))]
#![cfg_attr(not(feature="clippy"), allow(unknown_lints))]

extern crate env_logger;
#[cfg(feature = "rustfmt")]
extern crate rustfmt;

#[cfg(any(feature = "amqp0-build-primitives", feature = "amqp0-pregen-primitives"))]
extern crate amqp0_codegen as codegen;
#[cfg(any(feature = "amqp0-build-primitives", feature = "amqp0-pregen-primitives"))]
extern crate amqp0_specs as specs;

fn main() {
    amqp0::build();
}

#[cfg(not(any(feature = "amqp0-build-primitives", feature = "amqp0-pregen-primitives")))]
mod amqp0 {
    pub fn build() {
        println!("Skipping build (neither amqp0-build-primitives nor amqp0-pregen-primitives specified)");
    }
}

#[cfg(any(feature = "amqp0-build-primitives", feature = "amqp0-pregen-primitives"))]
mod amqp0 {
    use std::env;
    use std::fs::{self, File};
    use std::io::{self, Write, BufWriter};
    use std::path::{Path, PathBuf};

    use env_logger;
    #[cfg(feature = "rustfmt")]
    use rustfmt;

    use codegen::primalgen::{CommonSpecs, CommonSpecsWriter, SpecWriter};
    use specs::specs as amqp0_specs;

    pub fn build() {
        env_logger::init().unwrap();
        println!("Building primitives from amqpspec");

        let out_path = env::var_os("OUT_DIR").map(PathBuf::from).expect("Error: OUT_DIR not set");

        // amqp0 specs
        let amqp0_specs = CommonSpecs::new(amqp0_specs());
        let paths = write_amqp0_specs(&out_path, amqp0_specs);

        // file(s) needs to be dropped before reaching here
        if cfg!(feature = "rustfmt") {
            let paths = paths.iter()
                .map(|p| p.to_path_buf())
                .collect();
            format_files(paths);
        }

        if cfg!(feature = "amqp0-pregen-primitives") {
            let pregen_dir = Path::new("pregen");
            for path in paths {
                let suffix = path.strip_prefix(&out_path).unwrap();
                let dst = pregen_dir.join(suffix);
                println!("Saving to {} to {}", path.display(), dst.display());
                fs::copy(&path, dst).unwrap();
            }
        }
    }

    #[cfg(not(feature = "rustfmt"))]
    fn format_files(_: Vec<PathBuf>) {}

    #[cfg(feature = "rustfmt")]
    fn format_files(paths: Vec<PathBuf>) {
        use rustfmt::Input;
        use rustfmt::config::{self as fmtconfig};

        let config = {
            let mut config = fmtconfig::Config::default();
            config.write_mode = fmtconfig::WriteMode::Overwrite;
            config
        };

        for path in paths {
            println!("Formatting {}", path.display());
            let summary = rustfmt::run(Input::File(path), &config);
            println!("Summary: {:?}", summary)
        }
    }

    fn write_header<W>(writer: &mut W)
        where W: io::Write
    {
        writeln!(writer, "// Generated by build script in amqp0-primitives").unwrap();
        writeln!(writer, "// Pregenerated files are used by default.").unwrap();
        writeln!(writer, "// ").unwrap();
        writeln!(writer, "// Build using amqp0-pregen crate using: cargo --features=\"amqp0-build-primitives\"").unwrap();
        writeln!(writer, "// Regenerate pregenerated scripts using: cargo --features=\"amqp0-pregen-primitives\"").unwrap();
        writeln!(writer, "// ").unwrap();
        writeln!(writer, "// EDITORS BEWARE: Your modifications may be overridden\n").unwrap();
    }

    fn write_amqp0_specs(path: &Path, specs: CommonSpecs) -> Vec<PathBuf> {
        if !path.is_dir() {
            println!("Creating directory: {}", path.display());
            if fs::create_dir_all(path).is_err() {
                panic!("Unable to create {}", path.display())
            }
        }

        let mut paths = Vec::with_capacity(1 + specs.len());
        let common = path.join("mod.rs");
        println!("amqp0: {}", path.display());

        {
            let file = File::create(&common).expect("Failed to open primalgen.spec.rs");
            let mut common_writer = BufWriter::new(file);
            write_header(&mut common_writer);

            for spec in specs.iter() {
                let spec_writer = SpecWriter::new(spec);
                println!("Spec [{}]: {}", spec_writer.mod_name(), path.display());

                let path = path.join(format!("{}.rs", spec_writer.mod_name()));
                {
                    let file = match File::create(&path) {
                        Ok(f) => f,
                        Err(e) => panic!("Error opening file [{}]: {:?}", path.display(), e),
                    };

                    let mut writer = BufWriter::new(file);
                    write_header(&mut writer);
                    writeln!(writer, "#![allow(too_many_arguments)]\n").unwrap();

                    spec_writer.write(&mut writer).unwrap();

                    writeln!(common_writer, "pub mod {};", spec_writer.mod_name()).unwrap();
                }
                paths.push(path);
            }

            let common = CommonSpecsWriter::new(&specs);
            common.write(&mut common_writer).unwrap();
        }

        paths.push(common);

        paths
    }
}