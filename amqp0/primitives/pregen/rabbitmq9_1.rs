/// Generated by build script in amqp0-primitives
/// Pregenerated files are used by default.
///
/// Build using amqp0-pregen crate using: cargo --features="amqp0-build-primitives"
/// Regenerate pregenerated scripts using: cargo --features="amqp0-pregen-primitives"
///
// EDITORS BEWARE: Your modifications may be overridden

// Class Constants
pub const CLASS_BASIC: u16 = 60;
pub const CLASS_CHANNEL: u16 = 20;
pub const CLASS_CONFIRM: u16 = 85;
pub const CLASS_CONNECTION: u16 = 10;
pub const CLASS_EXCHANGE: u16 = 40;
pub const CLASS_QUEUE: u16 = 50;
pub const CLASS_TX: u16 = 90;

// Class Methods
pub const METHOD_BASIC_QOS: u16 = 10;
pub const METHOD_BASIC_QOS_OK: u16 = 11;
pub const METHOD_BASIC_CONSUME: u16 = 20;
pub const METHOD_BASIC_CONSUME_OK: u16 = 21;
pub const METHOD_BASIC_CANCEL: u16 = 30;
pub const METHOD_BASIC_CANCEL_OK: u16 = 31;
pub const METHOD_BASIC_PUBLISH: u16 = 40;
pub const METHOD_BASIC_RETURN: u16 = 50;
pub const METHOD_BASIC_DELIVER: u16 = 60;
pub const METHOD_BASIC_GET: u16 = 70;
pub const METHOD_BASIC_GET_OK: u16 = 71;
pub const METHOD_BASIC_GET_EMPTY: u16 = 72;
pub const METHOD_BASIC_ACK: u16 = 80;
pub const METHOD_BASIC_REJECT: u16 = 90;
pub const METHOD_BASIC_RECOVER_ASYNC: u16 = 100;
pub const METHOD_BASIC_RECOVER: u16 = 110;
pub const METHOD_BASIC_RECOVER_OK: u16 = 111;
pub const METHOD_BASIC_NACK: u16 = 120;

pub const METHOD_CHANNEL_OPEN: u16 = 10;
pub const METHOD_CHANNEL_OPEN_OK: u16 = 11;
pub const METHOD_CHANNEL_FLOW: u16 = 20;
pub const METHOD_CHANNEL_FLOW_OK: u16 = 21;
pub const METHOD_CHANNEL_CLOSE: u16 = 40;
pub const METHOD_CHANNEL_CLOSE_OK: u16 = 41;

pub const METHOD_CONFIRM_SELECT: u16 = 10;
pub const METHOD_CONFIRM_SELECT_OK: u16 = 11;

pub const METHOD_CONNECTION_START: u16 = 10;
pub const METHOD_CONNECTION_START_OK: u16 = 11;
pub const METHOD_CONNECTION_SECURE: u16 = 20;
pub const METHOD_CONNECTION_SECURE_OK: u16 = 21;
pub const METHOD_CONNECTION_TUNE: u16 = 30;
pub const METHOD_CONNECTION_TUNE_OK: u16 = 31;
pub const METHOD_CONNECTION_OPEN: u16 = 40;
pub const METHOD_CONNECTION_OPEN_OK: u16 = 41;
pub const METHOD_CONNECTION_CLOSE: u16 = 50;
pub const METHOD_CONNECTION_CLOSE_OK: u16 = 51;
pub const METHOD_CONNECTION_BLOCKED: u16 = 60;
pub const METHOD_CONNECTION_UNBLOCKED: u16 = 61;

pub const METHOD_EXCHANGE_DECLARE: u16 = 10;
pub const METHOD_EXCHANGE_DECLARE_OK: u16 = 11;
pub const METHOD_EXCHANGE_DELETE: u16 = 20;
pub const METHOD_EXCHANGE_DELETE_OK: u16 = 21;
pub const METHOD_EXCHANGE_BIND: u16 = 30;
pub const METHOD_EXCHANGE_BIND_OK: u16 = 31;
pub const METHOD_EXCHANGE_UNBIND: u16 = 40;
pub const METHOD_EXCHANGE_UNBIND_OK: u16 = 51;

pub const METHOD_QUEUE_DECLARE: u16 = 10;
pub const METHOD_QUEUE_DECLARE_OK: u16 = 11;
pub const METHOD_QUEUE_BIND: u16 = 20;
pub const METHOD_QUEUE_BIND_OK: u16 = 21;
pub const METHOD_QUEUE_UNBIND: u16 = 50;
pub const METHOD_QUEUE_UNBIND_OK: u16 = 51;
pub const METHOD_QUEUE_PURGE: u16 = 30;
pub const METHOD_QUEUE_PURGE_OK: u16 = 31;
pub const METHOD_QUEUE_DELETE: u16 = 40;
pub const METHOD_QUEUE_DELETE_OK: u16 = 41;

pub const METHOD_TX_SELECT: u16 = 10;
pub const METHOD_TX_SELECT_OK: u16 = 11;
pub const METHOD_TX_COMMIT: u16 = 20;
pub const METHOD_TX_COMMIT_OK: u16 = 21;
pub const METHOD_TX_ROLLBACK: u16 = 30;
pub const METHOD_TX_ROLLBACK_OK: u16 = 31;

// Class Modules
pub mod basic {
    pub struct Properties<'a> {
        content_type: Option<::std::borrow::Cow<'a, str>>,
        content_encoding: Option<::std::borrow::Cow<'a, str>>,
        headers: Option<::std::borrow::Cow<'a, ::field::Table<'a>>>,
        delivery_mode: Option<u8>,
        priority: Option<u8>,
        correlation_id: Option<::std::borrow::Cow<'a, str>>,
        reply_to: Option<::std::borrow::Cow<'a, str>>,
        expiration: Option<::std::borrow::Cow<'a, str>>,
        message_id: Option<::std::borrow::Cow<'a, str>>,
        timestamp: Option<u64>,
        ty: Option<::std::borrow::Cow<'a, str>>,
        user_id: Option<::std::borrow::Cow<'a, str>>,
        app_id: Option<::std::borrow::Cow<'a, str>>,
        reserved: Option<::std::borrow::Cow<'a, str>>,
    }

    impl<'a> Properties<'a> {
        pub fn content_type(&self) -> Option<&str> {
            self.content_type.as_ref().map(|v| &**v)
        }
        pub fn content_encoding(&self) -> Option<&str> {
            self.content_encoding.as_ref().map(|v| &**v)
        }
        pub fn headers(&self) -> Option<&::field::Table<'a>> {
            self.headers.as_ref().map(|v| &**v)
        }
        pub fn delivery_mode(&self) -> Option<u8> {
            self.delivery_mode
        }
        pub fn priority(&self) -> Option<u8> {
            self.priority
        }
        pub fn correlation_id(&self) -> Option<&str> {
            self.correlation_id.as_ref().map(|v| &**v)
        }
        pub fn reply_to(&self) -> Option<&str> {
            self.reply_to.as_ref().map(|v| &**v)
        }
        pub fn expiration(&self) -> Option<&str> {
            self.expiration.as_ref().map(|v| &**v)
        }
        pub fn message_id(&self) -> Option<&str> {
            self.message_id.as_ref().map(|v| &**v)
        }
        pub fn timestamp(&self) -> Option<u64> {
            self.timestamp
        }
        pub fn ty(&self) -> Option<&str> {
            self.ty.as_ref().map(|v| &**v)
        }
        pub fn user_id(&self) -> Option<&str> {
            self.user_id.as_ref().map(|v| &**v)
        }
        pub fn app_id(&self) -> Option<&str> {
            self.app_id.as_ref().map(|v| &**v)
        }
        pub fn reserved(&self) -> Option<&str> {
            self.reserved.as_ref().map(|v| &**v)
        }
    }
    pub struct Qos {
        prefetch_size: u32,
        prefetch_count: u16,
        global: bool,
    }
    impl Qos {
        pub fn new(prefetch_size: u32, prefetch_count: u16, global: bool) -> Self {
            Qos {
                prefetch_size: prefetch_size,
                prefetch_count: prefetch_count,
                global: global,
            }
        }
        pub fn prefetch_size(&self) -> u32 {
            self.prefetch_size
        }
        pub fn prefetch_count(&self) -> u16 {
            self.prefetch_count
        }
        pub fn global(&self) -> bool {
            self.global
        }
    }
    impl ::Payload for Qos {
        fn class_id(&self) -> u16 {
            60
        }
        fn method_id(&self) -> u16 {
            10
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            7
        }
    }
    pub struct QosOk;
    impl QosOk {
        pub fn new() -> Self {
            QosOk
        }
    }
    impl ::Payload for QosOk {
        fn class_id(&self) -> u16 {
            60
        }
        fn method_id(&self) -> u16 {
            11
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            0
        }
    }
    pub struct Consume<'a> {
        queue: ::std::borrow::Cow<'a, str>,
        consumer_tag: ::std::borrow::Cow<'a, str>,
        no_local: bool,
        no_ack: bool,
        exclusive: bool,
        no_wait: bool,
        arguments: ::std::borrow::Cow<'a, ::field::Table<'a>>,
    }
    impl<'a> Consume<'a> {
        pub fn new<Q, C, A>(queue: Q,
                            consumer_tag: C,
                            no_local: bool,
                            no_ack: bool,
                            exclusive: bool,
                            no_wait: bool,
                            arguments: A)
                            -> Self
            where Q: Into<::std::borrow::Cow<'a, str>>,
                  C: Into<::std::borrow::Cow<'a, str>>,
                  A: Into<::std::borrow::Cow<'a, ::field::Table<'a>>>
        {
            Consume {
                queue: queue.into(),
                consumer_tag: consumer_tag.into(),
                no_local: no_local,
                no_ack: no_ack,
                exclusive: exclusive,
                no_wait: no_wait,
                arguments: arguments.into(),
            }
        }
        pub fn queue(&self) -> &str {
            &*self.queue
        }
        pub fn consumer_tag(&self) -> &str {
            &*self.consumer_tag
        }
        pub fn no_local(&self) -> bool {
            self.no_local
        }
        pub fn no_ack(&self) -> bool {
            self.no_ack
        }
        pub fn exclusive(&self) -> bool {
            self.exclusive
        }
        pub fn no_wait(&self) -> bool {
            self.no_wait
        }
        pub fn arguments(&self) -> &::field::Table<'a> {
            &*self.arguments
        }
    }
    impl<'a> ::Payload for Consume<'a> {
        fn class_id(&self) -> u16 {
            60
        }
        fn method_id(&self) -> u16 {
            20
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [5, self.queue.len(), self.consumer_tag.len(), self.arguments.amqp_size()]
                .iter()
                .sum()
        }
    }
    pub struct ConsumeOk<'a> {
        consumer_tag: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ConsumeOk<'a> {
        pub fn new<C>(consumer_tag: C) -> Self
            where C: Into<::std::borrow::Cow<'a, str>>
        {
            ConsumeOk { consumer_tag: consumer_tag.into() }
        }
        pub fn consumer_tag(&self) -> &str {
            &*self.consumer_tag
        }
    }
    impl<'a> ::Payload for ConsumeOk<'a> {
        fn class_id(&self) -> u16 {
            60
        }
        fn method_id(&self) -> u16 {
            21
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [1, self.consumer_tag.len()]
                .iter()
                .sum()
        }
    }
    pub struct Cancel<'a> {
        consumer_tag: ::std::borrow::Cow<'a, str>,
        no_wait: bool,
    }
    impl<'a> Cancel<'a> {
        pub fn new<C>(consumer_tag: C, no_wait: bool) -> Self
            where C: Into<::std::borrow::Cow<'a, str>>
        {
            Cancel {
                consumer_tag: consumer_tag.into(),
                no_wait: no_wait,
            }
        }
        pub fn consumer_tag(&self) -> &str {
            &*self.consumer_tag
        }
        pub fn no_wait(&self) -> bool {
            self.no_wait
        }
    }
    impl<'a> ::Payload for Cancel<'a> {
        fn class_id(&self) -> u16 {
            60
        }
        fn method_id(&self) -> u16 {
            30
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [2, self.consumer_tag.len()]
                .iter()
                .sum()
        }
    }
    pub struct CancelOk<'a> {
        consumer_tag: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> CancelOk<'a> {
        pub fn new<C>(consumer_tag: C) -> Self
            where C: Into<::std::borrow::Cow<'a, str>>
        {
            CancelOk { consumer_tag: consumer_tag.into() }
        }
        pub fn consumer_tag(&self) -> &str {
            &*self.consumer_tag
        }
    }
    impl<'a> ::Payload for CancelOk<'a> {
        fn class_id(&self) -> u16 {
            60
        }
        fn method_id(&self) -> u16 {
            31
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [1, self.consumer_tag.len()]
                .iter()
                .sum()
        }
    }
    pub struct Publish<'a> {
        exchange: ::std::borrow::Cow<'a, str>,
        routing_key: ::std::borrow::Cow<'a, str>,
        mandatory: bool,
        immediate: bool,
    }
    impl<'a> Publish<'a> {
        pub fn new<E, R>(exchange: E, routing_key: R, mandatory: bool, immediate: bool) -> Self
            where E: Into<::std::borrow::Cow<'a, str>>,
                  R: Into<::std::borrow::Cow<'a, str>>
        {
            Publish {
                exchange: exchange.into(),
                routing_key: routing_key.into(),
                mandatory: mandatory,
                immediate: immediate,
            }
        }
        pub fn exchange(&self) -> &str {
            &*self.exchange
        }
        pub fn routing_key(&self) -> &str {
            &*self.routing_key
        }
        pub fn mandatory(&self) -> bool {
            self.mandatory
        }
        pub fn immediate(&self) -> bool {
            self.immediate
        }
    }
    impl<'a> ::Payload for Publish<'a> {
        fn class_id(&self) -> u16 {
            60
        }
        fn method_id(&self) -> u16 {
            40
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [5, self.exchange.len(), self.routing_key.len()]
                .iter()
                .sum()
        }
    }
    pub struct Return<'a> {
        reply_code: u16,
        reply_text: ::std::borrow::Cow<'a, str>,
        exchange: ::std::borrow::Cow<'a, str>,
        routing_key: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> Return<'a> {
        pub fn new<R, E, R0>(reply_code: u16, reply_text: R, exchange: E, routing_key: R0) -> Self
            where R: Into<::std::borrow::Cow<'a, str>>,
                  E: Into<::std::borrow::Cow<'a, str>>,
                  R0: Into<::std::borrow::Cow<'a, str>>
        {
            Return {
                reply_code: reply_code,
                reply_text: reply_text.into(),
                exchange: exchange.into(),
                routing_key: routing_key.into(),
            }
        }
        pub fn reply_code(&self) -> u16 {
            self.reply_code
        }
        pub fn reply_text(&self) -> &str {
            &*self.reply_text
        }
        pub fn exchange(&self) -> &str {
            &*self.exchange
        }
        pub fn routing_key(&self) -> &str {
            &*self.routing_key
        }
    }
    impl<'a> ::Payload for Return<'a> {
        fn class_id(&self) -> u16 {
            60
        }
        fn method_id(&self) -> u16 {
            50
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [5, self.reply_text.len(), self.exchange.len(), self.routing_key.len()]
                .iter()
                .sum()
        }
    }
    pub struct Deliver<'a> {
        consumer_tag: ::std::borrow::Cow<'a, str>,
        delivery_tag: u64,
        redelivered: bool,
        exchange: ::std::borrow::Cow<'a, str>,
        routing_key: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> Deliver<'a> {
        pub fn new<C, E, R>(consumer_tag: C,
                            delivery_tag: u64,
                            redelivered: bool,
                            exchange: E,
                            routing_key: R)
                            -> Self
            where C: Into<::std::borrow::Cow<'a, str>>,
                  E: Into<::std::borrow::Cow<'a, str>>,
                  R: Into<::std::borrow::Cow<'a, str>>
        {
            Deliver {
                consumer_tag: consumer_tag.into(),
                delivery_tag: delivery_tag,
                redelivered: redelivered,
                exchange: exchange.into(),
                routing_key: routing_key.into(),
            }
        }
        pub fn consumer_tag(&self) -> &str {
            &*self.consumer_tag
        }
        pub fn delivery_tag(&self) -> u64 {
            self.delivery_tag
        }
        pub fn redelivered(&self) -> bool {
            self.redelivered
        }
        pub fn exchange(&self) -> &str {
            &*self.exchange
        }
        pub fn routing_key(&self) -> &str {
            &*self.routing_key
        }
    }
    impl<'a> ::Payload for Deliver<'a> {
        fn class_id(&self) -> u16 {
            60
        }
        fn method_id(&self) -> u16 {
            60
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [12, self.consumer_tag.len(), self.exchange.len(), self.routing_key.len()]
                .iter()
                .sum()
        }
    }
    pub struct Get<'a> {
        queue: ::std::borrow::Cow<'a, str>,
        no_ack: bool,
    }
    impl<'a> Get<'a> {
        pub fn new<Q>(queue: Q, no_ack: bool) -> Self
            where Q: Into<::std::borrow::Cow<'a, str>>
        {
            Get {
                queue: queue.into(),
                no_ack: no_ack,
            }
        }
        pub fn queue(&self) -> &str {
            &*self.queue
        }
        pub fn no_ack(&self) -> bool {
            self.no_ack
        }
    }
    impl<'a> ::Payload for Get<'a> {
        fn class_id(&self) -> u16 {
            60
        }
        fn method_id(&self) -> u16 {
            70
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [4, self.queue.len()]
                .iter()
                .sum()
        }
    }
    pub struct GetOk<'a> {
        delivery_tag: u64,
        redelivered: bool,
        exchange: ::std::borrow::Cow<'a, str>,
        routing_key: ::std::borrow::Cow<'a, str>,
        message_count: u32,
    }
    impl<'a> GetOk<'a> {
        pub fn new<E, R>(delivery_tag: u64,
                         redelivered: bool,
                         exchange: E,
                         routing_key: R,
                         message_count: u32)
                         -> Self
            where E: Into<::std::borrow::Cow<'a, str>>,
                  R: Into<::std::borrow::Cow<'a, str>>
        {
            GetOk {
                delivery_tag: delivery_tag,
                redelivered: redelivered,
                exchange: exchange.into(),
                routing_key: routing_key.into(),
                message_count: message_count,
            }
        }
        pub fn delivery_tag(&self) -> u64 {
            self.delivery_tag
        }
        pub fn redelivered(&self) -> bool {
            self.redelivered
        }
        pub fn exchange(&self) -> &str {
            &*self.exchange
        }
        pub fn routing_key(&self) -> &str {
            &*self.routing_key
        }
        pub fn message_count(&self) -> u32 {
            self.message_count
        }
    }
    impl<'a> ::Payload for GetOk<'a> {
        fn class_id(&self) -> u16 {
            60
        }
        fn method_id(&self) -> u16 {
            71
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [15, self.exchange.len(), self.routing_key.len()]
                .iter()
                .sum()
        }
    }
    pub struct GetEmpty {
}
    impl GetEmpty {
        pub fn new() -> Self {
            GetEmpty {}
        }
    }
    impl ::Payload for GetEmpty {
        fn class_id(&self) -> u16 {
            60
        }
        fn method_id(&self) -> u16 {
            72
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [1].iter()
                .sum()
        }
    }
    pub struct Ack {
        delivery_tag: u64,
        multiple: bool,
    }
    impl Ack {
        pub fn new(delivery_tag: u64, multiple: bool) -> Self {
            Ack {
                delivery_tag: delivery_tag,
                multiple: multiple,
            }
        }
        pub fn delivery_tag(&self) -> u64 {
            self.delivery_tag
        }
        pub fn multiple(&self) -> bool {
            self.multiple
        }
    }
    impl ::Payload for Ack {
        fn class_id(&self) -> u16 {
            60
        }
        fn method_id(&self) -> u16 {
            80
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            9
        }
    }
    pub struct Reject {
        delivery_tag: u64,
        requeue: bool,
    }
    impl Reject {
        pub fn new(delivery_tag: u64, requeue: bool) -> Self {
            Reject {
                delivery_tag: delivery_tag,
                requeue: requeue,
            }
        }
        pub fn delivery_tag(&self) -> u64 {
            self.delivery_tag
        }
        pub fn requeue(&self) -> bool {
            self.requeue
        }
    }
    impl ::Payload for Reject {
        fn class_id(&self) -> u16 {
            60
        }
        fn method_id(&self) -> u16 {
            90
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            9
        }
    }
    pub struct RecoverAsync {
        requeue: bool,
    }
    impl RecoverAsync {
        pub fn new(requeue: bool) -> Self {
            RecoverAsync { requeue: requeue }
        }
        pub fn requeue(&self) -> bool {
            self.requeue
        }
    }
    impl ::Payload for RecoverAsync {
        fn class_id(&self) -> u16 {
            60
        }
        fn method_id(&self) -> u16 {
            100
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            1
        }
    }
    pub struct Recover {
        requeue: bool,
    }
    impl Recover {
        pub fn new(requeue: bool) -> Self {
            Recover { requeue: requeue }
        }
        pub fn requeue(&self) -> bool {
            self.requeue
        }
    }
    impl ::Payload for Recover {
        fn class_id(&self) -> u16 {
            60
        }
        fn method_id(&self) -> u16 {
            110
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            1
        }
    }
    pub struct RecoverOk;
    impl RecoverOk {
        pub fn new() -> Self {
            RecoverOk
        }
    }
    impl ::Payload for RecoverOk {
        fn class_id(&self) -> u16 {
            60
        }
        fn method_id(&self) -> u16 {
            111
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            0
        }
    }
    pub struct Nack {
        delivery_tag: u64,
        multiple: bool,
        requeue: bool,
    }
    impl Nack {
        pub fn new(delivery_tag: u64, multiple: bool, requeue: bool) -> Self {
            Nack {
                delivery_tag: delivery_tag,
                multiple: multiple,
                requeue: requeue,
            }
        }
        pub fn delivery_tag(&self) -> u64 {
            self.delivery_tag
        }
        pub fn multiple(&self) -> bool {
            self.multiple
        }
        pub fn requeue(&self) -> bool {
            self.requeue
        }
    }
    impl ::Payload for Nack {
        fn class_id(&self) -> u16 {
            60
        }
        fn method_id(&self) -> u16 {
            120
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            9
        }
    }
}
pub mod channel {
    pub struct Properties;
    impl Properties {}
    pub struct Open {
}
    impl Open {
        pub fn new() -> Self {
            Open {}
        }
    }
    impl ::Payload for Open {
        fn class_id(&self) -> u16 {
            20
        }
        fn method_id(&self) -> u16 {
            10
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [1].iter()
                .sum()
        }
    }
    pub struct OpenOk {
}
    impl OpenOk {
        pub fn new() -> Self {
            OpenOk {}
        }
    }
    impl ::Payload for OpenOk {
        fn class_id(&self) -> u16 {
            20
        }
        fn method_id(&self) -> u16 {
            11
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [2].iter()
                .sum()
        }
    }
    pub struct Flow {
        active: bool,
    }
    impl Flow {
        pub fn new(active: bool) -> Self {
            Flow { active: active }
        }
        pub fn active(&self) -> bool {
            self.active
        }
    }
    impl ::Payload for Flow {
        fn class_id(&self) -> u16 {
            20
        }
        fn method_id(&self) -> u16 {
            20
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            1
        }
    }
    pub struct FlowOk {
        active: bool,
    }
    impl FlowOk {
        pub fn new(active: bool) -> Self {
            FlowOk { active: active }
        }
        pub fn active(&self) -> bool {
            self.active
        }
    }
    impl ::Payload for FlowOk {
        fn class_id(&self) -> u16 {
            20
        }
        fn method_id(&self) -> u16 {
            21
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            1
        }
    }
    pub struct Close<'a> {
        reply_code: u16,
        reply_text: ::std::borrow::Cow<'a, str>,
        class_id: u16,
        method_id: u16,
    }
    impl<'a> Close<'a> {
        pub fn new<R>(reply_code: u16, reply_text: R, class_id: u16, method_id: u16) -> Self
            where R: Into<::std::borrow::Cow<'a, str>>
        {
            Close {
                reply_code: reply_code,
                reply_text: reply_text.into(),
                class_id: class_id,
                method_id: method_id,
            }
        }
        pub fn reply_code(&self) -> u16 {
            self.reply_code
        }
        pub fn reply_text(&self) -> &str {
            &*self.reply_text
        }
        pub fn class_id(&self) -> u16 {
            self.class_id
        }
        pub fn method_id(&self) -> u16 {
            self.method_id
        }
    }
    impl<'a> ::Payload for Close<'a> {
        fn class_id(&self) -> u16 {
            20
        }
        fn method_id(&self) -> u16 {
            40
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [7, self.reply_text.len()]
                .iter()
                .sum()
        }
    }
    pub struct CloseOk;
    impl CloseOk {
        pub fn new() -> Self {
            CloseOk
        }
    }
    impl ::Payload for CloseOk {
        fn class_id(&self) -> u16 {
            20
        }
        fn method_id(&self) -> u16 {
            41
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            0
        }
    }
}
pub mod confirm {
    pub struct Properties;
    impl Properties {}
    pub struct Select {
        nowait: bool,
    }
    impl Select {
        pub fn new(nowait: bool) -> Self {
            Select { nowait: nowait }
        }
        pub fn nowait(&self) -> bool {
            self.nowait
        }
    }
    impl ::Payload for Select {
        fn class_id(&self) -> u16 {
            85
        }
        fn method_id(&self) -> u16 {
            10
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            1
        }
    }
    pub struct SelectOk;
    impl SelectOk {
        pub fn new() -> Self {
            SelectOk
        }
    }
    impl ::Payload for SelectOk {
        fn class_id(&self) -> u16 {
            85
        }
        fn method_id(&self) -> u16 {
            11
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            0
        }
    }
}
pub mod connection {
    pub struct Properties;
    impl Properties {}
    pub struct Start<'a> {
        version_major: u8,
        version_minor: u8,
        server_properties: ::std::borrow::Cow<'a, ::field::Table<'a>>,
        mechanisms: ::std::borrow::Cow<'a, [u8]>,
        locales: ::std::borrow::Cow<'a, [u8]>,
    }
    impl<'a> Start<'a> {
        pub fn new<S, M, L>(version_major: u8,
                            version_minor: u8,
                            server_properties: S,
                            mechanisms: M,
                            locales: L)
                            -> Self
            where S: Into<::std::borrow::Cow<'a, ::field::Table<'a>>>,
                  M: Into<::std::borrow::Cow<'a, [u8]>>,
                  L: Into<::std::borrow::Cow<'a, [u8]>>
        {
            Start {
                version_major: version_major,
                version_minor: version_minor,
                server_properties: server_properties.into(),
                mechanisms: mechanisms.into(),
                locales: locales.into(),
            }
        }
        pub fn version_major(&self) -> u8 {
            self.version_major
        }
        pub fn version_minor(&self) -> u8 {
            self.version_minor
        }
        pub fn server_properties(&self) -> &::field::Table<'a> {
            &*self.server_properties
        }
        pub fn mechanisms(&self) -> &[u8] {
            &*self.mechanisms
        }
        pub fn locales(&self) -> &[u8] {
            &*self.locales
        }
    }
    impl<'a> ::Payload for Start<'a> {
        fn class_id(&self) -> u16 {
            10
        }
        fn method_id(&self) -> u16 {
            10
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [6, self.server_properties.amqp_size(), self.mechanisms.len(), self.locales.len()]
                .iter()
                .sum()
        }
    }
    pub struct StartOk<'a> {
        client_properties: ::std::borrow::Cow<'a, ::field::Table<'a>>,
        mechanism: ::std::borrow::Cow<'a, str>,
        response: ::std::borrow::Cow<'a, [u8]>,
        locale: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> StartOk<'a> {
        pub fn new<C, M, R, L>(client_properties: C, mechanism: M, response: R, locale: L) -> Self
            where C: Into<::std::borrow::Cow<'a, ::field::Table<'a>>>,
                  M: Into<::std::borrow::Cow<'a, str>>,
                  R: Into<::std::borrow::Cow<'a, [u8]>>,
                  L: Into<::std::borrow::Cow<'a, str>>
        {
            StartOk {
                client_properties: client_properties.into(),
                mechanism: mechanism.into(),
                response: response.into(),
                locale: locale.into(),
            }
        }
        pub fn client_properties(&self) -> &::field::Table<'a> {
            &*self.client_properties
        }
        pub fn mechanism(&self) -> &str {
            &*self.mechanism
        }
        pub fn response(&self) -> &[u8] {
            &*self.response
        }
        pub fn locale(&self) -> &str {
            &*self.locale
        }
    }
    impl<'a> ::Payload for StartOk<'a> {
        fn class_id(&self) -> u16 {
            10
        }
        fn method_id(&self) -> u16 {
            11
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [4,
             self.client_properties.amqp_size(),
             self.mechanism.len(),
             self.response.len(),
             self.locale.len()]
                .iter()
                .sum()
        }
    }
    pub struct Secure<'a> {
        challenge: ::std::borrow::Cow<'a, [u8]>,
    }
    impl<'a> Secure<'a> {
        pub fn new<C>(challenge: C) -> Self
            where C: Into<::std::borrow::Cow<'a, [u8]>>
        {
            Secure { challenge: challenge.into() }
        }
        pub fn challenge(&self) -> &[u8] {
            &*self.challenge
        }
    }
    impl<'a> ::Payload for Secure<'a> {
        fn class_id(&self) -> u16 {
            10
        }
        fn method_id(&self) -> u16 {
            20
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [2, self.challenge.len()]
                .iter()
                .sum()
        }
    }
    pub struct SecureOk<'a> {
        response: ::std::borrow::Cow<'a, [u8]>,
    }
    impl<'a> SecureOk<'a> {
        pub fn new<R>(response: R) -> Self
            where R: Into<::std::borrow::Cow<'a, [u8]>>
        {
            SecureOk { response: response.into() }
        }
        pub fn response(&self) -> &[u8] {
            &*self.response
        }
    }
    impl<'a> ::Payload for SecureOk<'a> {
        fn class_id(&self) -> u16 {
            10
        }
        fn method_id(&self) -> u16 {
            21
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [2, self.response.len()]
                .iter()
                .sum()
        }
    }
    pub struct Tune {
        channel_max: u16,
        frame_max: u32,
        heartbeat: u16,
    }
    impl Tune {
        pub fn new(channel_max: u16, frame_max: u32, heartbeat: u16) -> Self {
            Tune {
                channel_max: channel_max,
                frame_max: frame_max,
                heartbeat: heartbeat,
            }
        }
        pub fn channel_max(&self) -> u16 {
            self.channel_max
        }
        pub fn frame_max(&self) -> u32 {
            self.frame_max
        }
        pub fn heartbeat(&self) -> u16 {
            self.heartbeat
        }
    }
    impl ::Payload for Tune {
        fn class_id(&self) -> u16 {
            10
        }
        fn method_id(&self) -> u16 {
            30
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            8
        }
    }
    pub struct TuneOk {
        channel_max: u16,
        frame_max: u32,
        heartbeat: u16,
    }
    impl TuneOk {
        pub fn new(channel_max: u16, frame_max: u32, heartbeat: u16) -> Self {
            TuneOk {
                channel_max: channel_max,
                frame_max: frame_max,
                heartbeat: heartbeat,
            }
        }
        pub fn channel_max(&self) -> u16 {
            self.channel_max
        }
        pub fn frame_max(&self) -> u32 {
            self.frame_max
        }
        pub fn heartbeat(&self) -> u16 {
            self.heartbeat
        }
    }
    impl ::Payload for TuneOk {
        fn class_id(&self) -> u16 {
            10
        }
        fn method_id(&self) -> u16 {
            31
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            8
        }
    }
    pub struct Open<'a> {
        virtual_host: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> Open<'a> {
        pub fn new<V>(virtual_host: V) -> Self
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            Open { virtual_host: virtual_host.into() }
        }
        pub fn virtual_host(&self) -> &str {
            &*self.virtual_host
        }
    }
    impl<'a> ::Payload for Open<'a> {
        fn class_id(&self) -> u16 {
            10
        }
        fn method_id(&self) -> u16 {
            40
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [3, self.virtual_host.len()]
                .iter()
                .sum()
        }
    }
    pub struct OpenOk {
}
    impl OpenOk {
        pub fn new() -> Self {
            OpenOk {}
        }
    }
    impl ::Payload for OpenOk {
        fn class_id(&self) -> u16 {
            10
        }
        fn method_id(&self) -> u16 {
            41
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [1].iter()
                .sum()
        }
    }
    pub struct Close<'a> {
        reply_code: u16,
        reply_text: ::std::borrow::Cow<'a, str>,
        class_id: u16,
        method_id: u16,
    }
    impl<'a> Close<'a> {
        pub fn new<R>(reply_code: u16, reply_text: R, class_id: u16, method_id: u16) -> Self
            where R: Into<::std::borrow::Cow<'a, str>>
        {
            Close {
                reply_code: reply_code,
                reply_text: reply_text.into(),
                class_id: class_id,
                method_id: method_id,
            }
        }
        pub fn reply_code(&self) -> u16 {
            self.reply_code
        }
        pub fn reply_text(&self) -> &str {
            &*self.reply_text
        }
        pub fn class_id(&self) -> u16 {
            self.class_id
        }
        pub fn method_id(&self) -> u16 {
            self.method_id
        }
    }
    impl<'a> ::Payload for Close<'a> {
        fn class_id(&self) -> u16 {
            10
        }
        fn method_id(&self) -> u16 {
            50
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [7, self.reply_text.len()]
                .iter()
                .sum()
        }
    }
    pub struct CloseOk;
    impl CloseOk {
        pub fn new() -> Self {
            CloseOk
        }
    }
    impl ::Payload for CloseOk {
        fn class_id(&self) -> u16 {
            10
        }
        fn method_id(&self) -> u16 {
            51
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            0
        }
    }
    pub struct Blocked<'a> {
        reason: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> Blocked<'a> {
        pub fn new<R>(reason: R) -> Self
            where R: Into<::std::borrow::Cow<'a, str>>
        {
            Blocked { reason: reason.into() }
        }
        pub fn reason(&self) -> &str {
            &*self.reason
        }
    }
    impl<'a> ::Payload for Blocked<'a> {
        fn class_id(&self) -> u16 {
            10
        }
        fn method_id(&self) -> u16 {
            60
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [1, self.reason.len()]
                .iter()
                .sum()
        }
    }
    pub struct Unblocked;
    impl Unblocked {
        pub fn new() -> Self {
            Unblocked
        }
    }
    impl ::Payload for Unblocked {
        fn class_id(&self) -> u16 {
            10
        }
        fn method_id(&self) -> u16 {
            61
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            0
        }
    }
}
pub mod exchange {
    pub struct Properties;
    impl Properties {}
    pub struct Declare<'a> {
        exchange: ::std::borrow::Cow<'a, str>,
        ty: ::std::borrow::Cow<'a, str>,
        passive: bool,
        durable: bool,
        auto_delete: bool,
        internal: bool,
        no_wait: bool,
        arguments: ::std::borrow::Cow<'a, ::field::Table<'a>>,
    }
    impl<'a> Declare<'a> {
        pub fn new<E, T, A>(exchange: E,
                            ty: T,
                            passive: bool,
                            durable: bool,
                            auto_delete: bool,
                            internal: bool,
                            no_wait: bool,
                            arguments: A)
                            -> Self
            where E: Into<::std::borrow::Cow<'a, str>>,
                  T: Into<::std::borrow::Cow<'a, str>>,
                  A: Into<::std::borrow::Cow<'a, ::field::Table<'a>>>
        {
            Declare {
                exchange: exchange.into(),
                ty: ty.into(),
                passive: passive,
                durable: durable,
                auto_delete: auto_delete,
                internal: internal,
                no_wait: no_wait,
                arguments: arguments.into(),
            }
        }
        pub fn exchange(&self) -> &str {
            &*self.exchange
        }
        pub fn ty(&self) -> &str {
            &*self.ty
        }
        pub fn passive(&self) -> bool {
            self.passive
        }
        pub fn durable(&self) -> bool {
            self.durable
        }
        pub fn auto_delete(&self) -> bool {
            self.auto_delete
        }
        pub fn internal(&self) -> bool {
            self.internal
        }
        pub fn no_wait(&self) -> bool {
            self.no_wait
        }
        pub fn arguments(&self) -> &::field::Table<'a> {
            &*self.arguments
        }
    }
    impl<'a> ::Payload for Declare<'a> {
        fn class_id(&self) -> u16 {
            40
        }
        fn method_id(&self) -> u16 {
            10
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [5, self.exchange.len(), self.ty.len(), self.arguments.amqp_size()]
                .iter()
                .sum()
        }
    }
    pub struct DeclareOk;
    impl DeclareOk {
        pub fn new() -> Self {
            DeclareOk
        }
    }
    impl ::Payload for DeclareOk {
        fn class_id(&self) -> u16 {
            40
        }
        fn method_id(&self) -> u16 {
            11
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            0
        }
    }
    pub struct Delete<'a> {
        exchange: ::std::borrow::Cow<'a, str>,
        if_unused: bool,
        no_wait: bool,
    }
    impl<'a> Delete<'a> {
        pub fn new<E>(exchange: E, if_unused: bool, no_wait: bool) -> Self
            where E: Into<::std::borrow::Cow<'a, str>>
        {
            Delete {
                exchange: exchange.into(),
                if_unused: if_unused,
                no_wait: no_wait,
            }
        }
        pub fn exchange(&self) -> &str {
            &*self.exchange
        }
        pub fn if_unused(&self) -> bool {
            self.if_unused
        }
        pub fn no_wait(&self) -> bool {
            self.no_wait
        }
    }
    impl<'a> ::Payload for Delete<'a> {
        fn class_id(&self) -> u16 {
            40
        }
        fn method_id(&self) -> u16 {
            20
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [4, self.exchange.len()]
                .iter()
                .sum()
        }
    }
    pub struct DeleteOk;
    impl DeleteOk {
        pub fn new() -> Self {
            DeleteOk
        }
    }
    impl ::Payload for DeleteOk {
        fn class_id(&self) -> u16 {
            40
        }
        fn method_id(&self) -> u16 {
            21
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            0
        }
    }
    pub struct Bind<'a> {
        destination: ::std::borrow::Cow<'a, str>,
        source: ::std::borrow::Cow<'a, str>,
        routing_key: ::std::borrow::Cow<'a, str>,
        no_wait: bool,
        arguments: ::std::borrow::Cow<'a, ::field::Table<'a>>,
    }
    impl<'a> Bind<'a> {
        pub fn new<D, S, R, A>(destination: D,
                               source: S,
                               routing_key: R,
                               no_wait: bool,
                               arguments: A)
                               -> Self
            where D: Into<::std::borrow::Cow<'a, str>>,
                  S: Into<::std::borrow::Cow<'a, str>>,
                  R: Into<::std::borrow::Cow<'a, str>>,
                  A: Into<::std::borrow::Cow<'a, ::field::Table<'a>>>
        {
            Bind {
                destination: destination.into(),
                source: source.into(),
                routing_key: routing_key.into(),
                no_wait: no_wait,
                arguments: arguments.into(),
            }
        }
        pub fn destination(&self) -> &str {
            &*self.destination
        }
        pub fn source(&self) -> &str {
            &*self.source
        }
        pub fn routing_key(&self) -> &str {
            &*self.routing_key
        }
        pub fn no_wait(&self) -> bool {
            self.no_wait
        }
        pub fn arguments(&self) -> &::field::Table<'a> {
            &*self.arguments
        }
    }
    impl<'a> ::Payload for Bind<'a> {
        fn class_id(&self) -> u16 {
            40
        }
        fn method_id(&self) -> u16 {
            30
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [6,
             self.destination.len(),
             self.source.len(),
             self.routing_key.len(),
             self.arguments.amqp_size()]
                .iter()
                .sum()
        }
    }
    pub struct BindOk;
    impl BindOk {
        pub fn new() -> Self {
            BindOk
        }
    }
    impl ::Payload for BindOk {
        fn class_id(&self) -> u16 {
            40
        }
        fn method_id(&self) -> u16 {
            31
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            0
        }
    }
    pub struct Unbind<'a> {
        destination: ::std::borrow::Cow<'a, str>,
        source: ::std::borrow::Cow<'a, str>,
        routing_key: ::std::borrow::Cow<'a, str>,
        no_wait: bool,
        arguments: ::std::borrow::Cow<'a, ::field::Table<'a>>,
    }
    impl<'a> Unbind<'a> {
        pub fn new<D, S, R, A>(destination: D,
                               source: S,
                               routing_key: R,
                               no_wait: bool,
                               arguments: A)
                               -> Self
            where D: Into<::std::borrow::Cow<'a, str>>,
                  S: Into<::std::borrow::Cow<'a, str>>,
                  R: Into<::std::borrow::Cow<'a, str>>,
                  A: Into<::std::borrow::Cow<'a, ::field::Table<'a>>>
        {
            Unbind {
                destination: destination.into(),
                source: source.into(),
                routing_key: routing_key.into(),
                no_wait: no_wait,
                arguments: arguments.into(),
            }
        }
        pub fn destination(&self) -> &str {
            &*self.destination
        }
        pub fn source(&self) -> &str {
            &*self.source
        }
        pub fn routing_key(&self) -> &str {
            &*self.routing_key
        }
        pub fn no_wait(&self) -> bool {
            self.no_wait
        }
        pub fn arguments(&self) -> &::field::Table<'a> {
            &*self.arguments
        }
    }
    impl<'a> ::Payload for Unbind<'a> {
        fn class_id(&self) -> u16 {
            40
        }
        fn method_id(&self) -> u16 {
            40
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [6,
             self.destination.len(),
             self.source.len(),
             self.routing_key.len(),
             self.arguments.amqp_size()]
                .iter()
                .sum()
        }
    }
    pub struct UnbindOk;
    impl UnbindOk {
        pub fn new() -> Self {
            UnbindOk
        }
    }
    impl ::Payload for UnbindOk {
        fn class_id(&self) -> u16 {
            40
        }
        fn method_id(&self) -> u16 {
            51
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            0
        }
    }
}
pub mod queue {
    pub struct Properties;
    impl Properties {}
    pub struct Declare<'a> {
        queue: ::std::borrow::Cow<'a, str>,
        passive: bool,
        durable: bool,
        exclusive: bool,
        auto_delete: bool,
        no_wait: bool,
        arguments: ::std::borrow::Cow<'a, ::field::Table<'a>>,
    }
    impl<'a> Declare<'a> {
        pub fn new<Q, A>(queue: Q,
                         passive: bool,
                         durable: bool,
                         exclusive: bool,
                         auto_delete: bool,
                         no_wait: bool,
                         arguments: A)
                         -> Self
            where Q: Into<::std::borrow::Cow<'a, str>>,
                  A: Into<::std::borrow::Cow<'a, ::field::Table<'a>>>
        {
            Declare {
                queue: queue.into(),
                passive: passive,
                durable: durable,
                exclusive: exclusive,
                auto_delete: auto_delete,
                no_wait: no_wait,
                arguments: arguments.into(),
            }
        }
        pub fn queue(&self) -> &str {
            &*self.queue
        }
        pub fn passive(&self) -> bool {
            self.passive
        }
        pub fn durable(&self) -> bool {
            self.durable
        }
        pub fn exclusive(&self) -> bool {
            self.exclusive
        }
        pub fn auto_delete(&self) -> bool {
            self.auto_delete
        }
        pub fn no_wait(&self) -> bool {
            self.no_wait
        }
        pub fn arguments(&self) -> &::field::Table<'a> {
            &*self.arguments
        }
    }
    impl<'a> ::Payload for Declare<'a> {
        fn class_id(&self) -> u16 {
            50
        }
        fn method_id(&self) -> u16 {
            10
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [4, self.queue.len(), self.arguments.amqp_size()]
                .iter()
                .sum()
        }
    }
    pub struct DeclareOk<'a> {
        queue: ::std::borrow::Cow<'a, str>,
        message_count: u32,
        consumer_count: u32,
    }
    impl<'a> DeclareOk<'a> {
        pub fn new<Q>(queue: Q, message_count: u32, consumer_count: u32) -> Self
            where Q: Into<::std::borrow::Cow<'a, str>>
        {
            DeclareOk {
                queue: queue.into(),
                message_count: message_count,
                consumer_count: consumer_count,
            }
        }
        pub fn queue(&self) -> &str {
            &*self.queue
        }
        pub fn message_count(&self) -> u32 {
            self.message_count
        }
        pub fn consumer_count(&self) -> u32 {
            self.consumer_count
        }
    }
    impl<'a> ::Payload for DeclareOk<'a> {
        fn class_id(&self) -> u16 {
            50
        }
        fn method_id(&self) -> u16 {
            11
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [9, self.queue.len()]
                .iter()
                .sum()
        }
    }
    pub struct Bind<'a> {
        queue: ::std::borrow::Cow<'a, str>,
        exchange: ::std::borrow::Cow<'a, str>,
        routing_key: ::std::borrow::Cow<'a, str>,
        no_wait: bool,
        arguments: ::std::borrow::Cow<'a, ::field::Table<'a>>,
    }
    impl<'a> Bind<'a> {
        pub fn new<Q, E, R, A>(queue: Q,
                               exchange: E,
                               routing_key: R,
                               no_wait: bool,
                               arguments: A)
                               -> Self
            where Q: Into<::std::borrow::Cow<'a, str>>,
                  E: Into<::std::borrow::Cow<'a, str>>,
                  R: Into<::std::borrow::Cow<'a, str>>,
                  A: Into<::std::borrow::Cow<'a, ::field::Table<'a>>>
        {
            Bind {
                queue: queue.into(),
                exchange: exchange.into(),
                routing_key: routing_key.into(),
                no_wait: no_wait,
                arguments: arguments.into(),
            }
        }
        pub fn queue(&self) -> &str {
            &*self.queue
        }
        pub fn exchange(&self) -> &str {
            &*self.exchange
        }
        pub fn routing_key(&self) -> &str {
            &*self.routing_key
        }
        pub fn no_wait(&self) -> bool {
            self.no_wait
        }
        pub fn arguments(&self) -> &::field::Table<'a> {
            &*self.arguments
        }
    }
    impl<'a> ::Payload for Bind<'a> {
        fn class_id(&self) -> u16 {
            50
        }
        fn method_id(&self) -> u16 {
            20
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [6,
             self.queue.len(),
             self.exchange.len(),
             self.routing_key.len(),
             self.arguments.amqp_size()]
                .iter()
                .sum()
        }
    }
    pub struct BindOk;
    impl BindOk {
        pub fn new() -> Self {
            BindOk
        }
    }
    impl ::Payload for BindOk {
        fn class_id(&self) -> u16 {
            50
        }
        fn method_id(&self) -> u16 {
            21
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            0
        }
    }
    pub struct Unbind<'a> {
        queue: ::std::borrow::Cow<'a, str>,
        exchange: ::std::borrow::Cow<'a, str>,
        routing_key: ::std::borrow::Cow<'a, str>,
        arguments: ::std::borrow::Cow<'a, ::field::Table<'a>>,
    }
    impl<'a> Unbind<'a> {
        pub fn new<Q, E, R, A>(queue: Q, exchange: E, routing_key: R, arguments: A) -> Self
            where Q: Into<::std::borrow::Cow<'a, str>>,
                  E: Into<::std::borrow::Cow<'a, str>>,
                  R: Into<::std::borrow::Cow<'a, str>>,
                  A: Into<::std::borrow::Cow<'a, ::field::Table<'a>>>
        {
            Unbind {
                queue: queue.into(),
                exchange: exchange.into(),
                routing_key: routing_key.into(),
                arguments: arguments.into(),
            }
        }
        pub fn queue(&self) -> &str {
            &*self.queue
        }
        pub fn exchange(&self) -> &str {
            &*self.exchange
        }
        pub fn routing_key(&self) -> &str {
            &*self.routing_key
        }
        pub fn arguments(&self) -> &::field::Table<'a> {
            &*self.arguments
        }
    }
    impl<'a> ::Payload for Unbind<'a> {
        fn class_id(&self) -> u16 {
            50
        }
        fn method_id(&self) -> u16 {
            50
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [5,
             self.queue.len(),
             self.exchange.len(),
             self.routing_key.len(),
             self.arguments.amqp_size()]
                .iter()
                .sum()
        }
    }
    pub struct UnbindOk;
    impl UnbindOk {
        pub fn new() -> Self {
            UnbindOk
        }
    }
    impl ::Payload for UnbindOk {
        fn class_id(&self) -> u16 {
            50
        }
        fn method_id(&self) -> u16 {
            51
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            0
        }
    }
    pub struct Purge<'a> {
        queue: ::std::borrow::Cow<'a, str>,
        no_wait: bool,
    }
    impl<'a> Purge<'a> {
        pub fn new<Q>(queue: Q, no_wait: bool) -> Self
            where Q: Into<::std::borrow::Cow<'a, str>>
        {
            Purge {
                queue: queue.into(),
                no_wait: no_wait,
            }
        }
        pub fn queue(&self) -> &str {
            &*self.queue
        }
        pub fn no_wait(&self) -> bool {
            self.no_wait
        }
    }
    impl<'a> ::Payload for Purge<'a> {
        fn class_id(&self) -> u16 {
            50
        }
        fn method_id(&self) -> u16 {
            30
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [4, self.queue.len()]
                .iter()
                .sum()
        }
    }
    pub struct PurgeOk {
        message_count: u32,
    }
    impl PurgeOk {
        pub fn new(message_count: u32) -> Self {
            PurgeOk { message_count: message_count }
        }
        pub fn message_count(&self) -> u32 {
            self.message_count
        }
    }
    impl ::Payload for PurgeOk {
        fn class_id(&self) -> u16 {
            50
        }
        fn method_id(&self) -> u16 {
            31
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            4
        }
    }
    pub struct Delete<'a> {
        queue: ::std::borrow::Cow<'a, str>,
        if_unused: bool,
        if_empty: bool,
        no_wait: bool,
    }
    impl<'a> Delete<'a> {
        pub fn new<Q>(queue: Q, if_unused: bool, if_empty: bool, no_wait: bool) -> Self
            where Q: Into<::std::borrow::Cow<'a, str>>
        {
            Delete {
                queue: queue.into(),
                if_unused: if_unused,
                if_empty: if_empty,
                no_wait: no_wait,
            }
        }
        pub fn queue(&self) -> &str {
            &*self.queue
        }
        pub fn if_unused(&self) -> bool {
            self.if_unused
        }
        pub fn if_empty(&self) -> bool {
            self.if_empty
        }
        pub fn no_wait(&self) -> bool {
            self.no_wait
        }
    }
    impl<'a> ::Payload for Delete<'a> {
        fn class_id(&self) -> u16 {
            50
        }
        fn method_id(&self) -> u16 {
            40
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [4, self.queue.len()]
                .iter()
                .sum()
        }
    }
    pub struct DeleteOk {
        message_count: u32,
    }
    impl DeleteOk {
        pub fn new(message_count: u32) -> Self {
            DeleteOk { message_count: message_count }
        }
        pub fn message_count(&self) -> u32 {
            self.message_count
        }
    }
    impl ::Payload for DeleteOk {
        fn class_id(&self) -> u16 {
            50
        }
        fn method_id(&self) -> u16 {
            41
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            4
        }
    }
}
pub mod tx {
    pub struct Properties;
    impl Properties {}
    pub struct Select;
    impl Select {
        pub fn new() -> Self {
            Select
        }
    }
    impl ::Payload for Select {
        fn class_id(&self) -> u16 {
            90
        }
        fn method_id(&self) -> u16 {
            10
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            0
        }
    }
    pub struct SelectOk;
    impl SelectOk {
        pub fn new() -> Self {
            SelectOk
        }
    }
    impl ::Payload for SelectOk {
        fn class_id(&self) -> u16 {
            90
        }
        fn method_id(&self) -> u16 {
            11
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            0
        }
    }
    pub struct Commit;
    impl Commit {
        pub fn new() -> Self {
            Commit
        }
    }
    impl ::Payload for Commit {
        fn class_id(&self) -> u16 {
            90
        }
        fn method_id(&self) -> u16 {
            20
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            0
        }
    }
    pub struct CommitOk;
    impl CommitOk {
        pub fn new() -> Self {
            CommitOk
        }
    }
    impl ::Payload for CommitOk {
        fn class_id(&self) -> u16 {
            90
        }
        fn method_id(&self) -> u16 {
            21
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            0
        }
    }
    pub struct Rollback;
    impl Rollback {
        pub fn new() -> Self {
            Rollback
        }
    }
    impl ::Payload for Rollback {
        fn class_id(&self) -> u16 {
            90
        }
        fn method_id(&self) -> u16 {
            30
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            0
        }
    }
    pub struct RollbackOk;
    impl RollbackOk {
        pub fn new() -> Self {
            RollbackOk
        }
    }
    impl ::Payload for RollbackOk {
        fn class_id(&self) -> u16 {
            90
        }
        fn method_id(&self) -> u16 {
            31
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            0
        }
    }
}

#[allow(non_camel_case_types)]
pub struct Rabbitmq9_1;
impl ::Spec for Rabbitmq9_1 {}
