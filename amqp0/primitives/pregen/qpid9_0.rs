// Generated by build.rs script in amqp0-primitives
// Pre-generated files are used by default. Generation is done with the amqp0-codegen crate
//
// To regenerate, and not use pre-generated files, use: cargo --features="amqp0-build-primitives"
// To format and replace the pre-generated files, use: cargo --features="amqp0-build-primitives"
//
// EDITORS BEWARE: Your modifications may be overridden
#![allow(too_many_arguments)]

// Class Constants
pub const CLASS_ACCESS: u16 = 30;
pub const CLASS_BASIC: u16 = 60;
pub const CLASS_CHANNEL: u16 = 20;
pub const CLASS_CONNECTION: u16 = 10;
pub const CLASS_DTX: u16 = 100;
pub const CLASS_EXCHANGE: u16 = 40;
pub const CLASS_FILE: u16 = 70;
pub const CLASS_MESSAGE: u16 = 120;
pub const CLASS_QUEUE: u16 = 50;
pub const CLASS_STREAM: u16 = 80;
pub const CLASS_TUNNEL: u16 = 110;
pub const CLASS_TX: u16 = 90;

// Class Methods
pub const METHOD_ACCESS_REQUEST: u16 = 10;
pub const METHOD_ACCESS_REQUEST_OK: u16 = 11;

pub const METHOD_BASIC_QOS: u16 = 10;
pub const METHOD_BASIC_QOS_OK: u16 = 11;
pub const METHOD_BASIC_CONSUME: u16 = 20;
pub const METHOD_BASIC_CONSUME_OK: u16 = 21;
pub const METHOD_BASIC_CANCEL: u16 = 30;
pub const METHOD_BASIC_CANCEL_OK: u16 = 31;
pub const METHOD_BASIC_PUBLISH: u16 = 40;
pub const METHOD_BASIC_RETURN: u16 = 50;
pub const METHOD_BASIC_DELIVER: u16 = 60;
pub const METHOD_BASIC_GET: u16 = 70;
pub const METHOD_BASIC_GET_OK: u16 = 71;
pub const METHOD_BASIC_GET_EMPTY: u16 = 72;
pub const METHOD_BASIC_ACK: u16 = 80;
pub const METHOD_BASIC_REJECT: u16 = 90;
pub const METHOD_BASIC_RECOVER: u16 = 100;
pub const METHOD_BASIC_RECOVER_SYNC: u16 = 102;
pub const METHOD_BASIC_RECOVER_SYNC_OK: u16 = 101;

pub const METHOD_CHANNEL_OPEN: u16 = 10;
pub const METHOD_CHANNEL_OPEN_OK: u16 = 11;
pub const METHOD_CHANNEL_FLOW: u16 = 20;
pub const METHOD_CHANNEL_FLOW_OK: u16 = 21;
pub const METHOD_CHANNEL_CLOSE: u16 = 40;
pub const METHOD_CHANNEL_CLOSE_OK: u16 = 41;
pub const METHOD_CHANNEL_RESUME: u16 = 50;
pub const METHOD_CHANNEL_PING: u16 = 60;
pub const METHOD_CHANNEL_PONG: u16 = 70;
pub const METHOD_CHANNEL_OK: u16 = 80;

pub const METHOD_CONNECTION_START: u16 = 10;
pub const METHOD_CONNECTION_START_OK: u16 = 11;
pub const METHOD_CONNECTION_SECURE: u16 = 20;
pub const METHOD_CONNECTION_SECURE_OK: u16 = 21;
pub const METHOD_CONNECTION_TUNE: u16 = 30;
pub const METHOD_CONNECTION_TUNE_OK: u16 = 31;
pub const METHOD_CONNECTION_OPEN: u16 = 40;
pub const METHOD_CONNECTION_OPEN_OK: u16 = 41;
pub const METHOD_CONNECTION_REDIRECT: u16 = 42;
pub const METHOD_CONNECTION_CLOSE: u16 = 50;
pub const METHOD_CONNECTION_CLOSE_OK: u16 = 51;

pub const METHOD_DTX_SELECT: u16 = 10;
pub const METHOD_DTX_SELECT_OK: u16 = 11;
pub const METHOD_DTX_START: u16 = 20;
pub const METHOD_DTX_START_OK: u16 = 21;

pub const METHOD_EXCHANGE_DECLARE: u16 = 10;
pub const METHOD_EXCHANGE_DECLARE_OK: u16 = 11;
pub const METHOD_EXCHANGE_DELETE: u16 = 20;
pub const METHOD_EXCHANGE_DELETE_OK: u16 = 21;
pub const METHOD_EXCHANGE_BOUND: u16 = 22;
pub const METHOD_EXCHANGE_BOUND_OK: u16 = 23;

pub const METHOD_FILE_QOS: u16 = 10;
pub const METHOD_FILE_QOS_OK: u16 = 11;
pub const METHOD_FILE_CONSUME: u16 = 20;
pub const METHOD_FILE_CONSUME_OK: u16 = 21;
pub const METHOD_FILE_CANCEL: u16 = 30;
pub const METHOD_FILE_CANCEL_OK: u16 = 31;
pub const METHOD_FILE_OPEN: u16 = 40;
pub const METHOD_FILE_OPEN_OK: u16 = 41;
pub const METHOD_FILE_STAGE: u16 = 50;
pub const METHOD_FILE_PUBLISH: u16 = 60;
pub const METHOD_FILE_RETURN: u16 = 70;
pub const METHOD_FILE_DELIVER: u16 = 80;
pub const METHOD_FILE_ACK: u16 = 90;
pub const METHOD_FILE_REJECT: u16 = 100;

pub const METHOD_MESSAGE_TRANSFER: u16 = 10;
pub const METHOD_MESSAGE_CONSUME: u16 = 20;
pub const METHOD_MESSAGE_CANCEL: u16 = 30;
pub const METHOD_MESSAGE_GET: u16 = 40;
pub const METHOD_MESSAGE_RECOVER: u16 = 50;
pub const METHOD_MESSAGE_OPEN: u16 = 60;
pub const METHOD_MESSAGE_CLOSE: u16 = 70;
pub const METHOD_MESSAGE_APPEND: u16 = 80;
pub const METHOD_MESSAGE_CHECKPOINT: u16 = 90;
pub const METHOD_MESSAGE_RESUME: u16 = 100;
pub const METHOD_MESSAGE_QOS: u16 = 110;
pub const METHOD_MESSAGE_OK: u16 = 500;
pub const METHOD_MESSAGE_EMPTY: u16 = 510;
pub const METHOD_MESSAGE_REJECT: u16 = 520;
pub const METHOD_MESSAGE_OFFSET: u16 = 530;

pub const METHOD_QUEUE_DECLARE: u16 = 10;
pub const METHOD_QUEUE_DECLARE_OK: u16 = 11;
pub const METHOD_QUEUE_BIND: u16 = 20;
pub const METHOD_QUEUE_BIND_OK: u16 = 21;
pub const METHOD_QUEUE_UNBIND: u16 = 50;
pub const METHOD_QUEUE_UNBIND_OK: u16 = 51;
pub const METHOD_QUEUE_PURGE: u16 = 30;
pub const METHOD_QUEUE_PURGE_OK: u16 = 31;
pub const METHOD_QUEUE_DELETE: u16 = 40;
pub const METHOD_QUEUE_DELETE_OK: u16 = 41;

pub const METHOD_STREAM_QOS: u16 = 10;
pub const METHOD_STREAM_QOS_OK: u16 = 11;
pub const METHOD_STREAM_CONSUME: u16 = 20;
pub const METHOD_STREAM_CONSUME_OK: u16 = 21;
pub const METHOD_STREAM_CANCEL: u16 = 30;
pub const METHOD_STREAM_CANCEL_OK: u16 = 31;
pub const METHOD_STREAM_PUBLISH: u16 = 40;
pub const METHOD_STREAM_RETURN: u16 = 50;
pub const METHOD_STREAM_DELIVER: u16 = 60;

pub const METHOD_TUNNEL_REQUEST: u16 = 10;

pub const METHOD_TX_SELECT: u16 = 10;
pub const METHOD_TX_SELECT_OK: u16 = 11;
pub const METHOD_TX_COMMIT: u16 = 20;
pub const METHOD_TX_COMMIT_OK: u16 = 21;
pub const METHOD_TX_ROLLBACK: u16 = 30;
pub const METHOD_TX_ROLLBACK_OK: u16 = 31;

pub enum Header<'a> {
    Access,
    Basic(basic::Headers<'a>),
    Channel,
    Connection,
    Dtx,
    Exchange,
    File(file::Headers<'a>),
    Message,
    Queue,
    Stream(stream::Headers<'a>),
    Tunnel(tunnel::Headers<'a>),
    Tx,
} // enum Header

pub enum Frame<'a> {
    Body(&'a [u8]),
    Header(Header<'a>),
    Heartbeat,
    Method(Method<'a>),
    OobBody(&'a [u8]),
    OobHeader(Header<'a>),
    OobMethod(Method<'a>),
    Trace,
} // enum Frame

// Class Modules
pub mod access {
    pub struct Headers;
    pub struct Request<'a> {
        realm: ::std::borrow::Cow<'a, str>,
        exclusive: bool,
        passive: bool,
        active: bool,
        write: bool,
        read: bool,
    }
    impl<'a> Request<'a> {
        pub fn new<R>(realm: R,
                      exclusive: bool,
                      passive: bool,
                      active: bool,
                      write: bool,
                      read: bool)
                      -> Self
            where R: Into<::std::borrow::Cow<'a, str>>
        {
            Request {
                realm: realm.into(),
                exclusive: exclusive,
                passive: passive,
                active: active,
                write: write,
                read: read,
            }
        }
        impl_properties! {
(realm, realm_mut, set_realm) -> Cow<str>,
(exclusive, set_exclusive) -> bool,
(passive, set_passive) -> bool,
(active, set_active) -> bool,
(write, set_write) -> bool,
(read, set_read) -> bool,
} // impl_properties
    }
    impl<'a> ::Payload for Request<'a> {
        fn class_id(&self) -> u16 {
            30
        }
        fn method_id(&self) -> u16 {
            10
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [2, self.realm.len()]
                .iter()
                .sum()
        }
    }
    pub struct RequestOk {
        ticket: u16,
    }
    impl RequestOk {
        pub fn new(ticket: u16) -> Self {
            RequestOk { ticket: ticket }
        }
        impl_properties! {
(ticket, set_ticket) -> u16,
} // impl_properties
    }
    impl ::Payload for RequestOk {
        fn class_id(&self) -> u16 {
            30
        }
        fn method_id(&self) -> u16 {
            11
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            2
        }
    }
    pub enum Method<'a> {
        Request(Request<'a>),
        RequestOk(RequestOk),
    } // enum Method

} // mod access

pub mod basic {
    pub struct Headers<'a> {
        content_type: Option<::std::borrow::Cow<'a, str>>,
        content_encoding: Option<::std::borrow::Cow<'a, str>>,
        headers: Option<::field::Table<'a>>,
        delivery_mode: Option<u8>,
        priority: Option<u8>,
        correlation_id: Option<::std::borrow::Cow<'a, str>>,
        reply_to: Option<::std::borrow::Cow<'a, str>>,
        expiration: Option<::std::borrow::Cow<'a, str>>,
        message_id: Option<::std::borrow::Cow<'a, str>>,
        timestamp: Option<u64>,
        ty: Option<::std::borrow::Cow<'a, str>>,
        user_id: Option<::std::borrow::Cow<'a, str>>,
        app_id: Option<::std::borrow::Cow<'a, str>>,
        cluster_id: Option<::std::borrow::Cow<'a, str>>,
    }

    impl<'a> Headers<'a> {
        impl_properties! {
(content_type, content_type_mut, set_content_type, take_content_type) -> Option< Cow<str> >,
(content_encoding, content_encoding_mut, set_content_encoding, take_content_encoding) -> Option< Cow<str> >,
(headers, headers_mut, set_headers, take_headers) -> Option<&::field::Table<'a>>,
(delivery_mode, delivery_mode_mut, set_delivery_mode, take_delivery_mode) -> Option<u8>,
(priority, priority_mut, set_priority, take_priority) -> Option<u8>,
(correlation_id, correlation_id_mut, set_correlation_id, take_correlation_id) -> Option< Cow<str> >,
(reply_to, reply_to_mut, set_reply_to, take_reply_to) -> Option< Cow<str> >,
(expiration, expiration_mut, set_expiration, take_expiration) -> Option< Cow<str> >,
(message_id, message_id_mut, set_message_id, take_message_id) -> Option< Cow<str> >,
(timestamp, timestamp_mut, set_timestamp, take_timestamp) -> Option<u64>,
(ty, ty_mut, set_ty, take_ty) -> Option< Cow<str> >,
(user_id, user_id_mut, set_user_id, take_user_id) -> Option< Cow<str> >,
(app_id, app_id_mut, set_app_id, take_app_id) -> Option< Cow<str> >,
(cluster_id, cluster_id_mut, set_cluster_id, take_cluster_id) -> Option< Cow<str> >,
} // impl_properties
    }
    pub struct Qos {
        prefetch_size: u32,
        prefetch_count: u16,
        global: bool,
    }
    impl Qos {
        pub fn new(prefetch_size: u32, prefetch_count: u16, global: bool) -> Self {
            Qos {
                prefetch_size: prefetch_size,
                prefetch_count: prefetch_count,
                global: global,
            }
        }
        impl_properties! {
(prefetch_size, set_prefetch_size) -> u32,
(prefetch_count, set_prefetch_count) -> u16,
(global, set_global) -> bool,
} // impl_properties
    }
    impl ::Payload for Qos {
        fn class_id(&self) -> u16 {
            60
        }
        fn method_id(&self) -> u16 {
            10
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            7
        }
    }
    pub struct QosOk;
    impl QosOk {
        pub fn new() -> Self {
            QosOk
        }
    }
    impl ::Payload for QosOk {
        fn class_id(&self) -> u16 {
            60
        }
        fn method_id(&self) -> u16 {
            11
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            0
        }
    }
    pub struct Consume<'a> {
        ticket: u16,
        queue: ::std::borrow::Cow<'a, str>,
        consumer_tag: ::std::borrow::Cow<'a, str>,
        no_local: bool,
        no_ack: bool,
        exclusive: bool,
        nowait: bool,
        arguments: ::field::Table<'a>,
    }
    impl<'a> Consume<'a> {
        pub fn new<Q, C, A>(ticket: u16,
                            queue: Q,
                            consumer_tag: C,
                            no_local: bool,
                            no_ack: bool,
                            exclusive: bool,
                            nowait: bool,
                            arguments: A)
                            -> Self
            where Q: Into<::std::borrow::Cow<'a, str>>,
                  C: Into<::std::borrow::Cow<'a, str>>,
                  A: Into<::field::Table<'a>>
        {
            Consume {
                ticket: ticket,
                queue: queue.into(),
                consumer_tag: consumer_tag.into(),
                no_local: no_local,
                no_ack: no_ack,
                exclusive: exclusive,
                nowait: nowait,
                arguments: arguments.into(),
            }
        }
        impl_properties! {
(ticket, set_ticket) -> u16,
(queue, queue_mut, set_queue) -> Cow<str>,
(consumer_tag, consumer_tag_mut, set_consumer_tag) -> Cow<str>,
(no_local, set_no_local) -> bool,
(no_ack, set_no_ack) -> bool,
(exclusive, set_exclusive) -> bool,
(nowait, set_nowait) -> bool,
(arguments, arguments_mut, set_arguments) -> &::field::Table<'a>,
} // impl_properties
    }
    impl<'a> ::Payload for Consume<'a> {
        fn class_id(&self) -> u16 {
            60
        }
        fn method_id(&self) -> u16 {
            20
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [5, self.queue.len(), self.consumer_tag.len(), self.arguments.amqp_size()]
                .iter()
                .sum()
        }
    }
    pub struct ConsumeOk<'a> {
        consumer_tag: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ConsumeOk<'a> {
        pub fn new<C>(consumer_tag: C) -> Self
            where C: Into<::std::borrow::Cow<'a, str>>
        {
            ConsumeOk { consumer_tag: consumer_tag.into() }
        }
        impl_properties! {
(consumer_tag, consumer_tag_mut, set_consumer_tag) -> Cow<str>,
} // impl_properties
    }
    impl<'a> ::Payload for ConsumeOk<'a> {
        fn class_id(&self) -> u16 {
            60
        }
        fn method_id(&self) -> u16 {
            21
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [1, self.consumer_tag.len()]
                .iter()
                .sum()
        }
    }
    pub struct Cancel<'a> {
        consumer_tag: ::std::borrow::Cow<'a, str>,
        nowait: bool,
    }
    impl<'a> Cancel<'a> {
        pub fn new<C>(consumer_tag: C, nowait: bool) -> Self
            where C: Into<::std::borrow::Cow<'a, str>>
        {
            Cancel {
                consumer_tag: consumer_tag.into(),
                nowait: nowait,
            }
        }
        impl_properties! {
(consumer_tag, consumer_tag_mut, set_consumer_tag) -> Cow<str>,
(nowait, set_nowait) -> bool,
} // impl_properties
    }
    impl<'a> ::Payload for Cancel<'a> {
        fn class_id(&self) -> u16 {
            60
        }
        fn method_id(&self) -> u16 {
            30
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [2, self.consumer_tag.len()]
                .iter()
                .sum()
        }
    }
    pub struct CancelOk<'a> {
        consumer_tag: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> CancelOk<'a> {
        pub fn new<C>(consumer_tag: C) -> Self
            where C: Into<::std::borrow::Cow<'a, str>>
        {
            CancelOk { consumer_tag: consumer_tag.into() }
        }
        impl_properties! {
(consumer_tag, consumer_tag_mut, set_consumer_tag) -> Cow<str>,
} // impl_properties
    }
    impl<'a> ::Payload for CancelOk<'a> {
        fn class_id(&self) -> u16 {
            60
        }
        fn method_id(&self) -> u16 {
            31
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [1, self.consumer_tag.len()]
                .iter()
                .sum()
        }
    }
    pub struct Publish<'a> {
        ticket: u16,
        exchange: ::std::borrow::Cow<'a, str>,
        routing_key: ::std::borrow::Cow<'a, str>,
        mandatory: bool,
        immediate: bool,
    }
    impl<'a> Publish<'a> {
        pub fn new<E, R>(ticket: u16,
                         exchange: E,
                         routing_key: R,
                         mandatory: bool,
                         immediate: bool)
                         -> Self
            where E: Into<::std::borrow::Cow<'a, str>>,
                  R: Into<::std::borrow::Cow<'a, str>>
        {
            Publish {
                ticket: ticket,
                exchange: exchange.into(),
                routing_key: routing_key.into(),
                mandatory: mandatory,
                immediate: immediate,
            }
        }
        impl_properties! {
(ticket, set_ticket) -> u16,
(exchange, exchange_mut, set_exchange) -> Cow<str>,
(routing_key, routing_key_mut, set_routing_key) -> Cow<str>,
(mandatory, set_mandatory) -> bool,
(immediate, set_immediate) -> bool,
} // impl_properties
    }
    impl<'a> ::Payload for Publish<'a> {
        fn class_id(&self) -> u16 {
            60
        }
        fn method_id(&self) -> u16 {
            40
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [5, self.exchange.len(), self.routing_key.len()]
                .iter()
                .sum()
        }
    }
    pub struct Return<'a> {
        reply_code: u16,
        reply_text: ::std::borrow::Cow<'a, str>,
        exchange: ::std::borrow::Cow<'a, str>,
        routing_key: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> Return<'a> {
        pub fn new<R, E, R0>(reply_code: u16, reply_text: R, exchange: E, routing_key: R0) -> Self
            where R: Into<::std::borrow::Cow<'a, str>>,
                  E: Into<::std::borrow::Cow<'a, str>>,
                  R0: Into<::std::borrow::Cow<'a, str>>
        {
            Return {
                reply_code: reply_code,
                reply_text: reply_text.into(),
                exchange: exchange.into(),
                routing_key: routing_key.into(),
            }
        }
        impl_properties! {
(reply_code, set_reply_code) -> u16,
(reply_text, reply_text_mut, set_reply_text) -> Cow<str>,
(exchange, exchange_mut, set_exchange) -> Cow<str>,
(routing_key, routing_key_mut, set_routing_key) -> Cow<str>,
} // impl_properties
    }
    impl<'a> ::Payload for Return<'a> {
        fn class_id(&self) -> u16 {
            60
        }
        fn method_id(&self) -> u16 {
            50
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [5, self.reply_text.len(), self.exchange.len(), self.routing_key.len()]
                .iter()
                .sum()
        }
    }
    pub struct Deliver<'a> {
        consumer_tag: ::std::borrow::Cow<'a, str>,
        delivery_tag: u64,
        redelivered: bool,
        exchange: ::std::borrow::Cow<'a, str>,
        routing_key: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> Deliver<'a> {
        pub fn new<C, E, R>(consumer_tag: C,
                            delivery_tag: u64,
                            redelivered: bool,
                            exchange: E,
                            routing_key: R)
                            -> Self
            where C: Into<::std::borrow::Cow<'a, str>>,
                  E: Into<::std::borrow::Cow<'a, str>>,
                  R: Into<::std::borrow::Cow<'a, str>>
        {
            Deliver {
                consumer_tag: consumer_tag.into(),
                delivery_tag: delivery_tag,
                redelivered: redelivered,
                exchange: exchange.into(),
                routing_key: routing_key.into(),
            }
        }
        impl_properties! {
(consumer_tag, consumer_tag_mut, set_consumer_tag) -> Cow<str>,
(delivery_tag, set_delivery_tag) -> u64,
(redelivered, set_redelivered) -> bool,
(exchange, exchange_mut, set_exchange) -> Cow<str>,
(routing_key, routing_key_mut, set_routing_key) -> Cow<str>,
} // impl_properties
    }
    impl<'a> ::Payload for Deliver<'a> {
        fn class_id(&self) -> u16 {
            60
        }
        fn method_id(&self) -> u16 {
            60
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [12, self.consumer_tag.len(), self.exchange.len(), self.routing_key.len()]
                .iter()
                .sum()
        }
    }
    pub struct Get<'a> {
        ticket: u16,
        queue: ::std::borrow::Cow<'a, str>,
        no_ack: bool,
    }
    impl<'a> Get<'a> {
        pub fn new<Q>(ticket: u16, queue: Q, no_ack: bool) -> Self
            where Q: Into<::std::borrow::Cow<'a, str>>
        {
            Get {
                ticket: ticket,
                queue: queue.into(),
                no_ack: no_ack,
            }
        }
        impl_properties! {
(ticket, set_ticket) -> u16,
(queue, queue_mut, set_queue) -> Cow<str>,
(no_ack, set_no_ack) -> bool,
} // impl_properties
    }
    impl<'a> ::Payload for Get<'a> {
        fn class_id(&self) -> u16 {
            60
        }
        fn method_id(&self) -> u16 {
            70
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [4, self.queue.len()]
                .iter()
                .sum()
        }
    }
    pub struct GetOk<'a> {
        delivery_tag: u64,
        redelivered: bool,
        exchange: ::std::borrow::Cow<'a, str>,
        routing_key: ::std::borrow::Cow<'a, str>,
        message_count: u32,
    }
    impl<'a> GetOk<'a> {
        pub fn new<E, R>(delivery_tag: u64,
                         redelivered: bool,
                         exchange: E,
                         routing_key: R,
                         message_count: u32)
                         -> Self
            where E: Into<::std::borrow::Cow<'a, str>>,
                  R: Into<::std::borrow::Cow<'a, str>>
        {
            GetOk {
                delivery_tag: delivery_tag,
                redelivered: redelivered,
                exchange: exchange.into(),
                routing_key: routing_key.into(),
                message_count: message_count,
            }
        }
        impl_properties! {
(delivery_tag, set_delivery_tag) -> u64,
(redelivered, set_redelivered) -> bool,
(exchange, exchange_mut, set_exchange) -> Cow<str>,
(routing_key, routing_key_mut, set_routing_key) -> Cow<str>,
(message_count, set_message_count) -> u32,
} // impl_properties
    }
    impl<'a> ::Payload for GetOk<'a> {
        fn class_id(&self) -> u16 {
            60
        }
        fn method_id(&self) -> u16 {
            71
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [15, self.exchange.len(), self.routing_key.len()]
                .iter()
                .sum()
        }
    }
    pub struct GetEmpty<'a> {
        cluster_id: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> GetEmpty<'a> {
        pub fn new<C>(cluster_id: C) -> Self
            where C: Into<::std::borrow::Cow<'a, str>>
        {
            GetEmpty { cluster_id: cluster_id.into() }
        }
        impl_properties! {
(cluster_id, cluster_id_mut, set_cluster_id) -> Cow<str>,
} // impl_properties
    }
    impl<'a> ::Payload for GetEmpty<'a> {
        fn class_id(&self) -> u16 {
            60
        }
        fn method_id(&self) -> u16 {
            72
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [1, self.cluster_id.len()]
                .iter()
                .sum()
        }
    }
    pub struct Ack {
        delivery_tag: u64,
        multiple: bool,
    }
    impl Ack {
        pub fn new(delivery_tag: u64, multiple: bool) -> Self {
            Ack {
                delivery_tag: delivery_tag,
                multiple: multiple,
            }
        }
        impl_properties! {
(delivery_tag, set_delivery_tag) -> u64,
(multiple, set_multiple) -> bool,
} // impl_properties
    }
    impl ::Payload for Ack {
        fn class_id(&self) -> u16 {
            60
        }
        fn method_id(&self) -> u16 {
            80
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            9
        }
    }
    pub struct Reject {
        delivery_tag: u64,
        requeue: bool,
    }
    impl Reject {
        pub fn new(delivery_tag: u64, requeue: bool) -> Self {
            Reject {
                delivery_tag: delivery_tag,
                requeue: requeue,
            }
        }
        impl_properties! {
(delivery_tag, set_delivery_tag) -> u64,
(requeue, set_requeue) -> bool,
} // impl_properties
    }
    impl ::Payload for Reject {
        fn class_id(&self) -> u16 {
            60
        }
        fn method_id(&self) -> u16 {
            90
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            9
        }
    }
    pub struct Recover {
        requeue: bool,
    }
    impl Recover {
        pub fn new(requeue: bool) -> Self {
            Recover { requeue: requeue }
        }
        impl_properties! {
(requeue, set_requeue) -> bool,
} // impl_properties
    }
    impl ::Payload for Recover {
        fn class_id(&self) -> u16 {
            60
        }
        fn method_id(&self) -> u16 {
            100
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            1
        }
    }
    pub struct RecoverSync {
        requeue: bool,
    }
    impl RecoverSync {
        pub fn new(requeue: bool) -> Self {
            RecoverSync { requeue: requeue }
        }
        impl_properties! {
(requeue, set_requeue) -> bool,
} // impl_properties
    }
    impl ::Payload for RecoverSync {
        fn class_id(&self) -> u16 {
            60
        }
        fn method_id(&self) -> u16 {
            102
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            1
        }
    }
    pub struct RecoverSyncOk;
    impl RecoverSyncOk {
        pub fn new() -> Self {
            RecoverSyncOk
        }
    }
    impl ::Payload for RecoverSyncOk {
        fn class_id(&self) -> u16 {
            60
        }
        fn method_id(&self) -> u16 {
            101
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            0
        }
    }
    pub enum Method<'a> {
        Qos(Qos),
        QosOk(QosOk),
        Consume(Consume<'a>),
        ConsumeOk(ConsumeOk<'a>),
        Cancel(Cancel<'a>),
        CancelOk(CancelOk<'a>),
        Publish(Publish<'a>),
        Return(Return<'a>),
        Deliver(Deliver<'a>),
        Get(Get<'a>),
        GetOk(GetOk<'a>),
        GetEmpty(GetEmpty<'a>),
        Ack(Ack),
        Reject(Reject),
        Recover(Recover),
        RecoverSync(RecoverSync),
        RecoverSyncOk(RecoverSyncOk),
    } // enum Method

} // mod basic

pub mod channel {
    pub struct Headers;
    pub struct Open<'a> {
        out_of_band: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> Open<'a> {
        pub fn new<O>(out_of_band: O) -> Self
            where O: Into<::std::borrow::Cow<'a, str>>
        {
            Open { out_of_band: out_of_band.into() }
        }
        impl_properties! {
(out_of_band, out_of_band_mut, set_out_of_band) -> Cow<str>,
} // impl_properties
    }
    impl<'a> ::Payload for Open<'a> {
        fn class_id(&self) -> u16 {
            20
        }
        fn method_id(&self) -> u16 {
            10
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [1, self.out_of_band.len()]
                .iter()
                .sum()
        }
    }
    pub struct OpenOk<'a> {
        channel_id: ::std::borrow::Cow<'a, [u8]>,
    }
    impl<'a> OpenOk<'a> {
        pub fn new<C>(channel_id: C) -> Self
            where C: Into<::std::borrow::Cow<'a, [u8]>>
        {
            OpenOk { channel_id: channel_id.into() }
        }
        impl_properties! {
(channel_id, channel_id_mut, set_channel_id) -> Cow<[u8]>,
} // impl_properties
    }
    impl<'a> ::Payload for OpenOk<'a> {
        fn class_id(&self) -> u16 {
            20
        }
        fn method_id(&self) -> u16 {
            11
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [2, self.channel_id.len()]
                .iter()
                .sum()
        }
    }
    pub struct Flow {
        active: bool,
    }
    impl Flow {
        pub fn new(active: bool) -> Self {
            Flow { active: active }
        }
        impl_properties! {
(active, set_active) -> bool,
} // impl_properties
    }
    impl ::Payload for Flow {
        fn class_id(&self) -> u16 {
            20
        }
        fn method_id(&self) -> u16 {
            20
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            1
        }
    }
    pub struct FlowOk {
        active: bool,
    }
    impl FlowOk {
        pub fn new(active: bool) -> Self {
            FlowOk { active: active }
        }
        impl_properties! {
(active, set_active) -> bool,
} // impl_properties
    }
    impl ::Payload for FlowOk {
        fn class_id(&self) -> u16 {
            20
        }
        fn method_id(&self) -> u16 {
            21
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            1
        }
    }
    pub struct Close<'a> {
        reply_code: u16,
        reply_text: ::std::borrow::Cow<'a, str>,
        class_id: u16,
        method_id: u16,
    }
    impl<'a> Close<'a> {
        pub fn new<R>(reply_code: u16, reply_text: R, class_id: u16, method_id: u16) -> Self
            where R: Into<::std::borrow::Cow<'a, str>>
        {
            Close {
                reply_code: reply_code,
                reply_text: reply_text.into(),
                class_id: class_id,
                method_id: method_id,
            }
        }
        impl_properties! {
(reply_code, set_reply_code) -> u16,
(reply_text, reply_text_mut, set_reply_text) -> Cow<str>,
(class_id, set_class_id) -> u16,
(method_id, set_method_id) -> u16,
} // impl_properties
    }
    impl<'a> ::Payload for Close<'a> {
        fn class_id(&self) -> u16 {
            20
        }
        fn method_id(&self) -> u16 {
            40
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [7, self.reply_text.len()]
                .iter()
                .sum()
        }
    }
    pub struct CloseOk;
    impl CloseOk {
        pub fn new() -> Self {
            CloseOk
        }
    }
    impl ::Payload for CloseOk {
        fn class_id(&self) -> u16 {
            20
        }
        fn method_id(&self) -> u16 {
            41
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            0
        }
    }
    pub struct Resume<'a> {
        channel_id: ::std::borrow::Cow<'a, [u8]>,
    }
    impl<'a> Resume<'a> {
        pub fn new<C>(channel_id: C) -> Self
            where C: Into<::std::borrow::Cow<'a, [u8]>>
        {
            Resume { channel_id: channel_id.into() }
        }
        impl_properties! {
(channel_id, channel_id_mut, set_channel_id) -> Cow<[u8]>,
} // impl_properties
    }
    impl<'a> ::Payload for Resume<'a> {
        fn class_id(&self) -> u16 {
            20
        }
        fn method_id(&self) -> u16 {
            50
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [2, self.channel_id.len()]
                .iter()
                .sum()
        }
    }
    pub struct Ping;
    impl Ping {
        pub fn new() -> Self {
            Ping
        }
    }
    impl ::Payload for Ping {
        fn class_id(&self) -> u16 {
            20
        }
        fn method_id(&self) -> u16 {
            60
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            0
        }
    }
    pub struct Pong;
    impl Pong {
        pub fn new() -> Self {
            Pong
        }
    }
    impl ::Payload for Pong {
        fn class_id(&self) -> u16 {
            20
        }
        fn method_id(&self) -> u16 {
            70
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            0
        }
    }
    pub struct Ok;
    impl Ok {
        pub fn new() -> Self {
            Ok
        }
    }
    impl ::Payload for Ok {
        fn class_id(&self) -> u16 {
            20
        }
        fn method_id(&self) -> u16 {
            80
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            0
        }
    }
    pub enum Method<'a> {
        Open(Open<'a>),
        OpenOk(OpenOk<'a>),
        Flow(Flow),
        FlowOk(FlowOk),
        Close(Close<'a>),
        CloseOk(CloseOk),
        Resume(Resume<'a>),
        Ping(Ping),
        Pong(Pong),
        Ok(Ok),
    } // enum Method

} // mod channel

pub mod connection {
    pub struct Headers;
    pub struct Start<'a> {
        version_major: u8,
        version_minor: u8,
        server_properties: ::field::Table<'a>,
        mechanisms: ::std::borrow::Cow<'a, [u8]>,
        locales: ::std::borrow::Cow<'a, [u8]>,
    }
    impl<'a> Start<'a> {
        pub fn new<S, M, L>(version_major: u8,
                            version_minor: u8,
                            server_properties: S,
                            mechanisms: M,
                            locales: L)
                            -> Self
            where S: Into<::field::Table<'a>>,
                  M: Into<::std::borrow::Cow<'a, [u8]>>,
                  L: Into<::std::borrow::Cow<'a, [u8]>>
        {
            Start {
                version_major: version_major,
                version_minor: version_minor,
                server_properties: server_properties.into(),
                mechanisms: mechanisms.into(),
                locales: locales.into(),
            }
        }
        impl_properties! {
(version_major, set_version_major) -> u8,
(version_minor, set_version_minor) -> u8,
(server_properties, server_properties_mut, set_server_properties) -> &::field::Table<'a>,
(mechanisms, mechanisms_mut, set_mechanisms) -> Cow<[u8]>,
(locales, locales_mut, set_locales) -> Cow<[u8]>,
} // impl_properties
    }
    impl<'a> ::Payload for Start<'a> {
        fn class_id(&self) -> u16 {
            10
        }
        fn method_id(&self) -> u16 {
            10
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [6, self.server_properties.amqp_size(), self.mechanisms.len(), self.locales.len()]
                .iter()
                .sum()
        }
    }
    pub struct StartOk<'a> {
        client_properties: ::field::Table<'a>,
        mechanism: ::std::borrow::Cow<'a, str>,
        response: ::std::borrow::Cow<'a, [u8]>,
        locale: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> StartOk<'a> {
        pub fn new<C, M, R, L>(client_properties: C, mechanism: M, response: R, locale: L) -> Self
            where C: Into<::field::Table<'a>>,
                  M: Into<::std::borrow::Cow<'a, str>>,
                  R: Into<::std::borrow::Cow<'a, [u8]>>,
                  L: Into<::std::borrow::Cow<'a, str>>
        {
            StartOk {
                client_properties: client_properties.into(),
                mechanism: mechanism.into(),
                response: response.into(),
                locale: locale.into(),
            }
        }
        impl_properties! {
(client_properties, client_properties_mut, set_client_properties) -> &::field::Table<'a>,
(mechanism, mechanism_mut, set_mechanism) -> Cow<str>,
(response, response_mut, set_response) -> Cow<[u8]>,
(locale, locale_mut, set_locale) -> Cow<str>,
} // impl_properties
    }
    impl<'a> ::Payload for StartOk<'a> {
        fn class_id(&self) -> u16 {
            10
        }
        fn method_id(&self) -> u16 {
            11
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [4,
             self.client_properties.amqp_size(),
             self.mechanism.len(),
             self.response.len(),
             self.locale.len()]
                .iter()
                .sum()
        }
    }
    pub struct Secure<'a> {
        challenge: ::std::borrow::Cow<'a, [u8]>,
    }
    impl<'a> Secure<'a> {
        pub fn new<C>(challenge: C) -> Self
            where C: Into<::std::borrow::Cow<'a, [u8]>>
        {
            Secure { challenge: challenge.into() }
        }
        impl_properties! {
(challenge, challenge_mut, set_challenge) -> Cow<[u8]>,
} // impl_properties
    }
    impl<'a> ::Payload for Secure<'a> {
        fn class_id(&self) -> u16 {
            10
        }
        fn method_id(&self) -> u16 {
            20
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [2, self.challenge.len()]
                .iter()
                .sum()
        }
    }
    pub struct SecureOk<'a> {
        response: ::std::borrow::Cow<'a, [u8]>,
    }
    impl<'a> SecureOk<'a> {
        pub fn new<R>(response: R) -> Self
            where R: Into<::std::borrow::Cow<'a, [u8]>>
        {
            SecureOk { response: response.into() }
        }
        impl_properties! {
(response, response_mut, set_response) -> Cow<[u8]>,
} // impl_properties
    }
    impl<'a> ::Payload for SecureOk<'a> {
        fn class_id(&self) -> u16 {
            10
        }
        fn method_id(&self) -> u16 {
            21
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [2, self.response.len()]
                .iter()
                .sum()
        }
    }
    pub struct Tune {
        channel_max: u16,
        frame_max: u32,
        heartbeat: u16,
    }
    impl Tune {
        pub fn new(channel_max: u16, frame_max: u32, heartbeat: u16) -> Self {
            Tune {
                channel_max: channel_max,
                frame_max: frame_max,
                heartbeat: heartbeat,
            }
        }
        impl_properties! {
(channel_max, set_channel_max) -> u16,
(frame_max, set_frame_max) -> u32,
(heartbeat, set_heartbeat) -> u16,
} // impl_properties
    }
    impl ::Payload for Tune {
        fn class_id(&self) -> u16 {
            10
        }
        fn method_id(&self) -> u16 {
            30
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            8
        }
    }
    pub struct TuneOk {
        channel_max: u16,
        frame_max: u32,
        heartbeat: u16,
    }
    impl TuneOk {
        pub fn new(channel_max: u16, frame_max: u32, heartbeat: u16) -> Self {
            TuneOk {
                channel_max: channel_max,
                frame_max: frame_max,
                heartbeat: heartbeat,
            }
        }
        impl_properties! {
(channel_max, set_channel_max) -> u16,
(frame_max, set_frame_max) -> u32,
(heartbeat, set_heartbeat) -> u16,
} // impl_properties
    }
    impl ::Payload for TuneOk {
        fn class_id(&self) -> u16 {
            10
        }
        fn method_id(&self) -> u16 {
            31
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            8
        }
    }
    pub struct Open<'a> {
        virtual_host: ::std::borrow::Cow<'a, str>,
        capabilities: ::std::borrow::Cow<'a, str>,
        insist: bool,
    }
    impl<'a> Open<'a> {
        pub fn new<V, C>(virtual_host: V, capabilities: C, insist: bool) -> Self
            where V: Into<::std::borrow::Cow<'a, str>>,
                  C: Into<::std::borrow::Cow<'a, str>>
        {
            Open {
                virtual_host: virtual_host.into(),
                capabilities: capabilities.into(),
                insist: insist,
            }
        }
        impl_properties! {
(virtual_host, virtual_host_mut, set_virtual_host) -> Cow<str>,
(capabilities, capabilities_mut, set_capabilities) -> Cow<str>,
(insist, set_insist) -> bool,
} // impl_properties
    }
    impl<'a> ::Payload for Open<'a> {
        fn class_id(&self) -> u16 {
            10
        }
        fn method_id(&self) -> u16 {
            40
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [3, self.virtual_host.len(), self.capabilities.len()]
                .iter()
                .sum()
        }
    }
    pub struct OpenOk<'a> {
        known_hosts: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> OpenOk<'a> {
        pub fn new<K>(known_hosts: K) -> Self
            where K: Into<::std::borrow::Cow<'a, str>>
        {
            OpenOk { known_hosts: known_hosts.into() }
        }
        impl_properties! {
(known_hosts, known_hosts_mut, set_known_hosts) -> Cow<str>,
} // impl_properties
    }
    impl<'a> ::Payload for OpenOk<'a> {
        fn class_id(&self) -> u16 {
            10
        }
        fn method_id(&self) -> u16 {
            41
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [1, self.known_hosts.len()]
                .iter()
                .sum()
        }
    }
    pub struct Redirect<'a> {
        host: ::std::borrow::Cow<'a, str>,
        known_hosts: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> Redirect<'a> {
        pub fn new<H, K>(host: H, known_hosts: K) -> Self
            where H: Into<::std::borrow::Cow<'a, str>>,
                  K: Into<::std::borrow::Cow<'a, str>>
        {
            Redirect {
                host: host.into(),
                known_hosts: known_hosts.into(),
            }
        }
        impl_properties! {
(host, host_mut, set_host) -> Cow<str>,
(known_hosts, known_hosts_mut, set_known_hosts) -> Cow<str>,
} // impl_properties
    }
    impl<'a> ::Payload for Redirect<'a> {
        fn class_id(&self) -> u16 {
            10
        }
        fn method_id(&self) -> u16 {
            42
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [2, self.host.len(), self.known_hosts.len()]
                .iter()
                .sum()
        }
    }
    pub struct Close<'a> {
        reply_code: u16,
        reply_text: ::std::borrow::Cow<'a, str>,
        class_id: u16,
        method_id: u16,
    }
    impl<'a> Close<'a> {
        pub fn new<R>(reply_code: u16, reply_text: R, class_id: u16, method_id: u16) -> Self
            where R: Into<::std::borrow::Cow<'a, str>>
        {
            Close {
                reply_code: reply_code,
                reply_text: reply_text.into(),
                class_id: class_id,
                method_id: method_id,
            }
        }
        impl_properties! {
(reply_code, set_reply_code) -> u16,
(reply_text, reply_text_mut, set_reply_text) -> Cow<str>,
(class_id, set_class_id) -> u16,
(method_id, set_method_id) -> u16,
} // impl_properties
    }
    impl<'a> ::Payload for Close<'a> {
        fn class_id(&self) -> u16 {
            10
        }
        fn method_id(&self) -> u16 {
            50
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [7, self.reply_text.len()]
                .iter()
                .sum()
        }
    }
    pub struct CloseOk;
    impl CloseOk {
        pub fn new() -> Self {
            CloseOk
        }
    }
    impl ::Payload for CloseOk {
        fn class_id(&self) -> u16 {
            10
        }
        fn method_id(&self) -> u16 {
            51
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            0
        }
    }
    pub enum Method<'a> {
        Start(Start<'a>),
        StartOk(StartOk<'a>),
        Secure(Secure<'a>),
        SecureOk(SecureOk<'a>),
        Tune(Tune),
        TuneOk(TuneOk),
        Open(Open<'a>),
        OpenOk(OpenOk<'a>),
        Redirect(Redirect<'a>),
        Close(Close<'a>),
        CloseOk(CloseOk),
    } // enum Method

} // mod connection

pub mod dtx {
    pub struct Headers;
    pub struct Select;
    impl Select {
        pub fn new() -> Self {
            Select
        }
    }
    impl ::Payload for Select {
        fn class_id(&self) -> u16 {
            100
        }
        fn method_id(&self) -> u16 {
            10
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            0
        }
    }
    pub struct SelectOk;
    impl SelectOk {
        pub fn new() -> Self {
            SelectOk
        }
    }
    impl ::Payload for SelectOk {
        fn class_id(&self) -> u16 {
            100
        }
        fn method_id(&self) -> u16 {
            11
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            0
        }
    }
    pub struct Start<'a> {
        dtx_identifier: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> Start<'a> {
        pub fn new<D>(dtx_identifier: D) -> Self
            where D: Into<::std::borrow::Cow<'a, str>>
        {
            Start { dtx_identifier: dtx_identifier.into() }
        }
        impl_properties! {
(dtx_identifier, dtx_identifier_mut, set_dtx_identifier) -> Cow<str>,
} // impl_properties
    }
    impl<'a> ::Payload for Start<'a> {
        fn class_id(&self) -> u16 {
            100
        }
        fn method_id(&self) -> u16 {
            20
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [1, self.dtx_identifier.len()]
                .iter()
                .sum()
        }
    }
    pub struct StartOk;
    impl StartOk {
        pub fn new() -> Self {
            StartOk
        }
    }
    impl ::Payload for StartOk {
        fn class_id(&self) -> u16 {
            100
        }
        fn method_id(&self) -> u16 {
            21
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            0
        }
    }
    pub enum Method<'a> {
        Select(Select),
        SelectOk(SelectOk),
        Start(Start<'a>),
        StartOk(StartOk),
    } // enum Method

} // mod dtx

pub mod exchange {
    pub struct Headers;
    pub struct Declare<'a> {
        ticket: u16,
        exchange: ::std::borrow::Cow<'a, str>,
        ty: ::std::borrow::Cow<'a, str>,
        passive: bool,
        durable: bool,
        auto_delete: bool,
        internal: bool,
        nowait: bool,
        arguments: ::field::Table<'a>,
    }
    impl<'a> Declare<'a> {
        pub fn new<E, T, A>(ticket: u16,
                            exchange: E,
                            ty: T,
                            passive: bool,
                            durable: bool,
                            auto_delete: bool,
                            internal: bool,
                            nowait: bool,
                            arguments: A)
                            -> Self
            where E: Into<::std::borrow::Cow<'a, str>>,
                  T: Into<::std::borrow::Cow<'a, str>>,
                  A: Into<::field::Table<'a>>
        {
            Declare {
                ticket: ticket,
                exchange: exchange.into(),
                ty: ty.into(),
                passive: passive,
                durable: durable,
                auto_delete: auto_delete,
                internal: internal,
                nowait: nowait,
                arguments: arguments.into(),
            }
        }
        impl_properties! {
(ticket, set_ticket) -> u16,
(exchange, exchange_mut, set_exchange) -> Cow<str>,
(ty, ty_mut, set_ty) -> Cow<str>,
(passive, set_passive) -> bool,
(durable, set_durable) -> bool,
(auto_delete, set_auto_delete) -> bool,
(internal, set_internal) -> bool,
(nowait, set_nowait) -> bool,
(arguments, arguments_mut, set_arguments) -> &::field::Table<'a>,
} // impl_properties
    }
    impl<'a> ::Payload for Declare<'a> {
        fn class_id(&self) -> u16 {
            40
        }
        fn method_id(&self) -> u16 {
            10
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [5, self.exchange.len(), self.ty.len(), self.arguments.amqp_size()]
                .iter()
                .sum()
        }
    }
    pub struct DeclareOk;
    impl DeclareOk {
        pub fn new() -> Self {
            DeclareOk
        }
    }
    impl ::Payload for DeclareOk {
        fn class_id(&self) -> u16 {
            40
        }
        fn method_id(&self) -> u16 {
            11
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            0
        }
    }
    pub struct Delete<'a> {
        ticket: u16,
        exchange: ::std::borrow::Cow<'a, str>,
        if_unused: bool,
        nowait: bool,
    }
    impl<'a> Delete<'a> {
        pub fn new<E>(ticket: u16, exchange: E, if_unused: bool, nowait: bool) -> Self
            where E: Into<::std::borrow::Cow<'a, str>>
        {
            Delete {
                ticket: ticket,
                exchange: exchange.into(),
                if_unused: if_unused,
                nowait: nowait,
            }
        }
        impl_properties! {
(ticket, set_ticket) -> u16,
(exchange, exchange_mut, set_exchange) -> Cow<str>,
(if_unused, set_if_unused) -> bool,
(nowait, set_nowait) -> bool,
} // impl_properties
    }
    impl<'a> ::Payload for Delete<'a> {
        fn class_id(&self) -> u16 {
            40
        }
        fn method_id(&self) -> u16 {
            20
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [4, self.exchange.len()]
                .iter()
                .sum()
        }
    }
    pub struct DeleteOk;
    impl DeleteOk {
        pub fn new() -> Self {
            DeleteOk
        }
    }
    impl ::Payload for DeleteOk {
        fn class_id(&self) -> u16 {
            40
        }
        fn method_id(&self) -> u16 {
            21
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            0
        }
    }
    pub struct Bound<'a> {
        exchange: ::std::borrow::Cow<'a, str>,
        routing_key: ::std::borrow::Cow<'a, str>,
        queue: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> Bound<'a> {
        pub fn new<E, R, Q>(exchange: E, routing_key: R, queue: Q) -> Self
            where E: Into<::std::borrow::Cow<'a, str>>,
                  R: Into<::std::borrow::Cow<'a, str>>,
                  Q: Into<::std::borrow::Cow<'a, str>>
        {
            Bound {
                exchange: exchange.into(),
                routing_key: routing_key.into(),
                queue: queue.into(),
            }
        }
        impl_properties! {
(exchange, exchange_mut, set_exchange) -> Cow<str>,
(routing_key, routing_key_mut, set_routing_key) -> Cow<str>,
(queue, queue_mut, set_queue) -> Cow<str>,
} // impl_properties
    }
    impl<'a> ::Payload for Bound<'a> {
        fn class_id(&self) -> u16 {
            40
        }
        fn method_id(&self) -> u16 {
            22
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [3, self.exchange.len(), self.routing_key.len(), self.queue.len()]
                .iter()
                .sum()
        }
    }
    pub struct BoundOk<'a> {
        reply_code: u16,
        reply_text: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> BoundOk<'a> {
        pub fn new<R>(reply_code: u16, reply_text: R) -> Self
            where R: Into<::std::borrow::Cow<'a, str>>
        {
            BoundOk {
                reply_code: reply_code,
                reply_text: reply_text.into(),
            }
        }
        impl_properties! {
(reply_code, set_reply_code) -> u16,
(reply_text, reply_text_mut, set_reply_text) -> Cow<str>,
} // impl_properties
    }
    impl<'a> ::Payload for BoundOk<'a> {
        fn class_id(&self) -> u16 {
            40
        }
        fn method_id(&self) -> u16 {
            23
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [3, self.reply_text.len()]
                .iter()
                .sum()
        }
    }
    pub enum Method<'a> {
        Declare(Declare<'a>),
        DeclareOk(DeclareOk),
        Delete(Delete<'a>),
        DeleteOk(DeleteOk),
        Bound(Bound<'a>),
        BoundOk(BoundOk<'a>),
    } // enum Method

} // mod exchange

pub mod file {
    pub struct Headers<'a> {
        content_type: Option<::std::borrow::Cow<'a, str>>,
        content_encoding: Option<::std::borrow::Cow<'a, str>>,
        headers: Option<::field::Table<'a>>,
        priority: Option<u8>,
        reply_to: Option<::std::borrow::Cow<'a, str>>,
        message_id: Option<::std::borrow::Cow<'a, str>>,
        filename: Option<::std::borrow::Cow<'a, str>>,
        timestamp: Option<u64>,
        cluster_id: Option<::std::borrow::Cow<'a, str>>,
    }

    impl<'a> Headers<'a> {
        impl_properties! {
(content_type, content_type_mut, set_content_type, take_content_type) -> Option< Cow<str> >,
(content_encoding, content_encoding_mut, set_content_encoding, take_content_encoding) -> Option< Cow<str> >,
(headers, headers_mut, set_headers, take_headers) -> Option<&::field::Table<'a>>,
(priority, priority_mut, set_priority, take_priority) -> Option<u8>,
(reply_to, reply_to_mut, set_reply_to, take_reply_to) -> Option< Cow<str> >,
(message_id, message_id_mut, set_message_id, take_message_id) -> Option< Cow<str> >,
(filename, filename_mut, set_filename, take_filename) -> Option< Cow<str> >,
(timestamp, timestamp_mut, set_timestamp, take_timestamp) -> Option<u64>,
(cluster_id, cluster_id_mut, set_cluster_id, take_cluster_id) -> Option< Cow<str> >,
} // impl_properties
    }
    pub struct Qos {
        prefetch_size: u32,
        prefetch_count: u16,
        global: bool,
    }
    impl Qos {
        pub fn new(prefetch_size: u32, prefetch_count: u16, global: bool) -> Self {
            Qos {
                prefetch_size: prefetch_size,
                prefetch_count: prefetch_count,
                global: global,
            }
        }
        impl_properties! {
(prefetch_size, set_prefetch_size) -> u32,
(prefetch_count, set_prefetch_count) -> u16,
(global, set_global) -> bool,
} // impl_properties
    }
    impl ::Payload for Qos {
        fn class_id(&self) -> u16 {
            70
        }
        fn method_id(&self) -> u16 {
            10
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            7
        }
    }
    pub struct QosOk;
    impl QosOk {
        pub fn new() -> Self {
            QosOk
        }
    }
    impl ::Payload for QosOk {
        fn class_id(&self) -> u16 {
            70
        }
        fn method_id(&self) -> u16 {
            11
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            0
        }
    }
    pub struct Consume<'a> {
        ticket: u16,
        queue: ::std::borrow::Cow<'a, str>,
        consumer_tag: ::std::borrow::Cow<'a, str>,
        no_local: bool,
        no_ack: bool,
        exclusive: bool,
        nowait: bool,
        filter: ::field::Table<'a>,
    }
    impl<'a> Consume<'a> {
        pub fn new<Q, C, F>(ticket: u16,
                            queue: Q,
                            consumer_tag: C,
                            no_local: bool,
                            no_ack: bool,
                            exclusive: bool,
                            nowait: bool,
                            filter: F)
                            -> Self
            where Q: Into<::std::borrow::Cow<'a, str>>,
                  C: Into<::std::borrow::Cow<'a, str>>,
                  F: Into<::field::Table<'a>>
        {
            Consume {
                ticket: ticket,
                queue: queue.into(),
                consumer_tag: consumer_tag.into(),
                no_local: no_local,
                no_ack: no_ack,
                exclusive: exclusive,
                nowait: nowait,
                filter: filter.into(),
            }
        }
        impl_properties! {
(ticket, set_ticket) -> u16,
(queue, queue_mut, set_queue) -> Cow<str>,
(consumer_tag, consumer_tag_mut, set_consumer_tag) -> Cow<str>,
(no_local, set_no_local) -> bool,
(no_ack, set_no_ack) -> bool,
(exclusive, set_exclusive) -> bool,
(nowait, set_nowait) -> bool,
(filter, filter_mut, set_filter) -> &::field::Table<'a>,
} // impl_properties
    }
    impl<'a> ::Payload for Consume<'a> {
        fn class_id(&self) -> u16 {
            70
        }
        fn method_id(&self) -> u16 {
            20
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [5, self.queue.len(), self.consumer_tag.len(), self.filter.amqp_size()]
                .iter()
                .sum()
        }
    }
    pub struct ConsumeOk<'a> {
        consumer_tag: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ConsumeOk<'a> {
        pub fn new<C>(consumer_tag: C) -> Self
            where C: Into<::std::borrow::Cow<'a, str>>
        {
            ConsumeOk { consumer_tag: consumer_tag.into() }
        }
        impl_properties! {
(consumer_tag, consumer_tag_mut, set_consumer_tag) -> Cow<str>,
} // impl_properties
    }
    impl<'a> ::Payload for ConsumeOk<'a> {
        fn class_id(&self) -> u16 {
            70
        }
        fn method_id(&self) -> u16 {
            21
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [1, self.consumer_tag.len()]
                .iter()
                .sum()
        }
    }
    pub struct Cancel<'a> {
        consumer_tag: ::std::borrow::Cow<'a, str>,
        nowait: bool,
    }
    impl<'a> Cancel<'a> {
        pub fn new<C>(consumer_tag: C, nowait: bool) -> Self
            where C: Into<::std::borrow::Cow<'a, str>>
        {
            Cancel {
                consumer_tag: consumer_tag.into(),
                nowait: nowait,
            }
        }
        impl_properties! {
(consumer_tag, consumer_tag_mut, set_consumer_tag) -> Cow<str>,
(nowait, set_nowait) -> bool,
} // impl_properties
    }
    impl<'a> ::Payload for Cancel<'a> {
        fn class_id(&self) -> u16 {
            70
        }
        fn method_id(&self) -> u16 {
            30
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [2, self.consumer_tag.len()]
                .iter()
                .sum()
        }
    }
    pub struct CancelOk<'a> {
        consumer_tag: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> CancelOk<'a> {
        pub fn new<C>(consumer_tag: C) -> Self
            where C: Into<::std::borrow::Cow<'a, str>>
        {
            CancelOk { consumer_tag: consumer_tag.into() }
        }
        impl_properties! {
(consumer_tag, consumer_tag_mut, set_consumer_tag) -> Cow<str>,
} // impl_properties
    }
    impl<'a> ::Payload for CancelOk<'a> {
        fn class_id(&self) -> u16 {
            70
        }
        fn method_id(&self) -> u16 {
            31
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [1, self.consumer_tag.len()]
                .iter()
                .sum()
        }
    }
    pub struct Open<'a> {
        identifier: ::std::borrow::Cow<'a, str>,
        content_size: u64,
    }
    impl<'a> Open<'a> {
        pub fn new<I>(identifier: I, content_size: u64) -> Self
            where I: Into<::std::borrow::Cow<'a, str>>
        {
            Open {
                identifier: identifier.into(),
                content_size: content_size,
            }
        }
        impl_properties! {
(identifier, identifier_mut, set_identifier) -> Cow<str>,
(content_size, set_content_size) -> u64,
} // impl_properties
    }
    impl<'a> ::Payload for Open<'a> {
        fn class_id(&self) -> u16 {
            70
        }
        fn method_id(&self) -> u16 {
            40
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [9, self.identifier.len()]
                .iter()
                .sum()
        }
    }
    pub struct OpenOk {
        staged_size: u64,
    }
    impl OpenOk {
        pub fn new(staged_size: u64) -> Self {
            OpenOk { staged_size: staged_size }
        }
        impl_properties! {
(staged_size, set_staged_size) -> u64,
} // impl_properties
    }
    impl ::Payload for OpenOk {
        fn class_id(&self) -> u16 {
            70
        }
        fn method_id(&self) -> u16 {
            41
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            8
        }
    }
    pub struct Stage;
    impl Stage {
        pub fn new() -> Self {
            Stage
        }
    }
    impl ::Payload for Stage {
        fn class_id(&self) -> u16 {
            70
        }
        fn method_id(&self) -> u16 {
            50
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            0
        }
    }
    pub struct Publish<'a> {
        ticket: u16,
        exchange: ::std::borrow::Cow<'a, str>,
        routing_key: ::std::borrow::Cow<'a, str>,
        mandatory: bool,
        immediate: bool,
        identifier: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> Publish<'a> {
        pub fn new<E, R, I>(ticket: u16,
                            exchange: E,
                            routing_key: R,
                            mandatory: bool,
                            immediate: bool,
                            identifier: I)
                            -> Self
            where E: Into<::std::borrow::Cow<'a, str>>,
                  R: Into<::std::borrow::Cow<'a, str>>,
                  I: Into<::std::borrow::Cow<'a, str>>
        {
            Publish {
                ticket: ticket,
                exchange: exchange.into(),
                routing_key: routing_key.into(),
                mandatory: mandatory,
                immediate: immediate,
                identifier: identifier.into(),
            }
        }
        impl_properties! {
(ticket, set_ticket) -> u16,
(exchange, exchange_mut, set_exchange) -> Cow<str>,
(routing_key, routing_key_mut, set_routing_key) -> Cow<str>,
(mandatory, set_mandatory) -> bool,
(immediate, set_immediate) -> bool,
(identifier, identifier_mut, set_identifier) -> Cow<str>,
} // impl_properties
    }
    impl<'a> ::Payload for Publish<'a> {
        fn class_id(&self) -> u16 {
            70
        }
        fn method_id(&self) -> u16 {
            60
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [6, self.exchange.len(), self.routing_key.len(), self.identifier.len()]
                .iter()
                .sum()
        }
    }
    pub struct Return<'a> {
        reply_code: u16,
        reply_text: ::std::borrow::Cow<'a, str>,
        exchange: ::std::borrow::Cow<'a, str>,
        routing_key: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> Return<'a> {
        pub fn new<R, E, R0>(reply_code: u16, reply_text: R, exchange: E, routing_key: R0) -> Self
            where R: Into<::std::borrow::Cow<'a, str>>,
                  E: Into<::std::borrow::Cow<'a, str>>,
                  R0: Into<::std::borrow::Cow<'a, str>>
        {
            Return {
                reply_code: reply_code,
                reply_text: reply_text.into(),
                exchange: exchange.into(),
                routing_key: routing_key.into(),
            }
        }
        impl_properties! {
(reply_code, set_reply_code) -> u16,
(reply_text, reply_text_mut, set_reply_text) -> Cow<str>,
(exchange, exchange_mut, set_exchange) -> Cow<str>,
(routing_key, routing_key_mut, set_routing_key) -> Cow<str>,
} // impl_properties
    }
    impl<'a> ::Payload for Return<'a> {
        fn class_id(&self) -> u16 {
            70
        }
        fn method_id(&self) -> u16 {
            70
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [5, self.reply_text.len(), self.exchange.len(), self.routing_key.len()]
                .iter()
                .sum()
        }
    }
    pub struct Deliver<'a> {
        consumer_tag: ::std::borrow::Cow<'a, str>,
        delivery_tag: u64,
        redelivered: bool,
        exchange: ::std::borrow::Cow<'a, str>,
        routing_key: ::std::borrow::Cow<'a, str>,
        identifier: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> Deliver<'a> {
        pub fn new<C, E, R, I>(consumer_tag: C,
                               delivery_tag: u64,
                               redelivered: bool,
                               exchange: E,
                               routing_key: R,
                               identifier: I)
                               -> Self
            where C: Into<::std::borrow::Cow<'a, str>>,
                  E: Into<::std::borrow::Cow<'a, str>>,
                  R: Into<::std::borrow::Cow<'a, str>>,
                  I: Into<::std::borrow::Cow<'a, str>>
        {
            Deliver {
                consumer_tag: consumer_tag.into(),
                delivery_tag: delivery_tag,
                redelivered: redelivered,
                exchange: exchange.into(),
                routing_key: routing_key.into(),
                identifier: identifier.into(),
            }
        }
        impl_properties! {
(consumer_tag, consumer_tag_mut, set_consumer_tag) -> Cow<str>,
(delivery_tag, set_delivery_tag) -> u64,
(redelivered, set_redelivered) -> bool,
(exchange, exchange_mut, set_exchange) -> Cow<str>,
(routing_key, routing_key_mut, set_routing_key) -> Cow<str>,
(identifier, identifier_mut, set_identifier) -> Cow<str>,
} // impl_properties
    }
    impl<'a> ::Payload for Deliver<'a> {
        fn class_id(&self) -> u16 {
            70
        }
        fn method_id(&self) -> u16 {
            80
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [13,
             self.consumer_tag.len(),
             self.exchange.len(),
             self.routing_key.len(),
             self.identifier.len()]
                .iter()
                .sum()
        }
    }
    pub struct Ack {
        delivery_tag: u64,
        multiple: bool,
    }
    impl Ack {
        pub fn new(delivery_tag: u64, multiple: bool) -> Self {
            Ack {
                delivery_tag: delivery_tag,
                multiple: multiple,
            }
        }
        impl_properties! {
(delivery_tag, set_delivery_tag) -> u64,
(multiple, set_multiple) -> bool,
} // impl_properties
    }
    impl ::Payload for Ack {
        fn class_id(&self) -> u16 {
            70
        }
        fn method_id(&self) -> u16 {
            90
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            9
        }
    }
    pub struct Reject {
        delivery_tag: u64,
        requeue: bool,
    }
    impl Reject {
        pub fn new(delivery_tag: u64, requeue: bool) -> Self {
            Reject {
                delivery_tag: delivery_tag,
                requeue: requeue,
            }
        }
        impl_properties! {
(delivery_tag, set_delivery_tag) -> u64,
(requeue, set_requeue) -> bool,
} // impl_properties
    }
    impl ::Payload for Reject {
        fn class_id(&self) -> u16 {
            70
        }
        fn method_id(&self) -> u16 {
            100
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            9
        }
    }
    pub enum Method<'a> {
        Qos(Qos),
        QosOk(QosOk),
        Consume(Consume<'a>),
        ConsumeOk(ConsumeOk<'a>),
        Cancel(Cancel<'a>),
        CancelOk(CancelOk<'a>),
        Open(Open<'a>),
        OpenOk(OpenOk),
        Stage(Stage),
        Publish(Publish<'a>),
        Return(Return<'a>),
        Deliver(Deliver<'a>),
        Ack(Ack),
        Reject(Reject),
    } // enum Method

} // mod file

pub mod message {
    pub struct Headers;
    pub struct Transfer<'a> {
        ticket: u16,
        destination: ::std::borrow::Cow<'a, str>,
        redelivered: bool,
        immediate: bool,
        ttl: u64,
        priority: u8,
        timestamp: u64,
        delivery_mode: u8,
        expiration: u64,
        exchange: ::std::borrow::Cow<'a, str>,
        routing_key: ::std::borrow::Cow<'a, str>,
        message_id: ::std::borrow::Cow<'a, str>,
        correlation_id: ::std::borrow::Cow<'a, str>,
        reply_to: ::std::borrow::Cow<'a, str>,
        content_type: ::std::borrow::Cow<'a, str>,
        content_encoding: ::std::borrow::Cow<'a, str>,
        user_id: ::std::borrow::Cow<'a, str>,
        app_id: ::std::borrow::Cow<'a, str>,
        transaction_id: ::std::borrow::Cow<'a, str>,
        security_token: ::std::borrow::Cow<'a, [u8]>,
        application_headers: ::field::Table<'a>,
        body: ::std::borrow::Cow<'a, [u8]>,
    }
    impl<'a> Transfer<'a> {
        pub fn new<D, E, R, M, C, R0, C0, C1, U, A, T, S, A0, B>(ticket: u16,
                                                                 destination: D,
                                                                 redelivered: bool,
                                                                 immediate: bool,
                                                                 ttl: u64,
                                                                 priority: u8,
                                                                 timestamp: u64,
                                                                 delivery_mode: u8,
                                                                 expiration: u64,
                                                                 exchange: E,
                                                                 routing_key: R,
                                                                 message_id: M,
                                                                 correlation_id: C,
                                                                 reply_to: R0,
                                                                 content_type: C0,
                                                                 content_encoding: C1,
                                                                 user_id: U,
                                                                 app_id: A,
                                                                 transaction_id: T,
                                                                 security_token: S,
                                                                 application_headers: A0,
                                                                 body: B)
                                                                 -> Self
            where D: Into<::std::borrow::Cow<'a, str>>,
                  E: Into<::std::borrow::Cow<'a, str>>,
                  R: Into<::std::borrow::Cow<'a, str>>,
                  M: Into<::std::borrow::Cow<'a, str>>,
                  C: Into<::std::borrow::Cow<'a, str>>,
                  R0: Into<::std::borrow::Cow<'a, str>>,
                  C0: Into<::std::borrow::Cow<'a, str>>,
                  C1: Into<::std::borrow::Cow<'a, str>>,
                  U: Into<::std::borrow::Cow<'a, str>>,
                  A: Into<::std::borrow::Cow<'a, str>>,
                  T: Into<::std::borrow::Cow<'a, str>>,
                  S: Into<::std::borrow::Cow<'a, [u8]>>,
                  A0: Into<::field::Table<'a>>,
                  B: Into<::std::borrow::Cow<'a, [u8]>>
        {
            Transfer {
                ticket: ticket,
                destination: destination.into(),
                redelivered: redelivered,
                immediate: immediate,
                ttl: ttl,
                priority: priority,
                timestamp: timestamp,
                delivery_mode: delivery_mode,
                expiration: expiration,
                exchange: exchange.into(),
                routing_key: routing_key.into(),
                message_id: message_id.into(),
                correlation_id: correlation_id.into(),
                reply_to: reply_to.into(),
                content_type: content_type.into(),
                content_encoding: content_encoding.into(),
                user_id: user_id.into(),
                app_id: app_id.into(),
                transaction_id: transaction_id.into(),
                security_token: security_token.into(),
                application_headers: application_headers.into(),
                body: body.into(),
            }
        }
        impl_properties! {
(ticket, set_ticket) -> u16,
(destination, destination_mut, set_destination) -> Cow<str>,
(redelivered, set_redelivered) -> bool,
(immediate, set_immediate) -> bool,
(ttl, set_ttl) -> u64,
(priority, set_priority) -> u8,
(timestamp, set_timestamp) -> u64,
(delivery_mode, set_delivery_mode) -> u8,
(expiration, set_expiration) -> u64,
(exchange, exchange_mut, set_exchange) -> Cow<str>,
(routing_key, routing_key_mut, set_routing_key) -> Cow<str>,
(message_id, message_id_mut, set_message_id) -> Cow<str>,
(correlation_id, correlation_id_mut, set_correlation_id) -> Cow<str>,
(reply_to, reply_to_mut, set_reply_to) -> Cow<str>,
(content_type, content_type_mut, set_content_type) -> Cow<str>,
(content_encoding, content_encoding_mut, set_content_encoding) -> Cow<str>,
(user_id, user_id_mut, set_user_id) -> Cow<str>,
(app_id, app_id_mut, set_app_id) -> Cow<str>,
(transaction_id, transaction_id_mut, set_transaction_id) -> Cow<str>,
(security_token, security_token_mut, set_security_token) -> Cow<[u8]>,
(application_headers, application_headers_mut, set_application_headers) -> &::field::Table<'a>,
(body, body_mut, set_body) -> Cow<[u8]>,
} // impl_properties
    }
    impl<'a> ::Payload for Transfer<'a> {
        fn class_id(&self) -> u16 {
            120
        }
        fn method_id(&self) -> u16 {
            10
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [43,
             self.destination.len(),
             self.exchange.len(),
             self.routing_key.len(),
             self.message_id.len(),
             self.correlation_id.len(),
             self.reply_to.len(),
             self.content_type.len(),
             self.content_encoding.len(),
             self.user_id.len(),
             self.app_id.len(),
             self.transaction_id.len(),
             self.security_token.len(),
             self.application_headers.amqp_size(),
             self.body.len()]
                .iter()
                .sum()
        }
    }
    pub struct Consume<'a> {
        ticket: u16,
        queue: ::std::borrow::Cow<'a, str>,
        destination: ::std::borrow::Cow<'a, str>,
        no_local: bool,
        no_ack: bool,
        exclusive: bool,
        filter: ::field::Table<'a>,
    }
    impl<'a> Consume<'a> {
        pub fn new<Q, D, F>(ticket: u16,
                            queue: Q,
                            destination: D,
                            no_local: bool,
                            no_ack: bool,
                            exclusive: bool,
                            filter: F)
                            -> Self
            where Q: Into<::std::borrow::Cow<'a, str>>,
                  D: Into<::std::borrow::Cow<'a, str>>,
                  F: Into<::field::Table<'a>>
        {
            Consume {
                ticket: ticket,
                queue: queue.into(),
                destination: destination.into(),
                no_local: no_local,
                no_ack: no_ack,
                exclusive: exclusive,
                filter: filter.into(),
            }
        }
        impl_properties! {
(ticket, set_ticket) -> u16,
(queue, queue_mut, set_queue) -> Cow<str>,
(destination, destination_mut, set_destination) -> Cow<str>,
(no_local, set_no_local) -> bool,
(no_ack, set_no_ack) -> bool,
(exclusive, set_exclusive) -> bool,
(filter, filter_mut, set_filter) -> &::field::Table<'a>,
} // impl_properties
    }
    impl<'a> ::Payload for Consume<'a> {
        fn class_id(&self) -> u16 {
            120
        }
        fn method_id(&self) -> u16 {
            20
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [5, self.queue.len(), self.destination.len(), self.filter.amqp_size()]
                .iter()
                .sum()
        }
    }
    pub struct Cancel<'a> {
        destination: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> Cancel<'a> {
        pub fn new<D>(destination: D) -> Self
            where D: Into<::std::borrow::Cow<'a, str>>
        {
            Cancel { destination: destination.into() }
        }
        impl_properties! {
(destination, destination_mut, set_destination) -> Cow<str>,
} // impl_properties
    }
    impl<'a> ::Payload for Cancel<'a> {
        fn class_id(&self) -> u16 {
            120
        }
        fn method_id(&self) -> u16 {
            30
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [1, self.destination.len()]
                .iter()
                .sum()
        }
    }
    pub struct Get<'a> {
        ticket: u16,
        queue: ::std::borrow::Cow<'a, str>,
        destination: ::std::borrow::Cow<'a, str>,
        no_ack: bool,
    }
    impl<'a> Get<'a> {
        pub fn new<Q, D>(ticket: u16, queue: Q, destination: D, no_ack: bool) -> Self
            where Q: Into<::std::borrow::Cow<'a, str>>,
                  D: Into<::std::borrow::Cow<'a, str>>
        {
            Get {
                ticket: ticket,
                queue: queue.into(),
                destination: destination.into(),
                no_ack: no_ack,
            }
        }
        impl_properties! {
(ticket, set_ticket) -> u16,
(queue, queue_mut, set_queue) -> Cow<str>,
(destination, destination_mut, set_destination) -> Cow<str>,
(no_ack, set_no_ack) -> bool,
} // impl_properties
    }
    impl<'a> ::Payload for Get<'a> {
        fn class_id(&self) -> u16 {
            120
        }
        fn method_id(&self) -> u16 {
            40
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [5, self.queue.len(), self.destination.len()]
                .iter()
                .sum()
        }
    }
    pub struct Recover {
        requeue: bool,
    }
    impl Recover {
        pub fn new(requeue: bool) -> Self {
            Recover { requeue: requeue }
        }
        impl_properties! {
(requeue, set_requeue) -> bool,
} // impl_properties
    }
    impl ::Payload for Recover {
        fn class_id(&self) -> u16 {
            120
        }
        fn method_id(&self) -> u16 {
            50
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            1
        }
    }
    pub struct Open<'a> {
        reference: ::std::borrow::Cow<'a, [u8]>,
    }
    impl<'a> Open<'a> {
        pub fn new<R>(reference: R) -> Self
            where R: Into<::std::borrow::Cow<'a, [u8]>>
        {
            Open { reference: reference.into() }
        }
        impl_properties! {
(reference, reference_mut, set_reference) -> Cow<[u8]>,
} // impl_properties
    }
    impl<'a> ::Payload for Open<'a> {
        fn class_id(&self) -> u16 {
            120
        }
        fn method_id(&self) -> u16 {
            60
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [2, self.reference.len()]
                .iter()
                .sum()
        }
    }
    pub struct Close<'a> {
        reference: ::std::borrow::Cow<'a, [u8]>,
    }
    impl<'a> Close<'a> {
        pub fn new<R>(reference: R) -> Self
            where R: Into<::std::borrow::Cow<'a, [u8]>>
        {
            Close { reference: reference.into() }
        }
        impl_properties! {
(reference, reference_mut, set_reference) -> Cow<[u8]>,
} // impl_properties
    }
    impl<'a> ::Payload for Close<'a> {
        fn class_id(&self) -> u16 {
            120
        }
        fn method_id(&self) -> u16 {
            70
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [2, self.reference.len()]
                .iter()
                .sum()
        }
    }
    pub struct Append<'a> {
        reference: ::std::borrow::Cow<'a, [u8]>,
        bytes: ::std::borrow::Cow<'a, [u8]>,
    }
    impl<'a> Append<'a> {
        pub fn new<R, B>(reference: R, bytes: B) -> Self
            where R: Into<::std::borrow::Cow<'a, [u8]>>,
                  B: Into<::std::borrow::Cow<'a, [u8]>>
        {
            Append {
                reference: reference.into(),
                bytes: bytes.into(),
            }
        }
        impl_properties! {
(reference, reference_mut, set_reference) -> Cow<[u8]>,
(bytes, bytes_mut, set_bytes) -> Cow<[u8]>,
} // impl_properties
    }
    impl<'a> ::Payload for Append<'a> {
        fn class_id(&self) -> u16 {
            120
        }
        fn method_id(&self) -> u16 {
            80
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [4, self.reference.len(), self.bytes.len()]
                .iter()
                .sum()
        }
    }
    pub struct Checkpoint<'a> {
        reference: ::std::borrow::Cow<'a, [u8]>,
        identifier: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> Checkpoint<'a> {
        pub fn new<R, I>(reference: R, identifier: I) -> Self
            where R: Into<::std::borrow::Cow<'a, [u8]>>,
                  I: Into<::std::borrow::Cow<'a, str>>
        {
            Checkpoint {
                reference: reference.into(),
                identifier: identifier.into(),
            }
        }
        impl_properties! {
(reference, reference_mut, set_reference) -> Cow<[u8]>,
(identifier, identifier_mut, set_identifier) -> Cow<str>,
} // impl_properties
    }
    impl<'a> ::Payload for Checkpoint<'a> {
        fn class_id(&self) -> u16 {
            120
        }
        fn method_id(&self) -> u16 {
            90
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [3, self.reference.len(), self.identifier.len()]
                .iter()
                .sum()
        }
    }
    pub struct Resume<'a> {
        reference: ::std::borrow::Cow<'a, [u8]>,
        identifier: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> Resume<'a> {
        pub fn new<R, I>(reference: R, identifier: I) -> Self
            where R: Into<::std::borrow::Cow<'a, [u8]>>,
                  I: Into<::std::borrow::Cow<'a, str>>
        {
            Resume {
                reference: reference.into(),
                identifier: identifier.into(),
            }
        }
        impl_properties! {
(reference, reference_mut, set_reference) -> Cow<[u8]>,
(identifier, identifier_mut, set_identifier) -> Cow<str>,
} // impl_properties
    }
    impl<'a> ::Payload for Resume<'a> {
        fn class_id(&self) -> u16 {
            120
        }
        fn method_id(&self) -> u16 {
            100
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [3, self.reference.len(), self.identifier.len()]
                .iter()
                .sum()
        }
    }
    pub struct Qos {
        prefetch_size: u32,
        prefetch_count: u16,
        global: bool,
    }
    impl Qos {
        pub fn new(prefetch_size: u32, prefetch_count: u16, global: bool) -> Self {
            Qos {
                prefetch_size: prefetch_size,
                prefetch_count: prefetch_count,
                global: global,
            }
        }
        impl_properties! {
(prefetch_size, set_prefetch_size) -> u32,
(prefetch_count, set_prefetch_count) -> u16,
(global, set_global) -> bool,
} // impl_properties
    }
    impl ::Payload for Qos {
        fn class_id(&self) -> u16 {
            120
        }
        fn method_id(&self) -> u16 {
            110
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            7
        }
    }
    pub struct Ok;
    impl Ok {
        pub fn new() -> Self {
            Ok
        }
    }
    impl ::Payload for Ok {
        fn class_id(&self) -> u16 {
            120
        }
        fn method_id(&self) -> u16 {
            500
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            0
        }
    }
    pub struct Empty;
    impl Empty {
        pub fn new() -> Self {
            Empty
        }
    }
    impl ::Payload for Empty {
        fn class_id(&self) -> u16 {
            120
        }
        fn method_id(&self) -> u16 {
            510
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            0
        }
    }
    pub struct Reject<'a> {
        code: u16,
        text: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> Reject<'a> {
        pub fn new<T>(code: u16, text: T) -> Self
            where T: Into<::std::borrow::Cow<'a, str>>
        {
            Reject {
                code: code,
                text: text.into(),
            }
        }
        impl_properties! {
(code, set_code) -> u16,
(text, text_mut, set_text) -> Cow<str>,
} // impl_properties
    }
    impl<'a> ::Payload for Reject<'a> {
        fn class_id(&self) -> u16 {
            120
        }
        fn method_id(&self) -> u16 {
            520
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [3, self.text.len()]
                .iter()
                .sum()
        }
    }
    pub struct Offset {
        value: u64,
    }
    impl Offset {
        pub fn new(value: u64) -> Self {
            Offset { value: value }
        }
        impl_properties! {
(value, set_value) -> u64,
} // impl_properties
    }
    impl ::Payload for Offset {
        fn class_id(&self) -> u16 {
            120
        }
        fn method_id(&self) -> u16 {
            530
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            8
        }
    }
    pub enum Method<'a> {
        Transfer(Transfer<'a>),
        Consume(Consume<'a>),
        Cancel(Cancel<'a>),
        Get(Get<'a>),
        Recover(Recover),
        Open(Open<'a>),
        Close(Close<'a>),
        Append(Append<'a>),
        Checkpoint(Checkpoint<'a>),
        Resume(Resume<'a>),
        Qos(Qos),
        Ok(Ok),
        Empty(Empty),
        Reject(Reject<'a>),
        Offset(Offset),
    } // enum Method

} // mod message

pub mod queue {
    pub struct Headers;
    pub struct Declare<'a> {
        ticket: u16,
        queue: ::std::borrow::Cow<'a, str>,
        passive: bool,
        durable: bool,
        exclusive: bool,
        auto_delete: bool,
        nowait: bool,
        arguments: ::field::Table<'a>,
    }
    impl<'a> Declare<'a> {
        pub fn new<Q, A>(ticket: u16,
                         queue: Q,
                         passive: bool,
                         durable: bool,
                         exclusive: bool,
                         auto_delete: bool,
                         nowait: bool,
                         arguments: A)
                         -> Self
            where Q: Into<::std::borrow::Cow<'a, str>>,
                  A: Into<::field::Table<'a>>
        {
            Declare {
                ticket: ticket,
                queue: queue.into(),
                passive: passive,
                durable: durable,
                exclusive: exclusive,
                auto_delete: auto_delete,
                nowait: nowait,
                arguments: arguments.into(),
            }
        }
        impl_properties! {
(ticket, set_ticket) -> u16,
(queue, queue_mut, set_queue) -> Cow<str>,
(passive, set_passive) -> bool,
(durable, set_durable) -> bool,
(exclusive, set_exclusive) -> bool,
(auto_delete, set_auto_delete) -> bool,
(nowait, set_nowait) -> bool,
(arguments, arguments_mut, set_arguments) -> &::field::Table<'a>,
} // impl_properties
    }
    impl<'a> ::Payload for Declare<'a> {
        fn class_id(&self) -> u16 {
            50
        }
        fn method_id(&self) -> u16 {
            10
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [4, self.queue.len(), self.arguments.amqp_size()]
                .iter()
                .sum()
        }
    }
    pub struct DeclareOk<'a> {
        queue: ::std::borrow::Cow<'a, str>,
        message_count: u32,
        consumer_count: u32,
    }
    impl<'a> DeclareOk<'a> {
        pub fn new<Q>(queue: Q, message_count: u32, consumer_count: u32) -> Self
            where Q: Into<::std::borrow::Cow<'a, str>>
        {
            DeclareOk {
                queue: queue.into(),
                message_count: message_count,
                consumer_count: consumer_count,
            }
        }
        impl_properties! {
(queue, queue_mut, set_queue) -> Cow<str>,
(message_count, set_message_count) -> u32,
(consumer_count, set_consumer_count) -> u32,
} // impl_properties
    }
    impl<'a> ::Payload for DeclareOk<'a> {
        fn class_id(&self) -> u16 {
            50
        }
        fn method_id(&self) -> u16 {
            11
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [9, self.queue.len()]
                .iter()
                .sum()
        }
    }
    pub struct Bind<'a> {
        ticket: u16,
        queue: ::std::borrow::Cow<'a, str>,
        exchange: ::std::borrow::Cow<'a, str>,
        routing_key: ::std::borrow::Cow<'a, str>,
        nowait: bool,
        arguments: ::field::Table<'a>,
    }
    impl<'a> Bind<'a> {
        pub fn new<Q, E, R, A>(ticket: u16,
                               queue: Q,
                               exchange: E,
                               routing_key: R,
                               nowait: bool,
                               arguments: A)
                               -> Self
            where Q: Into<::std::borrow::Cow<'a, str>>,
                  E: Into<::std::borrow::Cow<'a, str>>,
                  R: Into<::std::borrow::Cow<'a, str>>,
                  A: Into<::field::Table<'a>>
        {
            Bind {
                ticket: ticket,
                queue: queue.into(),
                exchange: exchange.into(),
                routing_key: routing_key.into(),
                nowait: nowait,
                arguments: arguments.into(),
            }
        }
        impl_properties! {
(ticket, set_ticket) -> u16,
(queue, queue_mut, set_queue) -> Cow<str>,
(exchange, exchange_mut, set_exchange) -> Cow<str>,
(routing_key, routing_key_mut, set_routing_key) -> Cow<str>,
(nowait, set_nowait) -> bool,
(arguments, arguments_mut, set_arguments) -> &::field::Table<'a>,
} // impl_properties
    }
    impl<'a> ::Payload for Bind<'a> {
        fn class_id(&self) -> u16 {
            50
        }
        fn method_id(&self) -> u16 {
            20
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [6,
             self.queue.len(),
             self.exchange.len(),
             self.routing_key.len(),
             self.arguments.amqp_size()]
                .iter()
                .sum()
        }
    }
    pub struct BindOk;
    impl BindOk {
        pub fn new() -> Self {
            BindOk
        }
    }
    impl ::Payload for BindOk {
        fn class_id(&self) -> u16 {
            50
        }
        fn method_id(&self) -> u16 {
            21
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            0
        }
    }
    pub struct Unbind<'a> {
        ticket: u16,
        queue: ::std::borrow::Cow<'a, str>,
        exchange: ::std::borrow::Cow<'a, str>,
        routing_key: ::std::borrow::Cow<'a, str>,
        arguments: ::field::Table<'a>,
    }
    impl<'a> Unbind<'a> {
        pub fn new<Q, E, R, A>(ticket: u16,
                               queue: Q,
                               exchange: E,
                               routing_key: R,
                               arguments: A)
                               -> Self
            where Q: Into<::std::borrow::Cow<'a, str>>,
                  E: Into<::std::borrow::Cow<'a, str>>,
                  R: Into<::std::borrow::Cow<'a, str>>,
                  A: Into<::field::Table<'a>>
        {
            Unbind {
                ticket: ticket,
                queue: queue.into(),
                exchange: exchange.into(),
                routing_key: routing_key.into(),
                arguments: arguments.into(),
            }
        }
        impl_properties! {
(ticket, set_ticket) -> u16,
(queue, queue_mut, set_queue) -> Cow<str>,
(exchange, exchange_mut, set_exchange) -> Cow<str>,
(routing_key, routing_key_mut, set_routing_key) -> Cow<str>,
(arguments, arguments_mut, set_arguments) -> &::field::Table<'a>,
} // impl_properties
    }
    impl<'a> ::Payload for Unbind<'a> {
        fn class_id(&self) -> u16 {
            50
        }
        fn method_id(&self) -> u16 {
            50
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [5,
             self.queue.len(),
             self.exchange.len(),
             self.routing_key.len(),
             self.arguments.amqp_size()]
                .iter()
                .sum()
        }
    }
    pub struct UnbindOk;
    impl UnbindOk {
        pub fn new() -> Self {
            UnbindOk
        }
    }
    impl ::Payload for UnbindOk {
        fn class_id(&self) -> u16 {
            50
        }
        fn method_id(&self) -> u16 {
            51
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            0
        }
    }
    pub struct Purge<'a> {
        ticket: u16,
        queue: ::std::borrow::Cow<'a, str>,
        nowait: bool,
    }
    impl<'a> Purge<'a> {
        pub fn new<Q>(ticket: u16, queue: Q, nowait: bool) -> Self
            where Q: Into<::std::borrow::Cow<'a, str>>
        {
            Purge {
                ticket: ticket,
                queue: queue.into(),
                nowait: nowait,
            }
        }
        impl_properties! {
(ticket, set_ticket) -> u16,
(queue, queue_mut, set_queue) -> Cow<str>,
(nowait, set_nowait) -> bool,
} // impl_properties
    }
    impl<'a> ::Payload for Purge<'a> {
        fn class_id(&self) -> u16 {
            50
        }
        fn method_id(&self) -> u16 {
            30
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [4, self.queue.len()]
                .iter()
                .sum()
        }
    }
    pub struct PurgeOk {
        message_count: u32,
    }
    impl PurgeOk {
        pub fn new(message_count: u32) -> Self {
            PurgeOk { message_count: message_count }
        }
        impl_properties! {
(message_count, set_message_count) -> u32,
} // impl_properties
    }
    impl ::Payload for PurgeOk {
        fn class_id(&self) -> u16 {
            50
        }
        fn method_id(&self) -> u16 {
            31
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            4
        }
    }
    pub struct Delete<'a> {
        ticket: u16,
        queue: ::std::borrow::Cow<'a, str>,
        if_unused: bool,
        if_empty: bool,
        nowait: bool,
    }
    impl<'a> Delete<'a> {
        pub fn new<Q>(ticket: u16, queue: Q, if_unused: bool, if_empty: bool, nowait: bool) -> Self
            where Q: Into<::std::borrow::Cow<'a, str>>
        {
            Delete {
                ticket: ticket,
                queue: queue.into(),
                if_unused: if_unused,
                if_empty: if_empty,
                nowait: nowait,
            }
        }
        impl_properties! {
(ticket, set_ticket) -> u16,
(queue, queue_mut, set_queue) -> Cow<str>,
(if_unused, set_if_unused) -> bool,
(if_empty, set_if_empty) -> bool,
(nowait, set_nowait) -> bool,
} // impl_properties
    }
    impl<'a> ::Payload for Delete<'a> {
        fn class_id(&self) -> u16 {
            50
        }
        fn method_id(&self) -> u16 {
            40
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [4, self.queue.len()]
                .iter()
                .sum()
        }
    }
    pub struct DeleteOk {
        message_count: u32,
    }
    impl DeleteOk {
        pub fn new(message_count: u32) -> Self {
            DeleteOk { message_count: message_count }
        }
        impl_properties! {
(message_count, set_message_count) -> u32,
} // impl_properties
    }
    impl ::Payload for DeleteOk {
        fn class_id(&self) -> u16 {
            50
        }
        fn method_id(&self) -> u16 {
            41
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            4
        }
    }
    pub enum Method<'a> {
        Declare(Declare<'a>),
        DeclareOk(DeclareOk<'a>),
        Bind(Bind<'a>),
        BindOk(BindOk),
        Unbind(Unbind<'a>),
        UnbindOk(UnbindOk),
        Purge(Purge<'a>),
        PurgeOk(PurgeOk),
        Delete(Delete<'a>),
        DeleteOk(DeleteOk),
    } // enum Method

} // mod queue

pub mod stream {
    pub struct Headers<'a> {
        content_type: Option<::std::borrow::Cow<'a, str>>,
        content_encoding: Option<::std::borrow::Cow<'a, str>>,
        headers: Option<::field::Table<'a>>,
        priority: Option<u8>,
        timestamp: Option<u64>,
    }

    impl<'a> Headers<'a> {
        impl_properties! {
(content_type, content_type_mut, set_content_type, take_content_type) -> Option< Cow<str> >,
(content_encoding, content_encoding_mut, set_content_encoding, take_content_encoding) -> Option< Cow<str> >,
(headers, headers_mut, set_headers, take_headers) -> Option<&::field::Table<'a>>,
(priority, priority_mut, set_priority, take_priority) -> Option<u8>,
(timestamp, timestamp_mut, set_timestamp, take_timestamp) -> Option<u64>,
} // impl_properties
    }
    pub struct Qos {
        prefetch_size: u32,
        prefetch_count: u16,
        consume_rate: u32,
        global: bool,
    }
    impl Qos {
        pub fn new(prefetch_size: u32,
                   prefetch_count: u16,
                   consume_rate: u32,
                   global: bool)
                   -> Self {
            Qos {
                prefetch_size: prefetch_size,
                prefetch_count: prefetch_count,
                consume_rate: consume_rate,
                global: global,
            }
        }
        impl_properties! {
(prefetch_size, set_prefetch_size) -> u32,
(prefetch_count, set_prefetch_count) -> u16,
(consume_rate, set_consume_rate) -> u32,
(global, set_global) -> bool,
} // impl_properties
    }
    impl ::Payload for Qos {
        fn class_id(&self) -> u16 {
            80
        }
        fn method_id(&self) -> u16 {
            10
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            11
        }
    }
    pub struct QosOk;
    impl QosOk {
        pub fn new() -> Self {
            QosOk
        }
    }
    impl ::Payload for QosOk {
        fn class_id(&self) -> u16 {
            80
        }
        fn method_id(&self) -> u16 {
            11
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            0
        }
    }
    pub struct Consume<'a> {
        ticket: u16,
        queue: ::std::borrow::Cow<'a, str>,
        consumer_tag: ::std::borrow::Cow<'a, str>,
        no_local: bool,
        exclusive: bool,
        nowait: bool,
        filter: ::field::Table<'a>,
    }
    impl<'a> Consume<'a> {
        pub fn new<Q, C, F>(ticket: u16,
                            queue: Q,
                            consumer_tag: C,
                            no_local: bool,
                            exclusive: bool,
                            nowait: bool,
                            filter: F)
                            -> Self
            where Q: Into<::std::borrow::Cow<'a, str>>,
                  C: Into<::std::borrow::Cow<'a, str>>,
                  F: Into<::field::Table<'a>>
        {
            Consume {
                ticket: ticket,
                queue: queue.into(),
                consumer_tag: consumer_tag.into(),
                no_local: no_local,
                exclusive: exclusive,
                nowait: nowait,
                filter: filter.into(),
            }
        }
        impl_properties! {
(ticket, set_ticket) -> u16,
(queue, queue_mut, set_queue) -> Cow<str>,
(consumer_tag, consumer_tag_mut, set_consumer_tag) -> Cow<str>,
(no_local, set_no_local) -> bool,
(exclusive, set_exclusive) -> bool,
(nowait, set_nowait) -> bool,
(filter, filter_mut, set_filter) -> &::field::Table<'a>,
} // impl_properties
    }
    impl<'a> ::Payload for Consume<'a> {
        fn class_id(&self) -> u16 {
            80
        }
        fn method_id(&self) -> u16 {
            20
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [5, self.queue.len(), self.consumer_tag.len(), self.filter.amqp_size()]
                .iter()
                .sum()
        }
    }
    pub struct ConsumeOk<'a> {
        consumer_tag: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> ConsumeOk<'a> {
        pub fn new<C>(consumer_tag: C) -> Self
            where C: Into<::std::borrow::Cow<'a, str>>
        {
            ConsumeOk { consumer_tag: consumer_tag.into() }
        }
        impl_properties! {
(consumer_tag, consumer_tag_mut, set_consumer_tag) -> Cow<str>,
} // impl_properties
    }
    impl<'a> ::Payload for ConsumeOk<'a> {
        fn class_id(&self) -> u16 {
            80
        }
        fn method_id(&self) -> u16 {
            21
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [1, self.consumer_tag.len()]
                .iter()
                .sum()
        }
    }
    pub struct Cancel<'a> {
        consumer_tag: ::std::borrow::Cow<'a, str>,
        nowait: bool,
    }
    impl<'a> Cancel<'a> {
        pub fn new<C>(consumer_tag: C, nowait: bool) -> Self
            where C: Into<::std::borrow::Cow<'a, str>>
        {
            Cancel {
                consumer_tag: consumer_tag.into(),
                nowait: nowait,
            }
        }
        impl_properties! {
(consumer_tag, consumer_tag_mut, set_consumer_tag) -> Cow<str>,
(nowait, set_nowait) -> bool,
} // impl_properties
    }
    impl<'a> ::Payload for Cancel<'a> {
        fn class_id(&self) -> u16 {
            80
        }
        fn method_id(&self) -> u16 {
            30
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [2, self.consumer_tag.len()]
                .iter()
                .sum()
        }
    }
    pub struct CancelOk<'a> {
        consumer_tag: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> CancelOk<'a> {
        pub fn new<C>(consumer_tag: C) -> Self
            where C: Into<::std::borrow::Cow<'a, str>>
        {
            CancelOk { consumer_tag: consumer_tag.into() }
        }
        impl_properties! {
(consumer_tag, consumer_tag_mut, set_consumer_tag) -> Cow<str>,
} // impl_properties
    }
    impl<'a> ::Payload for CancelOk<'a> {
        fn class_id(&self) -> u16 {
            80
        }
        fn method_id(&self) -> u16 {
            31
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [1, self.consumer_tag.len()]
                .iter()
                .sum()
        }
    }
    pub struct Publish<'a> {
        ticket: u16,
        exchange: ::std::borrow::Cow<'a, str>,
        routing_key: ::std::borrow::Cow<'a, str>,
        mandatory: bool,
        immediate: bool,
    }
    impl<'a> Publish<'a> {
        pub fn new<E, R>(ticket: u16,
                         exchange: E,
                         routing_key: R,
                         mandatory: bool,
                         immediate: bool)
                         -> Self
            where E: Into<::std::borrow::Cow<'a, str>>,
                  R: Into<::std::borrow::Cow<'a, str>>
        {
            Publish {
                ticket: ticket,
                exchange: exchange.into(),
                routing_key: routing_key.into(),
                mandatory: mandatory,
                immediate: immediate,
            }
        }
        impl_properties! {
(ticket, set_ticket) -> u16,
(exchange, exchange_mut, set_exchange) -> Cow<str>,
(routing_key, routing_key_mut, set_routing_key) -> Cow<str>,
(mandatory, set_mandatory) -> bool,
(immediate, set_immediate) -> bool,
} // impl_properties
    }
    impl<'a> ::Payload for Publish<'a> {
        fn class_id(&self) -> u16 {
            80
        }
        fn method_id(&self) -> u16 {
            40
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [5, self.exchange.len(), self.routing_key.len()]
                .iter()
                .sum()
        }
    }
    pub struct Return<'a> {
        reply_code: u16,
        reply_text: ::std::borrow::Cow<'a, str>,
        exchange: ::std::borrow::Cow<'a, str>,
        routing_key: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> Return<'a> {
        pub fn new<R, E, R0>(reply_code: u16, reply_text: R, exchange: E, routing_key: R0) -> Self
            where R: Into<::std::borrow::Cow<'a, str>>,
                  E: Into<::std::borrow::Cow<'a, str>>,
                  R0: Into<::std::borrow::Cow<'a, str>>
        {
            Return {
                reply_code: reply_code,
                reply_text: reply_text.into(),
                exchange: exchange.into(),
                routing_key: routing_key.into(),
            }
        }
        impl_properties! {
(reply_code, set_reply_code) -> u16,
(reply_text, reply_text_mut, set_reply_text) -> Cow<str>,
(exchange, exchange_mut, set_exchange) -> Cow<str>,
(routing_key, routing_key_mut, set_routing_key) -> Cow<str>,
} // impl_properties
    }
    impl<'a> ::Payload for Return<'a> {
        fn class_id(&self) -> u16 {
            80
        }
        fn method_id(&self) -> u16 {
            50
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [5, self.reply_text.len(), self.exchange.len(), self.routing_key.len()]
                .iter()
                .sum()
        }
    }
    pub struct Deliver<'a> {
        consumer_tag: ::std::borrow::Cow<'a, str>,
        delivery_tag: u64,
        exchange: ::std::borrow::Cow<'a, str>,
        queue: ::std::borrow::Cow<'a, str>,
    }
    impl<'a> Deliver<'a> {
        pub fn new<C, E, Q>(consumer_tag: C, delivery_tag: u64, exchange: E, queue: Q) -> Self
            where C: Into<::std::borrow::Cow<'a, str>>,
                  E: Into<::std::borrow::Cow<'a, str>>,
                  Q: Into<::std::borrow::Cow<'a, str>>
        {
            Deliver {
                consumer_tag: consumer_tag.into(),
                delivery_tag: delivery_tag,
                exchange: exchange.into(),
                queue: queue.into(),
            }
        }
        impl_properties! {
(consumer_tag, consumer_tag_mut, set_consumer_tag) -> Cow<str>,
(delivery_tag, set_delivery_tag) -> u64,
(exchange, exchange_mut, set_exchange) -> Cow<str>,
(queue, queue_mut, set_queue) -> Cow<str>,
} // impl_properties
    }
    impl<'a> ::Payload for Deliver<'a> {
        fn class_id(&self) -> u16 {
            80
        }
        fn method_id(&self) -> u16 {
            60
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [11, self.consumer_tag.len(), self.exchange.len(), self.queue.len()]
                .iter()
                .sum()
        }
    }
    pub enum Method<'a> {
        Qos(Qos),
        QosOk(QosOk),
        Consume(Consume<'a>),
        ConsumeOk(ConsumeOk<'a>),
        Cancel(Cancel<'a>),
        CancelOk(CancelOk<'a>),
        Publish(Publish<'a>),
        Return(Return<'a>),
        Deliver(Deliver<'a>),
    } // enum Method

} // mod stream

pub mod tunnel {
    pub struct Headers<'a> {
        headers: Option<::field::Table<'a>>,
        proxy_name: Option<::std::borrow::Cow<'a, str>>,
        data_name: Option<::std::borrow::Cow<'a, str>>,
        durable: Option<u8>,
        broadcast: Option<u8>,
    }

    impl<'a> Headers<'a> {
        impl_properties! {
(headers, headers_mut, set_headers, take_headers) -> Option<&::field::Table<'a>>,
(proxy_name, proxy_name_mut, set_proxy_name, take_proxy_name) -> Option< Cow<str> >,
(data_name, data_name_mut, set_data_name, take_data_name) -> Option< Cow<str> >,
(durable, durable_mut, set_durable, take_durable) -> Option<u8>,
(broadcast, broadcast_mut, set_broadcast, take_broadcast) -> Option<u8>,
} // impl_properties
    }
    pub struct Request<'a> {
        meta_data: ::field::Table<'a>,
    }
    impl<'a> Request<'a> {
        pub fn new<M>(meta_data: M) -> Self
            where M: Into<::field::Table<'a>>
        {
            Request { meta_data: meta_data.into() }
        }
        impl_properties! {
(meta_data, meta_data_mut, set_meta_data) -> &::field::Table<'a>,
} // impl_properties
    }
    impl<'a> ::Payload for Request<'a> {
        fn class_id(&self) -> u16 {
            110
        }
        fn method_id(&self) -> u16 {
            10
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            [0, self.meta_data.amqp_size()]
                .iter()
                .sum()
        }
    }
    pub enum Method<'a> {
        Request(Request<'a>),
    } // enum Method

} // mod tunnel

pub mod tx {
    pub struct Headers;
    pub struct Select;
    impl Select {
        pub fn new() -> Self {
            Select
        }
    }
    impl ::Payload for Select {
        fn class_id(&self) -> u16 {
            90
        }
        fn method_id(&self) -> u16 {
            10
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            0
        }
    }
    pub struct SelectOk;
    impl SelectOk {
        pub fn new() -> Self {
            SelectOk
        }
    }
    impl ::Payload for SelectOk {
        fn class_id(&self) -> u16 {
            90
        }
        fn method_id(&self) -> u16 {
            11
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            0
        }
    }
    pub struct Commit;
    impl Commit {
        pub fn new() -> Self {
            Commit
        }
    }
    impl ::Payload for Commit {
        fn class_id(&self) -> u16 {
            90
        }
        fn method_id(&self) -> u16 {
            20
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            0
        }
    }
    pub struct CommitOk;
    impl CommitOk {
        pub fn new() -> Self {
            CommitOk
        }
    }
    impl ::Payload for CommitOk {
        fn class_id(&self) -> u16 {
            90
        }
        fn method_id(&self) -> u16 {
            21
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            0
        }
    }
    pub struct Rollback;
    impl Rollback {
        pub fn new() -> Self {
            Rollback
        }
    }
    impl ::Payload for Rollback {
        fn class_id(&self) -> u16 {
            90
        }
        fn method_id(&self) -> u16 {
            30
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            0
        }
    }
    pub struct RollbackOk;
    impl RollbackOk {
        pub fn new() -> Self {
            RollbackOk
        }
    }
    impl ::Payload for RollbackOk {
        fn class_id(&self) -> u16 {
            90
        }
        fn method_id(&self) -> u16 {
            31
        }
        fn write_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
            where W: ::std::io::Write
        {
            ::std::result::Result::Ok(())
        }
        fn len(&self) -> usize {
            0
        }
    }
    pub enum Method {
        Select(Select),
        SelectOk(SelectOk),
        Commit(Commit),
        CommitOk(CommitOk),
        Rollback(Rollback),
        RollbackOk(RollbackOk),
    } // enum Method

} // mod tx


// Class methods
type AccessMethod<'a> = access::Method<'a>;
type BasicMethod<'a> = basic::Method<'a>;
type ChannelMethod<'a> = channel::Method<'a>;
type ConnectionMethod<'a> = connection::Method<'a>;
type DtxMethod<'a> = dtx::Method<'a>;
type ExchangeMethod<'a> = exchange::Method<'a>;
type FileMethod<'a> = file::Method<'a>;
type MessageMethod<'a> = message::Method<'a>;
type QueueMethod<'a> = queue::Method<'a>;
type StreamMethod<'a> = stream::Method<'a>;
type TunnelMethod<'a> = tunnel::Method<'a>;
type TxMethod = tx::Method;

pub enum Method<'a> {
    Access(AccessMethod<'a>),
    Basic(BasicMethod<'a>),
    Channel(ChannelMethod<'a>),
    Connection(ConnectionMethod<'a>),
    Dtx(DtxMethod<'a>),
    Exchange(ExchangeMethod<'a>),
    File(FileMethod<'a>),
    Message(MessageMethod<'a>),
    Queue(QueueMethod<'a>),
    Stream(StreamMethod<'a>),
    Tunnel(TunnelMethod<'a>),
    Tx(TxMethod),
} // enum Method

#[allow(non_camel_case_types)]
pub struct Qpid9_0;
impl ::Spec for Qpid9_0 {}
