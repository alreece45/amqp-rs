// Generated by build.rs script in the amqp0-primitives crate.
// Pre-generated files are used by default. Generation is done with the amqp0-codegen crate.
//
// To regenerate, ignoring the pre-generated files, use: cargo --features="amqp0-build-primitives"
// To format and replace the pre-generated files, use: cargo --features="amqp0-pregen-primitives"
//
// EDITORS BEWARE: Your modifications may be overridden or removed.

// generated by primalgen::codegen::spec_module::class_mod::ClassModuleWriter
#![allow(too_many_arguments)]

impl<'a> ::method::exchange::BindMethod<'a> for ::Rabbitmq9_1 {
    type Payload = Bind<'a>;
} // impl<'a> ::method::exchange::BindMethod<'a> for ::Rabbitmq9_1

// generated by primalgen::codegen::spec-module::class_mod::method_struct
#[derive(Debug)]
pub struct Bind<'a> {
    destination: ::std::borrow::Cow<'a, str>,
    source: ::std::borrow::Cow<'a, str>,
    routing_key: ::std::borrow::Cow<'a, str>,
    no_wait: bool,
    arguments: ::field::TableEntries<'a>,
} // struct Bind<'a>

impl<'a> Bind<'a> {
    pub fn new<D, S, R, A>(destination: D,
                           source: S,
                           routing_key: R,
                           no_wait: bool,
                           arguments: A)
                           -> Self
        where D: Into<::std::borrow::Cow<'a, str>>,
              S: Into<::std::borrow::Cow<'a, str>>,
              R: Into<::std::borrow::Cow<'a, str>>,
              A: Into<::field::TableEntries<'a>>
    {
        Bind {
            destination: destination.into(),
            source: source.into(),
            routing_key: routing_key.into(),
            no_wait: no_wait,
            arguments: arguments.into(),
        } // Bind
    } // fn new()
    impl_properties! {
(destination, destination_mut, set_destination) -> Cow<str>,
(source, source_mut, set_source) -> Cow<str>,
(routing_key, routing_key_mut, set_routing_key) -> Cow<str>,
(no_wait, set_no_wait) -> bool,
(arguments, arguments_mut, set_arguments) -> &::field::TableEntries<'a>,
} // impl_properties
} // impl<'a> Bind<'a>
impl<'a> Default for Bind<'a> {
    fn default() -> Self {
        Bind::new("", "", "", false, ::field::TableEntries::new())
    } // fn default()
} // impl Default for Bind

impl<'a> ::Encodable for Bind<'a> {
    fn encoded_size(&self) -> usize {
        3 + ::Encodable::encoded_size(&self.destination) + ::Encodable::encoded_size(&self.source) +
        ::Encodable::encoded_size(&self.routing_key) +
        ::Encodable::encoded_size(&self.arguments)
    } // encoded_size
    fn write_encoded_to<W>(&self, writer: &mut W) -> ::std::io::Result<()>
        where W: ::std::io::Write
    {
        try!(::Encodable::write_encoded_to(&0u16, writer)); // reserved: reserved_1
        try!(::Encodable::write_encoded_to(&self.destination, writer)); // destination
        try!(::Encodable::write_encoded_to(&self.source, writer)); // source
        try!(::Encodable::write_encoded_to(&self.routing_key, writer)); // routing_key
        try!(::Encodable::write_encoded_to(&{
                                               let mut bits = ::bit_vec::BitVec::from_elem(8,
                                                                                           false);
                                               bits.set(7, self.no_wait);
                                               bits
                                           },
                                           writer));
        try!(::Encodable::write_encoded_to(&self.arguments, writer)); // arguments

        ::std::result::Result::Ok(())
    } // fn write_encoded_to()
} // impl Encodable

#[test]
fn test_bind_encodable_bytes_written_matches_len() {
    let payload: Bind = Default::default();
    let expected_len = ::Encodable::encoded_size(&payload);
    let mut writer = ::std::io::Cursor::new(Vec::with_capacity(expected_len));
    ::Encodable::write_encoded_to(&payload, &mut writer).unwrap();
    let payload = writer.into_inner();

    if payload.len() != expected_len {
        panic!("Expected payload len {}, got {}, {:?}",
               expected_len,
               payload.len(),
               &payload[..]);
    }
}



impl<'a> ::ProtocolMethodPayload for Bind<'a> {
    fn class(&self) -> ::Class {
        ::Class::Exchange
    }
    fn class_id(&self) -> u16 {
        40
    }
    fn class_name(&self) -> &'static str {
        "exchange"
    }
    fn method_id(&self) -> u16 {
        30
    }
    fn method_name(&self) -> &'static str {
        "bind"
    }
} // impl ::ProtocolMethodPayload for Bind<'a>
impl<'a> ::method::exchange::SetBindMethodFields<'a> for Bind<'a> {
    fn set_destination<V>(&mut self, destination: V)
        where V: Into<::std::borrow::Cow<'a, str>>
    {
        self.set_destination(destination.into())
    } // set_destination()
    fn set_source<V>(&mut self, source: V)
        where V: Into<::std::borrow::Cow<'a, str>>
    {
        self.set_source(source.into())
    } // set_source()
    fn set_routing_key<V>(&mut self, routing_key: V)
        where V: Into<::std::borrow::Cow<'a, str>>
    {
        self.set_routing_key(routing_key.into())
    } // set_routing_key()
    fn set_no_wait(&mut self, no_wait: bool) {
        self.set_no_wait(no_wait)
    } // set_no_wait()
    fn set_arguments<V>(&mut self, arguments: V)
        where V: Into<::field::TableEntries<'a>>
    {
        self.set_arguments(arguments.into())
    } // set_arguments()
} // impl<'a> ::method::exchange::SetBindMethodFields<'a> for Bind<'a>
impl<'a> From<Bind<'a>> for ClassMethod<'a> {
    fn from(from: Bind<'a>) -> Self {
        ClassMethod::Bind(from)
    } // fn from()
} // impl From<Bind<'a>> for ClassMethod

impl<'a> From<Bind<'a>> for super::SpecMethod<'a> {
    fn from(from: Bind<'a>) -> Self {
        super::SpecMethod::Exchange(from.into())
    } // fn default()
} // impl From<Bind<'a>> for ::super::SpecMethod
impl ::method::exchange::BindOkMethod for ::Rabbitmq9_1 {
    type Payload = BindOk;
} // impl ::method::exchange::BindOkMethod for ::Rabbitmq9_1

// generated by primalgen::codegen::spec-module::class_mod::method_struct
#[derive(Debug)]
pub struct BindOk;

impl BindOk {
    pub fn new() -> Self {
        BindOk
    } // fn new()
} // impl BindOk
impl Default for BindOk {
    fn default() -> Self {
        BindOk::new()
    } // fn default()
} // impl Default for BindOk

impl ::Encodable for BindOk {
    fn encoded_size(&self) -> usize {
        0
    } // encoded_size
    fn write_encoded_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
        where W: ::std::io::Write
    {
        ::std::result::Result::Ok(())
    }
} // impl Encodable

#[test]
fn test_bind_ok_encodable_bytes_written_matches_len() {
    let payload: BindOk = Default::default();
    let expected_len = ::Encodable::encoded_size(&payload);
    let mut writer = ::std::io::Cursor::new(Vec::with_capacity(expected_len));
    ::Encodable::write_encoded_to(&payload, &mut writer).unwrap();
    let payload = writer.into_inner();

    if payload.len() != expected_len {
        panic!("Expected payload len {}, got {}, {:?}",
               expected_len,
               payload.len(),
               &payload[..]);
    }
}



impl ::ProtocolMethodPayload for BindOk {
    fn class(&self) -> ::Class {
        ::Class::Exchange
    }
    fn class_id(&self) -> u16 {
        40
    }
    fn class_name(&self) -> &'static str {
        "exchange"
    }
    fn method_id(&self) -> u16 {
        31
    }
    fn method_name(&self) -> &'static str {
        "bind-ok"
    }
} // impl ::ProtocolMethodPayload for BindOk
impl<'a> From<BindOk> for ClassMethod<'a> {
    fn from(from: BindOk) -> Self {
        ClassMethod::BindOk(from)
    } // fn from()
} // impl From<BindOk> for ClassMethod

impl From<BindOk> for super::SpecMethod<'static> {
    fn from(from: BindOk) -> Self {
        super::SpecMethod::Exchange(from.into())
    } // fn default()
} // impl From<BindOk> for ::super::SpecMethod
impl<'a> ::method::exchange::DeclareMethod<'a> for ::Rabbitmq9_1 {
    type Payload = Declare<'a>;
} // impl<'a> ::method::exchange::DeclareMethod<'a> for ::Rabbitmq9_1

// generated by primalgen::codegen::spec-module::class_mod::method_struct
#[derive(Debug)]
pub struct Declare<'a> {
    exchange: ::std::borrow::Cow<'a, str>,
    ty: ::std::borrow::Cow<'a, str>,
    passive: bool,
    durable: bool,
    auto_delete: bool,
    internal: bool,
    no_wait: bool,
    arguments: ::field::TableEntries<'a>,
} // struct Declare<'a>

impl<'a> Declare<'a> {
    pub fn new<E, T, A>(exchange: E,
                        ty: T,
                        passive: bool,
                        durable: bool,
                        auto_delete: bool,
                        internal: bool,
                        no_wait: bool,
                        arguments: A)
                        -> Self
        where E: Into<::std::borrow::Cow<'a, str>>,
              T: Into<::std::borrow::Cow<'a, str>>,
              A: Into<::field::TableEntries<'a>>
    {
        Declare {
            exchange: exchange.into(),
            ty: ty.into(),
            passive: passive,
            durable: durable,
            auto_delete: auto_delete,
            internal: internal,
            no_wait: no_wait,
            arguments: arguments.into(),
        } // Declare
    } // fn new()
    impl_properties! {
(exchange, exchange_mut, set_exchange) -> Cow<str>,
(ty, ty_mut, set_ty) -> Cow<str>,
(passive, set_passive) -> bool,
(durable, set_durable) -> bool,
(auto_delete, set_auto_delete) -> bool,
(internal, set_internal) -> bool,
(no_wait, set_no_wait) -> bool,
(arguments, arguments_mut, set_arguments) -> &::field::TableEntries<'a>,
} // impl_properties
} // impl<'a> Declare<'a>
impl<'a> Default for Declare<'a> {
    fn default() -> Self {
        Declare::new("",
                     "",
                     false,
                     false,
                     false,
                     false,
                     false,
                     ::field::TableEntries::new())
    } // fn default()
} // impl Default for Declare

impl<'a> ::Encodable for Declare<'a> {
    fn encoded_size(&self) -> usize {
        3 + ::Encodable::encoded_size(&self.exchange) + ::Encodable::encoded_size(&self.ty) +
        ::Encodable::encoded_size(&self.arguments)
    } // encoded_size
    fn write_encoded_to<W>(&self, writer: &mut W) -> ::std::io::Result<()>
        where W: ::std::io::Write
    {
        try!(::Encodable::write_encoded_to(&0u16, writer)); // reserved: reserved_1
        try!(::Encodable::write_encoded_to(&self.exchange, writer)); // exchange
        try!(::Encodable::write_encoded_to(&self.ty, writer)); // ty
        try!(::Encodable::write_encoded_to(&{
                                               let mut bits = ::bit_vec::BitVec::from_elem(8,
                                                                                           false);
                                               bits.set(7, self.passive);
                                               bits.set(6, self.durable);
                                               bits.set(5, self.auto_delete);
                                               bits.set(4, self.internal);
                                               bits.set(3, self.no_wait);
                                               bits
                                           },
                                           writer));
        try!(::Encodable::write_encoded_to(&self.arguments, writer)); // arguments

        ::std::result::Result::Ok(())
    } // fn write_encoded_to()
} // impl Encodable

#[test]
fn test_declare_encodable_bytes_written_matches_len() {
    let payload: Declare = Default::default();
    let expected_len = ::Encodable::encoded_size(&payload);
    let mut writer = ::std::io::Cursor::new(Vec::with_capacity(expected_len));
    ::Encodable::write_encoded_to(&payload, &mut writer).unwrap();
    let payload = writer.into_inner();

    if payload.len() != expected_len {
        panic!("Expected payload len {}, got {}, {:?}",
               expected_len,
               payload.len(),
               &payload[..]);
    }
}



impl<'a> ::ProtocolMethodPayload for Declare<'a> {
    fn class(&self) -> ::Class {
        ::Class::Exchange
    }
    fn class_id(&self) -> u16 {
        40
    }
    fn class_name(&self) -> &'static str {
        "exchange"
    }
    fn method_id(&self) -> u16 {
        10
    }
    fn method_name(&self) -> &'static str {
        "declare"
    }
} // impl ::ProtocolMethodPayload for Declare<'a>
impl<'a> ::method::exchange::SetDeclareMethodFields<'a> for Declare<'a> {
    fn set_exchange<V>(&mut self, exchange: V)
        where V: Into<::std::borrow::Cow<'a, str>>
    {
        self.set_exchange(exchange.into())
    } // set_exchange()
    fn set_ty<V>(&mut self, ty: V)
        where V: Into<::std::borrow::Cow<'a, str>>
    {
        self.set_ty(ty.into())
    } // set_ty()
    fn set_passive(&mut self, passive: bool) {
        self.set_passive(passive)
    } // set_passive()
    fn set_durable(&mut self, durable: bool) {
        self.set_durable(durable)
    } // set_durable()
    fn set_auto_delete(&mut self, auto_delete: bool) {
        self.set_auto_delete(auto_delete)
    } // set_auto_delete()
    fn set_internal(&mut self, internal: bool) {
        self.set_internal(internal)
    } // set_internal()
    fn set_no_wait(&mut self, no_wait: bool) {
        self.set_no_wait(no_wait)
    } // set_no_wait()
    fn set_arguments<V>(&mut self, arguments: V)
        where V: Into<::field::TableEntries<'a>>
    {
        self.set_arguments(arguments.into())
    } // set_arguments()
} // impl<'a> ::method::exchange::SetDeclareMethodFields<'a> for Declare<'a>
impl<'a> From<Declare<'a>> for ClassMethod<'a> {
    fn from(from: Declare<'a>) -> Self {
        ClassMethod::Declare(from)
    } // fn from()
} // impl From<Declare<'a>> for ClassMethod

impl<'a> From<Declare<'a>> for super::SpecMethod<'a> {
    fn from(from: Declare<'a>) -> Self {
        super::SpecMethod::Exchange(from.into())
    } // fn default()
} // impl From<Declare<'a>> for ::super::SpecMethod
impl ::method::exchange::DeclareOkMethod for ::Rabbitmq9_1 {
    type Payload = DeclareOk;
} // impl ::method::exchange::DeclareOkMethod for ::Rabbitmq9_1

// generated by primalgen::codegen::spec-module::class_mod::method_struct
#[derive(Debug)]
pub struct DeclareOk;

impl DeclareOk {
    pub fn new() -> Self {
        DeclareOk
    } // fn new()
} // impl DeclareOk
impl Default for DeclareOk {
    fn default() -> Self {
        DeclareOk::new()
    } // fn default()
} // impl Default for DeclareOk

impl ::Encodable for DeclareOk {
    fn encoded_size(&self) -> usize {
        0
    } // encoded_size
    fn write_encoded_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
        where W: ::std::io::Write
    {
        ::std::result::Result::Ok(())
    }
} // impl Encodable

#[test]
fn test_declare_ok_encodable_bytes_written_matches_len() {
    let payload: DeclareOk = Default::default();
    let expected_len = ::Encodable::encoded_size(&payload);
    let mut writer = ::std::io::Cursor::new(Vec::with_capacity(expected_len));
    ::Encodable::write_encoded_to(&payload, &mut writer).unwrap();
    let payload = writer.into_inner();

    if payload.len() != expected_len {
        panic!("Expected payload len {}, got {}, {:?}",
               expected_len,
               payload.len(),
               &payload[..]);
    }
}



impl ::ProtocolMethodPayload for DeclareOk {
    fn class(&self) -> ::Class {
        ::Class::Exchange
    }
    fn class_id(&self) -> u16 {
        40
    }
    fn class_name(&self) -> &'static str {
        "exchange"
    }
    fn method_id(&self) -> u16 {
        11
    }
    fn method_name(&self) -> &'static str {
        "declare-ok"
    }
} // impl ::ProtocolMethodPayload for DeclareOk
impl<'a> From<DeclareOk> for ClassMethod<'a> {
    fn from(from: DeclareOk) -> Self {
        ClassMethod::DeclareOk(from)
    } // fn from()
} // impl From<DeclareOk> for ClassMethod

impl From<DeclareOk> for super::SpecMethod<'static> {
    fn from(from: DeclareOk) -> Self {
        super::SpecMethod::Exchange(from.into())
    } // fn default()
} // impl From<DeclareOk> for ::super::SpecMethod
impl<'a> ::method::exchange::DeleteMethod<'a> for ::Rabbitmq9_1 {
    type Payload = Delete<'a>;
} // impl<'a> ::method::exchange::DeleteMethod<'a> for ::Rabbitmq9_1

// generated by primalgen::codegen::spec-module::class_mod::method_struct
#[derive(Debug)]
pub struct Delete<'a> {
    exchange: ::std::borrow::Cow<'a, str>,
    if_unused: bool,
    no_wait: bool,
} // struct Delete<'a>

impl<'a> Delete<'a> {
    pub fn new<E>(exchange: E, if_unused: bool, no_wait: bool) -> Self
        where E: Into<::std::borrow::Cow<'a, str>>
    {
        Delete {
            exchange: exchange.into(),
            if_unused: if_unused,
            no_wait: no_wait,
        } // Delete
    } // fn new()
    impl_properties! {
(exchange, exchange_mut, set_exchange) -> Cow<str>,
(if_unused, set_if_unused) -> bool,
(no_wait, set_no_wait) -> bool,
} // impl_properties
} // impl<'a> Delete<'a>
impl<'a> Default for Delete<'a> {
    fn default() -> Self {
        Delete::new("", false, false)
    } // fn default()
} // impl Default for Delete

impl<'a> ::Encodable for Delete<'a> {
    fn encoded_size(&self) -> usize {
        3 + ::Encodable::encoded_size(&self.exchange)
    } // encoded_size
    fn write_encoded_to<W>(&self, writer: &mut W) -> ::std::io::Result<()>
        where W: ::std::io::Write
    {
        try!(::Encodable::write_encoded_to(&0u16, writer)); // reserved: reserved_1
        try!(::Encodable::write_encoded_to(&self.exchange, writer)); // exchange
        try!(::Encodable::write_encoded_to(&{
                                               let mut bits = ::bit_vec::BitVec::from_elem(8,
                                                                                           false);
                                               bits.set(7, self.if_unused);
                                               bits.set(6, self.no_wait);
                                               bits
                                           },
                                           writer));

        ::std::result::Result::Ok(())
    } // fn write_encoded_to()
} // impl Encodable

#[test]
fn test_delete_encodable_bytes_written_matches_len() {
    let payload: Delete = Default::default();
    let expected_len = ::Encodable::encoded_size(&payload);
    let mut writer = ::std::io::Cursor::new(Vec::with_capacity(expected_len));
    ::Encodable::write_encoded_to(&payload, &mut writer).unwrap();
    let payload = writer.into_inner();

    if payload.len() != expected_len {
        panic!("Expected payload len {}, got {}, {:?}",
               expected_len,
               payload.len(),
               &payload[..]);
    }
}



impl<'a> ::ProtocolMethodPayload for Delete<'a> {
    fn class(&self) -> ::Class {
        ::Class::Exchange
    }
    fn class_id(&self) -> u16 {
        40
    }
    fn class_name(&self) -> &'static str {
        "exchange"
    }
    fn method_id(&self) -> u16 {
        20
    }
    fn method_name(&self) -> &'static str {
        "delete"
    }
} // impl ::ProtocolMethodPayload for Delete<'a>
impl<'a> ::method::exchange::SetDeleteMethodFields<'a> for Delete<'a> {
    fn set_exchange<V>(&mut self, exchange: V)
        where V: Into<::std::borrow::Cow<'a, str>>
    {
        self.set_exchange(exchange.into())
    } // set_exchange()
    fn set_if_unused(&mut self, if_unused: bool) {
        self.set_if_unused(if_unused)
    } // set_if_unused()
    fn set_no_wait(&mut self, no_wait: bool) {
        self.set_no_wait(no_wait)
    } // set_no_wait()
} // impl<'a> ::method::exchange::SetDeleteMethodFields<'a> for Delete<'a>
impl<'a> From<Delete<'a>> for ClassMethod<'a> {
    fn from(from: Delete<'a>) -> Self {
        ClassMethod::Delete(from)
    } // fn from()
} // impl From<Delete<'a>> for ClassMethod

impl<'a> From<Delete<'a>> for super::SpecMethod<'a> {
    fn from(from: Delete<'a>) -> Self {
        super::SpecMethod::Exchange(from.into())
    } // fn default()
} // impl From<Delete<'a>> for ::super::SpecMethod
impl ::method::exchange::DeleteOkMethod for ::Rabbitmq9_1 {
    type Payload = DeleteOk;
} // impl ::method::exchange::DeleteOkMethod for ::Rabbitmq9_1

// generated by primalgen::codegen::spec-module::class_mod::method_struct
#[derive(Debug)]
pub struct DeleteOk;

impl DeleteOk {
    pub fn new() -> Self {
        DeleteOk
    } // fn new()
} // impl DeleteOk
impl Default for DeleteOk {
    fn default() -> Self {
        DeleteOk::new()
    } // fn default()
} // impl Default for DeleteOk

impl ::Encodable for DeleteOk {
    fn encoded_size(&self) -> usize {
        0
    } // encoded_size
    fn write_encoded_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
        where W: ::std::io::Write
    {
        ::std::result::Result::Ok(())
    }
} // impl Encodable

#[test]
fn test_delete_ok_encodable_bytes_written_matches_len() {
    let payload: DeleteOk = Default::default();
    let expected_len = ::Encodable::encoded_size(&payload);
    let mut writer = ::std::io::Cursor::new(Vec::with_capacity(expected_len));
    ::Encodable::write_encoded_to(&payload, &mut writer).unwrap();
    let payload = writer.into_inner();

    if payload.len() != expected_len {
        panic!("Expected payload len {}, got {}, {:?}",
               expected_len,
               payload.len(),
               &payload[..]);
    }
}



impl ::ProtocolMethodPayload for DeleteOk {
    fn class(&self) -> ::Class {
        ::Class::Exchange
    }
    fn class_id(&self) -> u16 {
        40
    }
    fn class_name(&self) -> &'static str {
        "exchange"
    }
    fn method_id(&self) -> u16 {
        21
    }
    fn method_name(&self) -> &'static str {
        "delete-ok"
    }
} // impl ::ProtocolMethodPayload for DeleteOk
impl<'a> From<DeleteOk> for ClassMethod<'a> {
    fn from(from: DeleteOk) -> Self {
        ClassMethod::DeleteOk(from)
    } // fn from()
} // impl From<DeleteOk> for ClassMethod

impl From<DeleteOk> for super::SpecMethod<'static> {
    fn from(from: DeleteOk) -> Self {
        super::SpecMethod::Exchange(from.into())
    } // fn default()
} // impl From<DeleteOk> for ::super::SpecMethod
impl<'a> ::method::exchange::UnbindMethod<'a> for ::Rabbitmq9_1 {
    type Payload = Unbind<'a>;
} // impl<'a> ::method::exchange::UnbindMethod<'a> for ::Rabbitmq9_1

// generated by primalgen::codegen::spec-module::class_mod::method_struct
#[derive(Debug)]
pub struct Unbind<'a> {
    destination: ::std::borrow::Cow<'a, str>,
    source: ::std::borrow::Cow<'a, str>,
    routing_key: ::std::borrow::Cow<'a, str>,
    no_wait: bool,
    arguments: ::field::TableEntries<'a>,
} // struct Unbind<'a>

impl<'a> Unbind<'a> {
    pub fn new<D, S, R, A>(destination: D,
                           source: S,
                           routing_key: R,
                           no_wait: bool,
                           arguments: A)
                           -> Self
        where D: Into<::std::borrow::Cow<'a, str>>,
              S: Into<::std::borrow::Cow<'a, str>>,
              R: Into<::std::borrow::Cow<'a, str>>,
              A: Into<::field::TableEntries<'a>>
    {
        Unbind {
            destination: destination.into(),
            source: source.into(),
            routing_key: routing_key.into(),
            no_wait: no_wait,
            arguments: arguments.into(),
        } // Unbind
    } // fn new()
    impl_properties! {
(destination, destination_mut, set_destination) -> Cow<str>,
(source, source_mut, set_source) -> Cow<str>,
(routing_key, routing_key_mut, set_routing_key) -> Cow<str>,
(no_wait, set_no_wait) -> bool,
(arguments, arguments_mut, set_arguments) -> &::field::TableEntries<'a>,
} // impl_properties
} // impl<'a> Unbind<'a>
impl<'a> Default for Unbind<'a> {
    fn default() -> Self {
        Unbind::new("", "", "", false, ::field::TableEntries::new())
    } // fn default()
} // impl Default for Unbind

impl<'a> ::Encodable for Unbind<'a> {
    fn encoded_size(&self) -> usize {
        3 + ::Encodable::encoded_size(&self.destination) + ::Encodable::encoded_size(&self.source) +
        ::Encodable::encoded_size(&self.routing_key) +
        ::Encodable::encoded_size(&self.arguments)
    } // encoded_size
    fn write_encoded_to<W>(&self, writer: &mut W) -> ::std::io::Result<()>
        where W: ::std::io::Write
    {
        try!(::Encodable::write_encoded_to(&0u16, writer)); // reserved: reserved_1
        try!(::Encodable::write_encoded_to(&self.destination, writer)); // destination
        try!(::Encodable::write_encoded_to(&self.source, writer)); // source
        try!(::Encodable::write_encoded_to(&self.routing_key, writer)); // routing_key
        try!(::Encodable::write_encoded_to(&{
                                               let mut bits = ::bit_vec::BitVec::from_elem(8,
                                                                                           false);
                                               bits.set(7, self.no_wait);
                                               bits
                                           },
                                           writer));
        try!(::Encodable::write_encoded_to(&self.arguments, writer)); // arguments

        ::std::result::Result::Ok(())
    } // fn write_encoded_to()
} // impl Encodable

#[test]
fn test_unbind_encodable_bytes_written_matches_len() {
    let payload: Unbind = Default::default();
    let expected_len = ::Encodable::encoded_size(&payload);
    let mut writer = ::std::io::Cursor::new(Vec::with_capacity(expected_len));
    ::Encodable::write_encoded_to(&payload, &mut writer).unwrap();
    let payload = writer.into_inner();

    if payload.len() != expected_len {
        panic!("Expected payload len {}, got {}, {:?}",
               expected_len,
               payload.len(),
               &payload[..]);
    }
}



impl<'a> ::ProtocolMethodPayload for Unbind<'a> {
    fn class(&self) -> ::Class {
        ::Class::Exchange
    }
    fn class_id(&self) -> u16 {
        40
    }
    fn class_name(&self) -> &'static str {
        "exchange"
    }
    fn method_id(&self) -> u16 {
        40
    }
    fn method_name(&self) -> &'static str {
        "unbind"
    }
} // impl ::ProtocolMethodPayload for Unbind<'a>
impl<'a> ::method::exchange::SetUnbindMethodFields<'a> for Unbind<'a> {
    fn set_destination<V>(&mut self, destination: V)
        where V: Into<::std::borrow::Cow<'a, str>>
    {
        self.set_destination(destination.into())
    } // set_destination()
    fn set_source<V>(&mut self, source: V)
        where V: Into<::std::borrow::Cow<'a, str>>
    {
        self.set_source(source.into())
    } // set_source()
    fn set_routing_key<V>(&mut self, routing_key: V)
        where V: Into<::std::borrow::Cow<'a, str>>
    {
        self.set_routing_key(routing_key.into())
    } // set_routing_key()
    fn set_no_wait(&mut self, no_wait: bool) {
        self.set_no_wait(no_wait)
    } // set_no_wait()
    fn set_arguments<V>(&mut self, arguments: V)
        where V: Into<::field::TableEntries<'a>>
    {
        self.set_arguments(arguments.into())
    } // set_arguments()
} // impl<'a> ::method::exchange::SetUnbindMethodFields<'a> for Unbind<'a>
impl<'a> From<Unbind<'a>> for ClassMethod<'a> {
    fn from(from: Unbind<'a>) -> Self {
        ClassMethod::Unbind(from)
    } // fn from()
} // impl From<Unbind<'a>> for ClassMethod

impl<'a> From<Unbind<'a>> for super::SpecMethod<'a> {
    fn from(from: Unbind<'a>) -> Self {
        super::SpecMethod::Exchange(from.into())
    } // fn default()
} // impl From<Unbind<'a>> for ::super::SpecMethod
impl ::method::exchange::UnbindOkMethod for ::Rabbitmq9_1 {
    type Payload = UnbindOk;
} // impl ::method::exchange::UnbindOkMethod for ::Rabbitmq9_1

// generated by primalgen::codegen::spec-module::class_mod::method_struct
#[derive(Debug)]
pub struct UnbindOk;

impl UnbindOk {
    pub fn new() -> Self {
        UnbindOk
    } // fn new()
} // impl UnbindOk
impl Default for UnbindOk {
    fn default() -> Self {
        UnbindOk::new()
    } // fn default()
} // impl Default for UnbindOk

impl ::Encodable for UnbindOk {
    fn encoded_size(&self) -> usize {
        0
    } // encoded_size
    fn write_encoded_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
        where W: ::std::io::Write
    {
        ::std::result::Result::Ok(())
    }
} // impl Encodable

#[test]
fn test_unbind_ok_encodable_bytes_written_matches_len() {
    let payload: UnbindOk = Default::default();
    let expected_len = ::Encodable::encoded_size(&payload);
    let mut writer = ::std::io::Cursor::new(Vec::with_capacity(expected_len));
    ::Encodable::write_encoded_to(&payload, &mut writer).unwrap();
    let payload = writer.into_inner();

    if payload.len() != expected_len {
        panic!("Expected payload len {}, got {}, {:?}",
               expected_len,
               payload.len(),
               &payload[..]);
    }
}



impl ::ProtocolMethodPayload for UnbindOk {
    fn class(&self) -> ::Class {
        ::Class::Exchange
    }
    fn class_id(&self) -> u16 {
        40
    }
    fn class_name(&self) -> &'static str {
        "exchange"
    }
    fn method_id(&self) -> u16 {
        51
    }
    fn method_name(&self) -> &'static str {
        "unbind-ok"
    }
} // impl ::ProtocolMethodPayload for UnbindOk
impl<'a> From<UnbindOk> for ClassMethod<'a> {
    fn from(from: UnbindOk) -> Self {
        ClassMethod::UnbindOk(from)
    } // fn from()
} // impl From<UnbindOk> for ClassMethod

impl From<UnbindOk> for super::SpecMethod<'static> {
    fn from(from: UnbindOk) -> Self {
        super::SpecMethod::Exchange(from.into())
    } // fn default()
} // impl From<UnbindOk> for ::super::SpecMethod

#[derive(Debug)]
pub enum ClassMethod<'a> {
    Bind(Bind<'a>),
    BindOk(BindOk),
    Declare(Declare<'a>),
    DeclareOk(DeclareOk),
    Delete(Delete<'a>),
    DeleteOk(DeleteOk),
    Unbind(Unbind<'a>),
    UnbindOk(UnbindOk),
} // enum ClassMethod


impl<'a> ::Encodable for ClassMethod<'a> {
    fn encoded_size(&self) -> usize {
        match *self {
            ClassMethod::Bind(ref method) => ::Encodable::encoded_size(method),
            ClassMethod::BindOk(ref method) => ::Encodable::encoded_size(method),
            ClassMethod::Declare(ref method) => ::Encodable::encoded_size(method),
            ClassMethod::DeclareOk(ref method) => ::Encodable::encoded_size(method),
            ClassMethod::Delete(ref method) => ::Encodable::encoded_size(method),
            ClassMethod::DeleteOk(ref method) => ::Encodable::encoded_size(method),
            ClassMethod::Unbind(ref method) => ::Encodable::encoded_size(method),
            ClassMethod::UnbindOk(ref method) => ::Encodable::encoded_size(method),

        } // match *self

    } // fn encoded_size
    fn write_encoded_to<W>(&self, _: &mut W) -> ::std::io::Result<()>
        where W: ::std::io::Write
    {
        unimplemented!()
    } // fn write_encoded_to()
} // impl ::Encodable for ClassMethod<'a>

impl<'a> ::ProtocolMethodPayload for ClassMethod<'a> {
    fn class(&self) -> ::Class {
        match *self {
            ClassMethod::Bind(ref method) => ::ProtocolMethodPayload::class(method),
            ClassMethod::BindOk(ref method) => ::ProtocolMethodPayload::class(method),
            ClassMethod::Declare(ref method) => ::ProtocolMethodPayload::class(method),
            ClassMethod::DeclareOk(ref method) => ::ProtocolMethodPayload::class(method),
            ClassMethod::Delete(ref method) => ::ProtocolMethodPayload::class(method),
            ClassMethod::DeleteOk(ref method) => ::ProtocolMethodPayload::class(method),
            ClassMethod::Unbind(ref method) => ::ProtocolMethodPayload::class(method),
            ClassMethod::UnbindOk(ref method) => ::ProtocolMethodPayload::class(method),

        } // match *self

    } // fn class

    fn class_id(&self) -> u16 {
        match *self {
            ClassMethod::Bind(ref method) => ::ProtocolMethodPayload::class_id(method),
            ClassMethod::BindOk(ref method) => ::ProtocolMethodPayload::class_id(method),
            ClassMethod::Declare(ref method) => ::ProtocolMethodPayload::class_id(method),
            ClassMethod::DeclareOk(ref method) => ::ProtocolMethodPayload::class_id(method),
            ClassMethod::Delete(ref method) => ::ProtocolMethodPayload::class_id(method),
            ClassMethod::DeleteOk(ref method) => ::ProtocolMethodPayload::class_id(method),
            ClassMethod::Unbind(ref method) => ::ProtocolMethodPayload::class_id(method),
            ClassMethod::UnbindOk(ref method) => ::ProtocolMethodPayload::class_id(method),

        } // match *self

    } // fn class_id

    fn class_name(&self) -> &'static str {
        match *self {
            ClassMethod::Bind(ref method) => ::ProtocolMethodPayload::class_name(method),
            ClassMethod::BindOk(ref method) => ::ProtocolMethodPayload::class_name(method),
            ClassMethod::Declare(ref method) => ::ProtocolMethodPayload::class_name(method),
            ClassMethod::DeclareOk(ref method) => ::ProtocolMethodPayload::class_name(method),
            ClassMethod::Delete(ref method) => ::ProtocolMethodPayload::class_name(method),
            ClassMethod::DeleteOk(ref method) => ::ProtocolMethodPayload::class_name(method),
            ClassMethod::Unbind(ref method) => ::ProtocolMethodPayload::class_name(method),
            ClassMethod::UnbindOk(ref method) => ::ProtocolMethodPayload::class_name(method),

        } // match *self

    } // fn class_name

    fn method_id(&self) -> u16 {
        match *self {
            ClassMethod::Bind(ref method) => ::ProtocolMethodPayload::method_id(method),
            ClassMethod::BindOk(ref method) => ::ProtocolMethodPayload::method_id(method),
            ClassMethod::Declare(ref method) => ::ProtocolMethodPayload::method_id(method),
            ClassMethod::DeclareOk(ref method) => ::ProtocolMethodPayload::method_id(method),
            ClassMethod::Delete(ref method) => ::ProtocolMethodPayload::method_id(method),
            ClassMethod::DeleteOk(ref method) => ::ProtocolMethodPayload::method_id(method),
            ClassMethod::Unbind(ref method) => ::ProtocolMethodPayload::method_id(method),
            ClassMethod::UnbindOk(ref method) => ::ProtocolMethodPayload::method_id(method),

        } // match *self

    } // fn method_id

    fn method_name(&self) -> &'static str {
        match *self {
            ClassMethod::Bind(ref method) => ::ProtocolMethodPayload::method_name(method),
            ClassMethod::BindOk(ref method) => ::ProtocolMethodPayload::method_name(method),
            ClassMethod::Declare(ref method) => ::ProtocolMethodPayload::method_name(method),
            ClassMethod::DeclareOk(ref method) => ::ProtocolMethodPayload::method_name(method),
            ClassMethod::Delete(ref method) => ::ProtocolMethodPayload::method_name(method),
            ClassMethod::DeleteOk(ref method) => ::ProtocolMethodPayload::method_name(method),
            ClassMethod::Unbind(ref method) => ::ProtocolMethodPayload::method_name(method),
            ClassMethod::UnbindOk(ref method) => ::ProtocolMethodPayload::method_name(method),

        } // match *self

    } // fn method_name
} // impl ProtocolMethodPayload for ClassMethod
