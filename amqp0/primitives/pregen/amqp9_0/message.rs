// Generated by build.rs script in amqp0-primitives
// Pre-generated files are used by default. Generation is done with the amqp0-codegen crate
//
// To regenerate, and not use pre-generated files, use: cargo --features="amqp0-build-primitives"
// To format and replace the pre-generated files, use: cargo --features="amqp0-pregen-primitives"
//
// EDITORS BEWARE: Your modifications may be overridden

// generated by primalgen::codegen::spec_module::class_mod::ClassModuleWriter
#![allow(too_many_arguments)]

impl<'a> ::method::message::AppendMethod<'a> for ::Amqp9_0 {
    type Payload = Append<'a>;
} // impl<'a> ::method::message::AppendMethod<'a> for ::Amqp9_0

// generated by primalgen::codegen::spec-module::class_mod::method_struct
#[derive(Debug)]
pub struct Append<'a> {
    reference: ::std::borrow::Cow<'a, [u8]>,
    bytes: ::std::borrow::Cow<'a, [u8]>,
} // struct Append<'a>

impl<'a> Append<'a> {
    pub fn new<R, B>(reference: R, bytes: B) -> Self
        where R: Into<::std::borrow::Cow<'a, [u8]>>,
              B: Into<::std::borrow::Cow<'a, [u8]>>
    {
        Append {
            reference: reference.into(),
            bytes: bytes.into(),
        } // Append
    } // fn new()
    impl_properties! {
(reference, reference_mut, set_reference) -> Cow<[u8]>,
(bytes, bytes_mut, set_bytes) -> Cow<[u8]>,
} // impl_properties
} // impl<'a> Append<'a>
impl<'a> Default for Append<'a> {
    fn default() -> Self {
        Append::new(&[][..], &[][..])
    } // fn default()
} // impl Default for Append

impl<'a> ::Encodable for Append<'a> {
    fn encoded_size(&self) -> usize {
        [4, ::Encodable::encoded_size(&self.reference), ::Encodable::encoded_size(&self.bytes)]
            .iter()
            .sum()
    } // fn encoded_size()
} // impl Encodable

impl<'a> ::ProtocolMethodPayload for Append<'a> {
    fn class_id(&self) -> u16 {
        120
    } // fn class_id()
    fn method_id(&self) -> u16 {
        80
    } // fn method_id()
} // impl ::Payload for Append
impl<'a> ::method::message::SetAppendMethodFields<'a> for Append<'a> {
    fn set_reference<V>(&mut self, reference: V)
        where V: Into<::std::borrow::Cow<'a, [u8]>>
    {
        self.set_reference(reference.into())
    } // set_reference()
    fn set_bytes<V>(&mut self, bytes: V)
        where V: Into<::std::borrow::Cow<'a, [u8]>>
    {
        self.set_bytes(bytes.into())
    } // set_bytes()
} // impl<'a> ::method::message::SetAppendMethodFields<'a> for Append<'a>
impl<'a> ::method::message::CancelMethod<'a> for ::Amqp9_0 {
    type Payload = Cancel<'a>;
} // impl<'a> ::method::message::CancelMethod<'a> for ::Amqp9_0

// generated by primalgen::codegen::spec-module::class_mod::method_struct
#[derive(Debug)]
pub struct Cancel<'a> {
    destination: ::std::borrow::Cow<'a, str>,
} // struct Cancel<'a>

impl<'a> Cancel<'a> {
    pub fn new<D>(destination: D) -> Self
        where D: Into<::std::borrow::Cow<'a, str>>
    {
        Cancel { destination: destination.into() } // Cancel
    } // fn new()
    impl_properties! {
(destination, destination_mut, set_destination) -> Cow<str>,
} // impl_properties
} // impl<'a> Cancel<'a>
impl<'a> Default for Cancel<'a> {
    fn default() -> Self {
        Cancel::new("")
    } // fn default()
} // impl Default for Cancel

impl<'a> ::Encodable for Cancel<'a> {
    fn encoded_size(&self) -> usize {
        [1, ::Encodable::encoded_size(&self.destination)]
            .iter()
            .sum()
    } // fn encoded_size()
} // impl Encodable

impl<'a> ::ProtocolMethodPayload for Cancel<'a> {
    fn class_id(&self) -> u16 {
        120
    } // fn class_id()
    fn method_id(&self) -> u16 {
        30
    } // fn method_id()
} // impl ::Payload for Cancel
impl<'a> ::method::message::SetCancelMethodFields<'a> for Cancel<'a> {
    fn set_destination<V>(&mut self, destination: V)
        where V: Into<::std::borrow::Cow<'a, str>>
    {
        self.set_destination(destination.into())
    } // set_destination()
} // impl<'a> ::method::message::SetCancelMethodFields<'a> for Cancel<'a>
impl<'a> ::method::message::CheckpointMethod<'a> for ::Amqp9_0 {
    type Payload = Checkpoint<'a>;
} // impl<'a> ::method::message::CheckpointMethod<'a> for ::Amqp9_0

// generated by primalgen::codegen::spec-module::class_mod::method_struct
#[derive(Debug)]
pub struct Checkpoint<'a> {
    reference: ::std::borrow::Cow<'a, [u8]>,
    identifier: ::std::borrow::Cow<'a, str>,
} // struct Checkpoint<'a>

impl<'a> Checkpoint<'a> {
    pub fn new<R, I>(reference: R, identifier: I) -> Self
        where R: Into<::std::borrow::Cow<'a, [u8]>>,
              I: Into<::std::borrow::Cow<'a, str>>
    {
        Checkpoint {
            reference: reference.into(),
            identifier: identifier.into(),
        } // Checkpoint
    } // fn new()
    impl_properties! {
(reference, reference_mut, set_reference) -> Cow<[u8]>,
(identifier, identifier_mut, set_identifier) -> Cow<str>,
} // impl_properties
} // impl<'a> Checkpoint<'a>
impl<'a> Default for Checkpoint<'a> {
    fn default() -> Self {
        Checkpoint::new(&[][..], "")
    } // fn default()
} // impl Default for Checkpoint

impl<'a> ::Encodable for Checkpoint<'a> {
    fn encoded_size(&self) -> usize {
        [3, ::Encodable::encoded_size(&self.reference), ::Encodable::encoded_size(&self.identifier)]
            .iter()
            .sum()
    } // fn encoded_size()
} // impl Encodable

impl<'a> ::ProtocolMethodPayload for Checkpoint<'a> {
    fn class_id(&self) -> u16 {
        120
    } // fn class_id()
    fn method_id(&self) -> u16 {
        90
    } // fn method_id()
} // impl ::Payload for Checkpoint
impl<'a> ::method::message::SetCheckpointMethodFields<'a> for Checkpoint<'a> {
    fn set_reference<V>(&mut self, reference: V)
        where V: Into<::std::borrow::Cow<'a, [u8]>>
    {
        self.set_reference(reference.into())
    } // set_reference()
    fn set_identifier<V>(&mut self, identifier: V)
        where V: Into<::std::borrow::Cow<'a, str>>
    {
        self.set_identifier(identifier.into())
    } // set_identifier()
} // impl<'a> ::method::message::SetCheckpointMethodFields<'a> for Checkpoint<'a>
impl<'a> ::method::message::CloseMethod<'a> for ::Amqp9_0 {
    type Payload = Close<'a>;
} // impl<'a> ::method::message::CloseMethod<'a> for ::Amqp9_0

// generated by primalgen::codegen::spec-module::class_mod::method_struct
#[derive(Debug)]
pub struct Close<'a> {
    reference: ::std::borrow::Cow<'a, [u8]>,
} // struct Close<'a>

impl<'a> Close<'a> {
    pub fn new<R>(reference: R) -> Self
        where R: Into<::std::borrow::Cow<'a, [u8]>>
    {
        Close { reference: reference.into() } // Close
    } // fn new()
    impl_properties! {
(reference, reference_mut, set_reference) -> Cow<[u8]>,
} // impl_properties
} // impl<'a> Close<'a>
impl<'a> Default for Close<'a> {
    fn default() -> Self {
        Close::new(&[][..])
    } // fn default()
} // impl Default for Close

impl<'a> ::Encodable for Close<'a> {
    fn encoded_size(&self) -> usize {
        [2, ::Encodable::encoded_size(&self.reference)]
            .iter()
            .sum()
    } // fn encoded_size()
} // impl Encodable

impl<'a> ::ProtocolMethodPayload for Close<'a> {
    fn class_id(&self) -> u16 {
        120
    } // fn class_id()
    fn method_id(&self) -> u16 {
        70
    } // fn method_id()
} // impl ::Payload for Close
impl<'a> ::method::message::SetCloseMethodFields<'a> for Close<'a> {
    fn set_reference<V>(&mut self, reference: V)
        where V: Into<::std::borrow::Cow<'a, [u8]>>
    {
        self.set_reference(reference.into())
    } // set_reference()
} // impl<'a> ::method::message::SetCloseMethodFields<'a> for Close<'a>
impl<'a> ::method::message::ConsumeMethod<'a> for ::Amqp9_0 {
    type Payload = Consume<'a>;
} // impl<'a> ::method::message::ConsumeMethod<'a> for ::Amqp9_0

// generated by primalgen::codegen::spec-module::class_mod::method_struct
#[derive(Debug)]
pub struct Consume<'a> {
    ticket: u16,
    queue: ::std::borrow::Cow<'a, str>,
    destination: ::std::borrow::Cow<'a, str>,
    no_local: bool,
    no_ack: bool,
    exclusive: bool,
    filter: ::field::TableEntries<'a>,
} // struct Consume<'a>

impl<'a> Consume<'a> {
    pub fn new<Q, D, F>(ticket: u16,
                        queue: Q,
                        destination: D,
                        no_local: bool,
                        no_ack: bool,
                        exclusive: bool,
                        filter: F)
                        -> Self
        where Q: Into<::std::borrow::Cow<'a, str>>,
              D: Into<::std::borrow::Cow<'a, str>>,
              F: Into<::field::TableEntries<'a>>
    {
        Consume {
            ticket: ticket,
            queue: queue.into(),
            destination: destination.into(),
            no_local: no_local,
            no_ack: no_ack,
            exclusive: exclusive,
            filter: filter.into(),
        } // Consume
    } // fn new()
    impl_properties! {
(ticket, set_ticket) -> u16,
(queue, queue_mut, set_queue) -> Cow<str>,
(destination, destination_mut, set_destination) -> Cow<str>,
(no_local, set_no_local) -> bool,
(no_ack, set_no_ack) -> bool,
(exclusive, set_exclusive) -> bool,
(filter, filter_mut, set_filter) -> &::field::TableEntries<'a>,
} // impl_properties
} // impl<'a> Consume<'a>
impl<'a> Default for Consume<'a> {
    fn default() -> Self {
        Consume::new(0, "", "", false, false, false, ::field::TableEntries::new())
    } // fn default()
} // impl Default for Consume

impl<'a> ::Encodable for Consume<'a> {
    fn encoded_size(&self) -> usize {
        [5,
         ::Encodable::encoded_size(&self.queue),
         ::Encodable::encoded_size(&self.destination),
         ::Encodable::encoded_size(&self.filter)]
            .iter()
            .sum()
    } // fn encoded_size()
} // impl Encodable

impl<'a> ::ProtocolMethodPayload for Consume<'a> {
    fn class_id(&self) -> u16 {
        120
    } // fn class_id()
    fn method_id(&self) -> u16 {
        20
    } // fn method_id()
} // impl ::Payload for Consume
impl<'a> ::method::message::SetConsumeMethodFields<'a> for Consume<'a> {
    fn set_ticket(&mut self, ticket: u16) {
        self.set_ticket(ticket)
    } // set_ticket()
    fn set_queue<V>(&mut self, queue: V)
        where V: Into<::std::borrow::Cow<'a, str>>
    {
        self.set_queue(queue.into())
    } // set_queue()
    fn set_destination<V>(&mut self, destination: V)
        where V: Into<::std::borrow::Cow<'a, str>>
    {
        self.set_destination(destination.into())
    } // set_destination()
    fn set_no_local(&mut self, no_local: bool) {
        self.set_no_local(no_local)
    } // set_no_local()
    fn set_no_ack(&mut self, no_ack: bool) {
        self.set_no_ack(no_ack)
    } // set_no_ack()
    fn set_exclusive(&mut self, exclusive: bool) {
        self.set_exclusive(exclusive)
    } // set_exclusive()
    fn set_filter<V>(&mut self, filter: V)
        where V: Into<::field::TableEntries<'a>>
    {
        self.set_filter(filter.into())
    } // set_filter()
} // impl<'a> ::method::message::SetConsumeMethodFields<'a> for Consume<'a>
impl ::method::message::EmptyMethod for ::Amqp9_0 {
    type Payload = Empty;
} // impl ::method::message::EmptyMethod for ::Amqp9_0

// generated by primalgen::codegen::spec-module::class_mod::method_struct
#[derive(Debug)]
pub struct Empty;

impl Empty {
    pub fn new() -> Self {
        Empty
    } // fn new()
} // impl Empty
impl Default for Empty {
    fn default() -> Self {
        Empty::new()
    } // fn default()
} // impl Default for Empty

impl ::Encodable for Empty {
    fn encoded_size(&self) -> usize {
        0
    } // fn encoded_size()
} // impl Encodable

impl ::ProtocolMethodPayload for Empty {
    fn class_id(&self) -> u16 {
        120
    } // fn class_id()
    fn method_id(&self) -> u16 {
        510
    } // fn method_id()
} // impl ::Payload for Empty
impl<'a> ::method::message::GetMethod<'a> for ::Amqp9_0 {
    type Payload = Get<'a>;
} // impl<'a> ::method::message::GetMethod<'a> for ::Amqp9_0

// generated by primalgen::codegen::spec-module::class_mod::method_struct
#[derive(Debug)]
pub struct Get<'a> {
    ticket: u16,
    queue: ::std::borrow::Cow<'a, str>,
    destination: ::std::borrow::Cow<'a, str>,
    no_ack: bool,
} // struct Get<'a>

impl<'a> Get<'a> {
    pub fn new<Q, D>(ticket: u16, queue: Q, destination: D, no_ack: bool) -> Self
        where Q: Into<::std::borrow::Cow<'a, str>>,
              D: Into<::std::borrow::Cow<'a, str>>
    {
        Get {
            ticket: ticket,
            queue: queue.into(),
            destination: destination.into(),
            no_ack: no_ack,
        } // Get
    } // fn new()
    impl_properties! {
(ticket, set_ticket) -> u16,
(queue, queue_mut, set_queue) -> Cow<str>,
(destination, destination_mut, set_destination) -> Cow<str>,
(no_ack, set_no_ack) -> bool,
} // impl_properties
} // impl<'a> Get<'a>
impl<'a> Default for Get<'a> {
    fn default() -> Self {
        Get::new(0, "", "", false)
    } // fn default()
} // impl Default for Get

impl<'a> ::Encodable for Get<'a> {
    fn encoded_size(&self) -> usize {
        [5, ::Encodable::encoded_size(&self.queue), ::Encodable::encoded_size(&self.destination)]
            .iter()
            .sum()
    } // fn encoded_size()
} // impl Encodable

impl<'a> ::ProtocolMethodPayload for Get<'a> {
    fn class_id(&self) -> u16 {
        120
    } // fn class_id()
    fn method_id(&self) -> u16 {
        40
    } // fn method_id()
} // impl ::Payload for Get
impl<'a> ::method::message::SetGetMethodFields<'a> for Get<'a> {
    fn set_ticket(&mut self, ticket: u16) {
        self.set_ticket(ticket)
    } // set_ticket()
    fn set_queue<V>(&mut self, queue: V)
        where V: Into<::std::borrow::Cow<'a, str>>
    {
        self.set_queue(queue.into())
    } // set_queue()
    fn set_destination<V>(&mut self, destination: V)
        where V: Into<::std::borrow::Cow<'a, str>>
    {
        self.set_destination(destination.into())
    } // set_destination()
    fn set_no_ack(&mut self, no_ack: bool) {
        self.set_no_ack(no_ack)
    } // set_no_ack()
} // impl<'a> ::method::message::SetGetMethodFields<'a> for Get<'a>
impl ::method::message::OffsetMethod for ::Amqp9_0 {
    type Payload = Offset;
} // impl ::method::message::OffsetMethod for ::Amqp9_0

// generated by primalgen::codegen::spec-module::class_mod::method_struct
#[derive(Debug)]
pub struct Offset {
    value: u64,
} // struct Offset

impl Offset {
    pub fn new(value: u64) -> Self {
        Offset { value: value } // Offset
    } // fn new()
    impl_properties! {
(value, set_value) -> u64,
} // impl_properties
} // impl Offset
impl Default for Offset {
    fn default() -> Self {
        Offset::new(0)
    } // fn default()
} // impl Default for Offset

impl ::Encodable for Offset {
    fn encoded_size(&self) -> usize {
        8
    } // fn encoded_size()
} // impl Encodable

impl ::ProtocolMethodPayload for Offset {
    fn class_id(&self) -> u16 {
        120
    } // fn class_id()
    fn method_id(&self) -> u16 {
        530
    } // fn method_id()
} // impl ::Payload for Offset
impl ::method::message::SetOffsetMethodFields for Offset {
    fn set_value(&mut self, value: u64) {
        self.set_value(value)
    } // set_value()
} // impl ::method::message::SetOffsetMethodFields for Offset
impl ::method::message::OkMethod for ::Amqp9_0 {
    type Payload = Ok;
} // impl ::method::message::OkMethod for ::Amqp9_0

// generated by primalgen::codegen::spec-module::class_mod::method_struct
#[derive(Debug)]
pub struct Ok;

impl Ok {
    pub fn new() -> Self {
        Ok
    } // fn new()
} // impl Ok
impl Default for Ok {
    fn default() -> Self {
        Ok::new()
    } // fn default()
} // impl Default for Ok

impl ::Encodable for Ok {
    fn encoded_size(&self) -> usize {
        0
    } // fn encoded_size()
} // impl Encodable

impl ::ProtocolMethodPayload for Ok {
    fn class_id(&self) -> u16 {
        120
    } // fn class_id()
    fn method_id(&self) -> u16 {
        500
    } // fn method_id()
} // impl ::Payload for Ok
impl<'a> ::method::message::OpenMethod<'a> for ::Amqp9_0 {
    type Payload = Open<'a>;
} // impl<'a> ::method::message::OpenMethod<'a> for ::Amqp9_0

// generated by primalgen::codegen::spec-module::class_mod::method_struct
#[derive(Debug)]
pub struct Open<'a> {
    reference: ::std::borrow::Cow<'a, [u8]>,
} // struct Open<'a>

impl<'a> Open<'a> {
    pub fn new<R>(reference: R) -> Self
        where R: Into<::std::borrow::Cow<'a, [u8]>>
    {
        Open { reference: reference.into() } // Open
    } // fn new()
    impl_properties! {
(reference, reference_mut, set_reference) -> Cow<[u8]>,
} // impl_properties
} // impl<'a> Open<'a>
impl<'a> Default for Open<'a> {
    fn default() -> Self {
        Open::new(&[][..])
    } // fn default()
} // impl Default for Open

impl<'a> ::Encodable for Open<'a> {
    fn encoded_size(&self) -> usize {
        [2, ::Encodable::encoded_size(&self.reference)]
            .iter()
            .sum()
    } // fn encoded_size()
} // impl Encodable

impl<'a> ::ProtocolMethodPayload for Open<'a> {
    fn class_id(&self) -> u16 {
        120
    } // fn class_id()
    fn method_id(&self) -> u16 {
        60
    } // fn method_id()
} // impl ::Payload for Open
impl<'a> ::method::message::SetOpenMethodFields<'a> for Open<'a> {
    fn set_reference<V>(&mut self, reference: V)
        where V: Into<::std::borrow::Cow<'a, [u8]>>
    {
        self.set_reference(reference.into())
    } // set_reference()
} // impl<'a> ::method::message::SetOpenMethodFields<'a> for Open<'a>
impl ::method::message::QosMethod for ::Amqp9_0 {
    type Payload = Qos;
} // impl ::method::message::QosMethod for ::Amqp9_0

// generated by primalgen::codegen::spec-module::class_mod::method_struct
#[derive(Debug)]
pub struct Qos {
    prefetch_size: u32,
    prefetch_count: u16,
    global: bool,
} // struct Qos

impl Qos {
    pub fn new(prefetch_size: u32, prefetch_count: u16, global: bool) -> Self {
        Qos {
            prefetch_size: prefetch_size,
            prefetch_count: prefetch_count,
            global: global,
        } // Qos
    } // fn new()
    impl_properties! {
(prefetch_size, set_prefetch_size) -> u32,
(prefetch_count, set_prefetch_count) -> u16,
(global, set_global) -> bool,
} // impl_properties
} // impl Qos
impl Default for Qos {
    fn default() -> Self {
        Qos::new(0, 0, false)
    } // fn default()
} // impl Default for Qos

impl ::Encodable for Qos {
    fn encoded_size(&self) -> usize {
        7
    } // fn encoded_size()
} // impl Encodable

impl ::ProtocolMethodPayload for Qos {
    fn class_id(&self) -> u16 {
        120
    } // fn class_id()
    fn method_id(&self) -> u16 {
        110
    } // fn method_id()
} // impl ::Payload for Qos
impl ::method::message::SetQosMethodFields for Qos {
    fn set_prefetch_size(&mut self, prefetch_size: u32) {
        self.set_prefetch_size(prefetch_size)
    } // set_prefetch_size()
    fn set_prefetch_count(&mut self, prefetch_count: u16) {
        self.set_prefetch_count(prefetch_count)
    } // set_prefetch_count()
    fn set_global(&mut self, global: bool) {
        self.set_global(global)
    } // set_global()
} // impl ::method::message::SetQosMethodFields for Qos
impl ::method::message::RecoverMethod for ::Amqp9_0 {
    type Payload = Recover;
} // impl ::method::message::RecoverMethod for ::Amqp9_0

// generated by primalgen::codegen::spec-module::class_mod::method_struct
#[derive(Debug)]
pub struct Recover {
    requeue: bool,
} // struct Recover

impl Recover {
    pub fn new(requeue: bool) -> Self {
        Recover { requeue: requeue } // Recover
    } // fn new()
    impl_properties! {
(requeue, set_requeue) -> bool,
} // impl_properties
} // impl Recover
impl Default for Recover {
    fn default() -> Self {
        Recover::new(false)
    } // fn default()
} // impl Default for Recover

impl ::Encodable for Recover {
    fn encoded_size(&self) -> usize {
        1
    } // fn encoded_size()
} // impl Encodable

impl ::ProtocolMethodPayload for Recover {
    fn class_id(&self) -> u16 {
        120
    } // fn class_id()
    fn method_id(&self) -> u16 {
        50
    } // fn method_id()
} // impl ::Payload for Recover
impl ::method::message::SetRecoverMethodFields for Recover {
    fn set_requeue(&mut self, requeue: bool) {
        self.set_requeue(requeue)
    } // set_requeue()
} // impl ::method::message::SetRecoverMethodFields for Recover
impl<'a> ::method::message::RejectMethod<'a> for ::Amqp9_0 {
    type Payload = Reject<'a>;
} // impl<'a> ::method::message::RejectMethod<'a> for ::Amqp9_0

// generated by primalgen::codegen::spec-module::class_mod::method_struct
#[derive(Debug)]
pub struct Reject<'a> {
    code: u16,
    text: ::std::borrow::Cow<'a, str>,
} // struct Reject<'a>

impl<'a> Reject<'a> {
    pub fn new<T>(code: u16, text: T) -> Self
        where T: Into<::std::borrow::Cow<'a, str>>
    {
        Reject {
            code: code,
            text: text.into(),
        } // Reject
    } // fn new()
    impl_properties! {
(code, set_code) -> u16,
(text, text_mut, set_text) -> Cow<str>,
} // impl_properties
} // impl<'a> Reject<'a>
impl<'a> Default for Reject<'a> {
    fn default() -> Self {
        Reject::new(0, "")
    } // fn default()
} // impl Default for Reject

impl<'a> ::Encodable for Reject<'a> {
    fn encoded_size(&self) -> usize {
        [3, ::Encodable::encoded_size(&self.text)]
            .iter()
            .sum()
    } // fn encoded_size()
} // impl Encodable

impl<'a> ::ProtocolMethodPayload for Reject<'a> {
    fn class_id(&self) -> u16 {
        120
    } // fn class_id()
    fn method_id(&self) -> u16 {
        520
    } // fn method_id()
} // impl ::Payload for Reject
impl<'a> ::method::message::SetRejectMethodFields<'a> for Reject<'a> {
    fn set_code(&mut self, code: u16) {
        self.set_code(code)
    } // set_code()
    fn set_text<V>(&mut self, text: V)
        where V: Into<::std::borrow::Cow<'a, str>>
    {
        self.set_text(text.into())
    } // set_text()
} // impl<'a> ::method::message::SetRejectMethodFields<'a> for Reject<'a>
impl<'a> ::method::message::ResumeMethod<'a> for ::Amqp9_0 {
    type Payload = Resume<'a>;
} // impl<'a> ::method::message::ResumeMethod<'a> for ::Amqp9_0

// generated by primalgen::codegen::spec-module::class_mod::method_struct
#[derive(Debug)]
pub struct Resume<'a> {
    reference: ::std::borrow::Cow<'a, [u8]>,
    identifier: ::std::borrow::Cow<'a, str>,
} // struct Resume<'a>

impl<'a> Resume<'a> {
    pub fn new<R, I>(reference: R, identifier: I) -> Self
        where R: Into<::std::borrow::Cow<'a, [u8]>>,
              I: Into<::std::borrow::Cow<'a, str>>
    {
        Resume {
            reference: reference.into(),
            identifier: identifier.into(),
        } // Resume
    } // fn new()
    impl_properties! {
(reference, reference_mut, set_reference) -> Cow<[u8]>,
(identifier, identifier_mut, set_identifier) -> Cow<str>,
} // impl_properties
} // impl<'a> Resume<'a>
impl<'a> Default for Resume<'a> {
    fn default() -> Self {
        Resume::new(&[][..], "")
    } // fn default()
} // impl Default for Resume

impl<'a> ::Encodable for Resume<'a> {
    fn encoded_size(&self) -> usize {
        [3, ::Encodable::encoded_size(&self.reference), ::Encodable::encoded_size(&self.identifier)]
            .iter()
            .sum()
    } // fn encoded_size()
} // impl Encodable

impl<'a> ::ProtocolMethodPayload for Resume<'a> {
    fn class_id(&self) -> u16 {
        120
    } // fn class_id()
    fn method_id(&self) -> u16 {
        100
    } // fn method_id()
} // impl ::Payload for Resume
impl<'a> ::method::message::SetResumeMethodFields<'a> for Resume<'a> {
    fn set_reference<V>(&mut self, reference: V)
        where V: Into<::std::borrow::Cow<'a, [u8]>>
    {
        self.set_reference(reference.into())
    } // set_reference()
    fn set_identifier<V>(&mut self, identifier: V)
        where V: Into<::std::borrow::Cow<'a, str>>
    {
        self.set_identifier(identifier.into())
    } // set_identifier()
} // impl<'a> ::method::message::SetResumeMethodFields<'a> for Resume<'a>
impl<'a> ::method::message::TransferMethod<'a> for ::Amqp9_0 {
    type Payload = Transfer<'a>;
} // impl<'a> ::method::message::TransferMethod<'a> for ::Amqp9_0

// generated by primalgen::codegen::spec-module::class_mod::method_struct
#[derive(Debug)]
pub struct Transfer<'a> {
    ticket: u16,
    destination: ::std::borrow::Cow<'a, str>,
    redelivered: bool,
    immediate: bool,
    ttl: u64,
    priority: u8,
    timestamp: u64,
    delivery_mode: u8,
    expiration: u64,
    exchange: ::std::borrow::Cow<'a, str>,
    routing_key: ::std::borrow::Cow<'a, str>,
    message_id: ::std::borrow::Cow<'a, str>,
    correlation_id: ::std::borrow::Cow<'a, str>,
    reply_to: ::std::borrow::Cow<'a, str>,
    content_type: ::std::borrow::Cow<'a, str>,
    content_encoding: ::std::borrow::Cow<'a, str>,
    user_id: ::std::borrow::Cow<'a, str>,
    app_id: ::std::borrow::Cow<'a, str>,
    transaction_id: ::std::borrow::Cow<'a, str>,
    security_token: ::std::borrow::Cow<'a, [u8]>,
    application_headers: ::field::TableEntries<'a>,
    body: ::std::borrow::Cow<'a, [u8]>,
} // struct Transfer<'a>

impl<'a> Transfer<'a> {
    pub fn new<D, E, R, M, C, R0, C0, C1, U, A, T, S, A0, B>(ticket: u16,
                                                             destination: D,
                                                             redelivered: bool,
                                                             immediate: bool,
                                                             ttl: u64,
                                                             priority: u8,
                                                             timestamp: u64,
                                                             delivery_mode: u8,
                                                             expiration: u64,
                                                             exchange: E,
                                                             routing_key: R,
                                                             message_id: M,
                                                             correlation_id: C,
                                                             reply_to: R0,
                                                             content_type: C0,
                                                             content_encoding: C1,
                                                             user_id: U,
                                                             app_id: A,
                                                             transaction_id: T,
                                                             security_token: S,
                                                             application_headers: A0,
                                                             body: B)
                                                             -> Self
        where D: Into<::std::borrow::Cow<'a, str>>,
              E: Into<::std::borrow::Cow<'a, str>>,
              R: Into<::std::borrow::Cow<'a, str>>,
              M: Into<::std::borrow::Cow<'a, str>>,
              C: Into<::std::borrow::Cow<'a, str>>,
              R0: Into<::std::borrow::Cow<'a, str>>,
              C0: Into<::std::borrow::Cow<'a, str>>,
              C1: Into<::std::borrow::Cow<'a, str>>,
              U: Into<::std::borrow::Cow<'a, str>>,
              A: Into<::std::borrow::Cow<'a, str>>,
              T: Into<::std::borrow::Cow<'a, str>>,
              S: Into<::std::borrow::Cow<'a, [u8]>>,
              A0: Into<::field::TableEntries<'a>>,
              B: Into<::std::borrow::Cow<'a, [u8]>>
    {
        Transfer {
            ticket: ticket,
            destination: destination.into(),
            redelivered: redelivered,
            immediate: immediate,
            ttl: ttl,
            priority: priority,
            timestamp: timestamp,
            delivery_mode: delivery_mode,
            expiration: expiration,
            exchange: exchange.into(),
            routing_key: routing_key.into(),
            message_id: message_id.into(),
            correlation_id: correlation_id.into(),
            reply_to: reply_to.into(),
            content_type: content_type.into(),
            content_encoding: content_encoding.into(),
            user_id: user_id.into(),
            app_id: app_id.into(),
            transaction_id: transaction_id.into(),
            security_token: security_token.into(),
            application_headers: application_headers.into(),
            body: body.into(),
        } // Transfer
    } // fn new()
    impl_properties! {
(ticket, set_ticket) -> u16,
(destination, destination_mut, set_destination) -> Cow<str>,
(redelivered, set_redelivered) -> bool,
(immediate, set_immediate) -> bool,
(ttl, set_ttl) -> u64,
(priority, set_priority) -> u8,
(timestamp, set_timestamp) -> u64,
(delivery_mode, set_delivery_mode) -> u8,
(expiration, set_expiration) -> u64,
(exchange, exchange_mut, set_exchange) -> Cow<str>,
(routing_key, routing_key_mut, set_routing_key) -> Cow<str>,
(message_id, message_id_mut, set_message_id) -> Cow<str>,
(correlation_id, correlation_id_mut, set_correlation_id) -> Cow<str>,
(reply_to, reply_to_mut, set_reply_to) -> Cow<str>,
(content_type, content_type_mut, set_content_type) -> Cow<str>,
(content_encoding, content_encoding_mut, set_content_encoding) -> Cow<str>,
(user_id, user_id_mut, set_user_id) -> Cow<str>,
(app_id, app_id_mut, set_app_id) -> Cow<str>,
(transaction_id, transaction_id_mut, set_transaction_id) -> Cow<str>,
(security_token, security_token_mut, set_security_token) -> Cow<[u8]>,
(application_headers, application_headers_mut, set_application_headers) -> &::field::TableEntries<'a>,
(body, body_mut, set_body) -> Cow<[u8]>,
} // impl_properties
} // impl<'a> Transfer<'a>
impl<'a> Default for Transfer<'a> {
    fn default() -> Self {
        Transfer::new(0,
                      "",
                      false,
                      false,
                      0,
                      0,
                      0,
                      0,
                      0,
                      "",
                      "",
                      "",
                      "",
                      "",
                      "",
                      "",
                      "",
                      "",
                      "",
                      &[][..],
                      ::field::TableEntries::new(),
                      &[][..])
    } // fn default()
} // impl Default for Transfer

impl<'a> ::Encodable for Transfer<'a> {
    fn encoded_size(&self) -> usize {
        [43,
         ::Encodable::encoded_size(&self.destination),
         ::Encodable::encoded_size(&self.exchange),
         ::Encodable::encoded_size(&self.routing_key),
         ::Encodable::encoded_size(&self.message_id),
         ::Encodable::encoded_size(&self.correlation_id),
         ::Encodable::encoded_size(&self.reply_to),
         ::Encodable::encoded_size(&self.content_type),
         ::Encodable::encoded_size(&self.content_encoding),
         ::Encodable::encoded_size(&self.user_id),
         ::Encodable::encoded_size(&self.app_id),
         ::Encodable::encoded_size(&self.transaction_id),
         ::Encodable::encoded_size(&self.security_token),
         ::Encodable::encoded_size(&self.application_headers),
         ::Encodable::encoded_size(&self.body)]
            .iter()
            .sum()
    } // fn encoded_size()
} // impl Encodable

impl<'a> ::ProtocolMethodPayload for Transfer<'a> {
    fn class_id(&self) -> u16 {
        120
    } // fn class_id()
    fn method_id(&self) -> u16 {
        10
    } // fn method_id()
} // impl ::Payload for Transfer
impl<'a> ::method::message::SetTransferMethodFields<'a> for Transfer<'a> {
    fn set_ticket(&mut self, ticket: u16) {
        self.set_ticket(ticket)
    } // set_ticket()
    fn set_destination<V>(&mut self, destination: V)
        where V: Into<::std::borrow::Cow<'a, str>>
    {
        self.set_destination(destination.into())
    } // set_destination()
    fn set_redelivered(&mut self, redelivered: bool) {
        self.set_redelivered(redelivered)
    } // set_redelivered()
    fn set_immediate(&mut self, immediate: bool) {
        self.set_immediate(immediate)
    } // set_immediate()
    fn set_ttl(&mut self, ttl: u64) {
        self.set_ttl(ttl)
    } // set_ttl()
    fn set_priority(&mut self, priority: u8) {
        self.set_priority(priority)
    } // set_priority()
    fn set_timestamp(&mut self, timestamp: u64) {
        self.set_timestamp(timestamp)
    } // set_timestamp()
    fn set_delivery_mode(&mut self, delivery_mode: u8) {
        self.set_delivery_mode(delivery_mode)
    } // set_delivery_mode()
    fn set_expiration(&mut self, expiration: u64) {
        self.set_expiration(expiration)
    } // set_expiration()
    fn set_exchange<V>(&mut self, exchange: V)
        where V: Into<::std::borrow::Cow<'a, str>>
    {
        self.set_exchange(exchange.into())
    } // set_exchange()
    fn set_routing_key<V>(&mut self, routing_key: V)
        where V: Into<::std::borrow::Cow<'a, str>>
    {
        self.set_routing_key(routing_key.into())
    } // set_routing_key()
    fn set_message_id<V>(&mut self, message_id: V)
        where V: Into<::std::borrow::Cow<'a, str>>
    {
        self.set_message_id(message_id.into())
    } // set_message_id()
    fn set_correlation_id<V>(&mut self, correlation_id: V)
        where V: Into<::std::borrow::Cow<'a, str>>
    {
        self.set_correlation_id(correlation_id.into())
    } // set_correlation_id()
    fn set_reply_to<V>(&mut self, reply_to: V)
        where V: Into<::std::borrow::Cow<'a, str>>
    {
        self.set_reply_to(reply_to.into())
    } // set_reply_to()
    fn set_content_type<V>(&mut self, content_type: V)
        where V: Into<::std::borrow::Cow<'a, str>>
    {
        self.set_content_type(content_type.into())
    } // set_content_type()
    fn set_content_encoding<V>(&mut self, content_encoding: V)
        where V: Into<::std::borrow::Cow<'a, str>>
    {
        self.set_content_encoding(content_encoding.into())
    } // set_content_encoding()
    fn set_user_id<V>(&mut self, user_id: V)
        where V: Into<::std::borrow::Cow<'a, str>>
    {
        self.set_user_id(user_id.into())
    } // set_user_id()
    fn set_app_id<V>(&mut self, app_id: V)
        where V: Into<::std::borrow::Cow<'a, str>>
    {
        self.set_app_id(app_id.into())
    } // set_app_id()
    fn set_transaction_id<V>(&mut self, transaction_id: V)
        where V: Into<::std::borrow::Cow<'a, str>>
    {
        self.set_transaction_id(transaction_id.into())
    } // set_transaction_id()
    fn set_security_token<V>(&mut self, security_token: V)
        where V: Into<::std::borrow::Cow<'a, [u8]>>
    {
        self.set_security_token(security_token.into())
    } // set_security_token()
    fn set_application_headers<V>(&mut self, application_headers: V)
        where V: Into<::field::TableEntries<'a>>
    {
        self.set_application_headers(application_headers.into())
    } // set_application_headers()
    fn set_body<V>(&mut self, body: V)
        where V: Into<::std::borrow::Cow<'a, [u8]>>
    {
        self.set_body(body.into())
    } // set_body()
} // impl<'a> ::method::message::SetTransferMethodFields<'a> for Transfer<'a>

#[derive(Debug)]
pub enum ClassMethod<'a> {
    Append(Append<'a>),
    Cancel(Cancel<'a>),
    Checkpoint(Checkpoint<'a>),
    Close(Close<'a>),
    Consume(Consume<'a>),
    Empty(Empty),
    Get(Get<'a>),
    Offset(Offset),
    Ok(Ok),
    Open(Open<'a>),
    Qos(Qos),
    Recover(Recover),
    Reject(Reject<'a>),
    Resume(Resume<'a>),
    Transfer(Transfer<'a>),
} // enum ClassMethod


impl<'a> ::Encodable for ClassMethod<'a> {
    fn encoded_size(&self) -> usize {
        match *self {
            ClassMethod::Append(ref method) => ::Encodable::encoded_size(method),
            ClassMethod::Cancel(ref method) => ::Encodable::encoded_size(method),
            ClassMethod::Checkpoint(ref method) => ::Encodable::encoded_size(method),
            ClassMethod::Close(ref method) => ::Encodable::encoded_size(method),
            ClassMethod::Consume(ref method) => ::Encodable::encoded_size(method),
            ClassMethod::Empty(ref method) => ::Encodable::encoded_size(method),
            ClassMethod::Get(ref method) => ::Encodable::encoded_size(method),
            ClassMethod::Offset(ref method) => ::Encodable::encoded_size(method),
            ClassMethod::Ok(ref method) => ::Encodable::encoded_size(method),
            ClassMethod::Open(ref method) => ::Encodable::encoded_size(method),
            ClassMethod::Qos(ref method) => ::Encodable::encoded_size(method),
            ClassMethod::Recover(ref method) => ::Encodable::encoded_size(method),
            ClassMethod::Reject(ref method) => ::Encodable::encoded_size(method),
            ClassMethod::Resume(ref method) => ::Encodable::encoded_size(method),
            ClassMethod::Transfer(ref method) => ::Encodable::encoded_size(method),

        } // match *self

    } // fn encoded_size
} // impl ::Encodable for ClassMethod<'a>

impl<'a> ::ProtocolMethodPayload for ClassMethod<'a> {
    fn class_id(&self) -> u16 {
        match *self {
            ClassMethod::Append(ref method) => ::ProtocolMethodPayload::class_id(method),
            ClassMethod::Cancel(ref method) => ::ProtocolMethodPayload::class_id(method),
            ClassMethod::Checkpoint(ref method) => ::ProtocolMethodPayload::class_id(method),
            ClassMethod::Close(ref method) => ::ProtocolMethodPayload::class_id(method),
            ClassMethod::Consume(ref method) => ::ProtocolMethodPayload::class_id(method),
            ClassMethod::Empty(ref method) => ::ProtocolMethodPayload::class_id(method),
            ClassMethod::Get(ref method) => ::ProtocolMethodPayload::class_id(method),
            ClassMethod::Offset(ref method) => ::ProtocolMethodPayload::class_id(method),
            ClassMethod::Ok(ref method) => ::ProtocolMethodPayload::class_id(method),
            ClassMethod::Open(ref method) => ::ProtocolMethodPayload::class_id(method),
            ClassMethod::Qos(ref method) => ::ProtocolMethodPayload::class_id(method),
            ClassMethod::Recover(ref method) => ::ProtocolMethodPayload::class_id(method),
            ClassMethod::Reject(ref method) => ::ProtocolMethodPayload::class_id(method),
            ClassMethod::Resume(ref method) => ::ProtocolMethodPayload::class_id(method),
            ClassMethod::Transfer(ref method) => ::ProtocolMethodPayload::class_id(method),

        } // match *self

    } // fn class_id

    fn method_id(&self) -> u16 {
        match *self {
            ClassMethod::Append(ref method) => ::ProtocolMethodPayload::method_id(method),
            ClassMethod::Cancel(ref method) => ::ProtocolMethodPayload::method_id(method),
            ClassMethod::Checkpoint(ref method) => ::ProtocolMethodPayload::method_id(method),
            ClassMethod::Close(ref method) => ::ProtocolMethodPayload::method_id(method),
            ClassMethod::Consume(ref method) => ::ProtocolMethodPayload::method_id(method),
            ClassMethod::Empty(ref method) => ::ProtocolMethodPayload::method_id(method),
            ClassMethod::Get(ref method) => ::ProtocolMethodPayload::method_id(method),
            ClassMethod::Offset(ref method) => ::ProtocolMethodPayload::method_id(method),
            ClassMethod::Ok(ref method) => ::ProtocolMethodPayload::method_id(method),
            ClassMethod::Open(ref method) => ::ProtocolMethodPayload::method_id(method),
            ClassMethod::Qos(ref method) => ::ProtocolMethodPayload::method_id(method),
            ClassMethod::Recover(ref method) => ::ProtocolMethodPayload::method_id(method),
            ClassMethod::Reject(ref method) => ::ProtocolMethodPayload::method_id(method),
            ClassMethod::Resume(ref method) => ::ProtocolMethodPayload::method_id(method),
            ClassMethod::Transfer(ref method) => ::ProtocolMethodPayload::method_id(method),

        } // match *self

    } // fn method_id
} // impl ProtocolMethodPayload for ClassMethod
