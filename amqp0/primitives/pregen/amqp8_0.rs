// Generated by build.rs script in amqp0-primitives
// Pre-generated files are used by default. Generation is done with the amqp0-codegen crate
//
// To regenerate, and not use pre-generated files, use: cargo --features="amqp0-build-primitives"
// To format and replace the pre-generated files, use: cargo --features="amqp0-pregen-primitives"
//
// EDITORS BEWARE: Your modifications may be overridden
#![allow(too_many_arguments)]

// Class Constants
// Generated by primalgen::codegen::spec_module::SpecModuleWriter
pub const CLASS_CONNECTION: u16 = 10;
pub const CLASS_CHANNEL: u16 = 20;
pub const CLASS_ACCESS: u16 = 30;
pub const CLASS_EXCHANGE: u16 = 40;
pub const CLASS_QUEUE: u16 = 50;
pub const CLASS_BASIC: u16 = 60;
pub const CLASS_FILE: u16 = 70;
pub const CLASS_STREAM: u16 = 80;
pub const CLASS_TX: u16 = 90;
pub const CLASS_DTX: u16 = 100;
pub const CLASS_TUNNEL: u16 = 110;
pub const CLASS_TEST: u16 = 120;

// Class Methods
// Generated by codegen::spec_module::SpecModuleWriter
pub const METHOD_ACCESS_REQUEST: u16 = 10;
pub const METHOD_ACCESS_REQUEST_OK: u16 = 11;

pub const METHOD_BASIC_QOS: u16 = 10;
pub const METHOD_BASIC_QOS_OK: u16 = 11;
pub const METHOD_BASIC_CONSUME: u16 = 20;
pub const METHOD_BASIC_CONSUME_OK: u16 = 21;
pub const METHOD_BASIC_CANCEL: u16 = 30;
pub const METHOD_BASIC_CANCEL_OK: u16 = 31;
pub const METHOD_BASIC_PUBLISH: u16 = 40;
pub const METHOD_BASIC_RETURN: u16 = 50;
pub const METHOD_BASIC_DELIVER: u16 = 60;
pub const METHOD_BASIC_GET: u16 = 70;
pub const METHOD_BASIC_GET_OK: u16 = 71;
pub const METHOD_BASIC_GET_EMPTY: u16 = 72;
pub const METHOD_BASIC_ACK: u16 = 80;
pub const METHOD_BASIC_REJECT: u16 = 90;
pub const METHOD_BASIC_RECOVER: u16 = 100;

pub const METHOD_CHANNEL_OPEN: u16 = 10;
pub const METHOD_CHANNEL_OPEN_OK: u16 = 11;
pub const METHOD_CHANNEL_FLOW: u16 = 20;
pub const METHOD_CHANNEL_FLOW_OK: u16 = 21;
pub const METHOD_CHANNEL_ALERT: u16 = 30;
pub const METHOD_CHANNEL_CLOSE: u16 = 40;
pub const METHOD_CHANNEL_CLOSE_OK: u16 = 41;

pub const METHOD_CONNECTION_START: u16 = 10;
pub const METHOD_CONNECTION_START_OK: u16 = 11;
pub const METHOD_CONNECTION_SECURE: u16 = 20;
pub const METHOD_CONNECTION_SECURE_OK: u16 = 21;
pub const METHOD_CONNECTION_TUNE: u16 = 30;
pub const METHOD_CONNECTION_TUNE_OK: u16 = 31;
pub const METHOD_CONNECTION_OPEN: u16 = 40;
pub const METHOD_CONNECTION_OPEN_OK: u16 = 41;
pub const METHOD_CONNECTION_REDIRECT: u16 = 50;
pub const METHOD_CONNECTION_CLOSE: u16 = 60;
pub const METHOD_CONNECTION_CLOSE_OK: u16 = 61;

pub const METHOD_DTX_SELECT: u16 = 10;
pub const METHOD_DTX_SELECT_OK: u16 = 11;
pub const METHOD_DTX_START: u16 = 20;
pub const METHOD_DTX_START_OK: u16 = 21;

pub const METHOD_EXCHANGE_DECLARE: u16 = 10;
pub const METHOD_EXCHANGE_DECLARE_OK: u16 = 11;
pub const METHOD_EXCHANGE_DELETE: u16 = 20;
pub const METHOD_EXCHANGE_DELETE_OK: u16 = 21;

pub const METHOD_FILE_QOS: u16 = 10;
pub const METHOD_FILE_QOS_OK: u16 = 11;
pub const METHOD_FILE_CONSUME: u16 = 20;
pub const METHOD_FILE_CONSUME_OK: u16 = 21;
pub const METHOD_FILE_CANCEL: u16 = 30;
pub const METHOD_FILE_CANCEL_OK: u16 = 31;
pub const METHOD_FILE_OPEN: u16 = 40;
pub const METHOD_FILE_OPEN_OK: u16 = 41;
pub const METHOD_FILE_STAGE: u16 = 50;
pub const METHOD_FILE_PUBLISH: u16 = 60;
pub const METHOD_FILE_RETURN: u16 = 70;
pub const METHOD_FILE_DELIVER: u16 = 80;
pub const METHOD_FILE_ACK: u16 = 90;
pub const METHOD_FILE_REJECT: u16 = 100;

pub const METHOD_QUEUE_DECLARE: u16 = 10;
pub const METHOD_QUEUE_DECLARE_OK: u16 = 11;
pub const METHOD_QUEUE_BIND: u16 = 20;
pub const METHOD_QUEUE_BIND_OK: u16 = 21;
pub const METHOD_QUEUE_PURGE: u16 = 30;
pub const METHOD_QUEUE_PURGE_OK: u16 = 31;
pub const METHOD_QUEUE_DELETE: u16 = 40;
pub const METHOD_QUEUE_DELETE_OK: u16 = 41;

pub const METHOD_STREAM_QOS: u16 = 10;
pub const METHOD_STREAM_QOS_OK: u16 = 11;
pub const METHOD_STREAM_CONSUME: u16 = 20;
pub const METHOD_STREAM_CONSUME_OK: u16 = 21;
pub const METHOD_STREAM_CANCEL: u16 = 30;
pub const METHOD_STREAM_CANCEL_OK: u16 = 31;
pub const METHOD_STREAM_PUBLISH: u16 = 40;
pub const METHOD_STREAM_RETURN: u16 = 50;
pub const METHOD_STREAM_DELIVER: u16 = 60;

pub const METHOD_TEST_INTEGER: u16 = 10;
pub const METHOD_TEST_INTEGER_OK: u16 = 11;
pub const METHOD_TEST_STRING: u16 = 20;
pub const METHOD_TEST_STRING_OK: u16 = 21;
pub const METHOD_TEST_TABLE: u16 = 30;
pub const METHOD_TEST_TABLE_OK: u16 = 31;
pub const METHOD_TEST_CONTENT: u16 = 40;
pub const METHOD_TEST_CONTENT_OK: u16 = 41;

pub const METHOD_TUNNEL_REQUEST: u16 = 10;

pub const METHOD_TX_SELECT: u16 = 10;
pub const METHOD_TX_SELECT_OK: u16 = 11;
pub const METHOD_TX_COMMIT: u16 = 20;
pub const METHOD_TX_COMMIT_OK: u16 = 21;
pub const METHOD_TX_ROLLBACK: u16 = 30;
pub const METHOD_TX_ROLLBACK_OK: u16 = 31;

// Generated by primalgen::codegen::header_enum::HeaderEnumWriter
#[derive(Debug)]
pub enum SpecHeader<'a> {
    Access,
    Basic(basic::Header<'a>),
    Channel,
    Connection,
    Dtx,
    Exchange,
    File(file::Header<'a>),
    Queue,
    Stream(stream::Header<'a>),
    Test,
    Tunnel(tunnel::Header<'a>),
    Tx,
} // enum SpecHeader

impl<'a> ::Encodable for SpecHeader<'a> {
    fn encoded_size(&self) -> usize {
        match *self {
            SpecHeader::Access => 0,
            SpecHeader::Basic(ref header) => ::Encodable::encoded_size(header),
            SpecHeader::Channel => 0,
            SpecHeader::Connection => 0,
            SpecHeader::Dtx => 0,
            SpecHeader::Exchange => 0,
            SpecHeader::File(ref header) => ::Encodable::encoded_size(header),
            SpecHeader::Queue => 0,
            SpecHeader::Stream(ref header) => ::Encodable::encoded_size(header),
            SpecHeader::Test => 0,
            SpecHeader::Tunnel(ref header) => ::Encodable::encoded_size(header),
            SpecHeader::Tx => 0,

        } // match *self

    } // fn encoded_size
} // F::Encodable for SpecMethod

// Generated by primalgen::codegen::spec_module::SpecModuleWriter
#[derive(Debug)]
pub struct Frame<'a> {
    channel: u16,
    cycle: u8,
    payload: FramePayload<'a>,
} // struct Frame

impl<'a> Frame<'a> {
    pub fn new<P>(channel: u16, cycle: u8, payload: P) -> Self
        where P: Into<FramePayload<'a>>
    {
        Frame {
            channel: channel,
            cycle: cycle,
            payload: payload.into(),
        } // Frame
    } // fn new()

    pub fn channel(&self) -> u16 {
        self.channel
    } // fn channel()

    pub fn payload(&self) -> &FramePayload<'a> {
        &self.payload
    } // fn payload()

    pub fn cycle(&self) -> u8 {
        {
            self.cycle
        }
    } // fn cycle()
} // impl Frame<'a>


// Generated by primalgen::codegen::spec_module::frame_payload_enum::FramePayloadEnumWriter
#[derive(Debug)]
pub enum FramePayload<'a> {
    Body(&'a [u8]),
    Header(SpecHeader<'a>),
    Heartbeat,
    Method(SpecMethod<'a>),
    OobBody(&'a [u8]),
    OobHeader(SpecHeader<'a>),
    OobMethod(SpecMethod<'a>),
    Trace(&'a [u8]),
} // enum FramePayload

// Generated by primalgen::codegen::spec_module::frame_payload_enum::FramePayloadEnumWriter
impl<'a> ::Encodable for FramePayload<'a> {
    fn encoded_size(&self) -> usize {
        match *self {
            FramePayload::Method(ref method) |
            FramePayload::OobMethod(ref method) => ::Encodable::encoded_size(method),
            FramePayload::Header(ref header) |
            FramePayload::OobHeader(ref header) => ::Encodable::encoded_size(header),
            FramePayload::Body(ref body) |
            FramePayload::OobBody(ref body) |
            FramePayload::Trace(ref body) => body.len(),
            _ => 0,
        } // match
    } // fn encoded_size()
} // impl Encodable

// Class Modules

// generated by primalgen::codegen::spec_module::class_mod::ClassModuleWriter
pub mod access {
    impl<'a> ::method::access::RequestMethod<'a> for ::Amqp8_0 {
        type Payload = Request<'a>;
    } // impl<'a> ::method::access::RequestMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Request<'a> {
        realm: ::std::borrow::Cow<'a, str>,
        exclusive: bool,
        passive: bool,
        active: bool,
        write: bool,
        read: bool,
    } // struct Request<'a>

    impl<'a> Request<'a> {
        pub fn new<R>(realm: R,
                      exclusive: bool,
                      passive: bool,
                      active: bool,
                      write: bool,
                      read: bool)
                      -> Self
            where R: Into<::std::borrow::Cow<'a, str>>
        {
            Request {
                realm: realm.into(),
                exclusive: exclusive,
                passive: passive,
                active: active,
                write: write,
                read: read,
            } // Request
        } // fn new()
        impl_properties! {
(realm, realm_mut, set_realm) -> Cow<str>,
(exclusive, set_exclusive) -> bool,
(passive, set_passive) -> bool,
(active, set_active) -> bool,
(write, set_write) -> bool,
(read, set_read) -> bool,
} // impl_properties
    } // impl<'a> Request<'a>
    impl<'a> Default for Request<'a> {
        fn default() -> Self {
            Request::new("", false, false, false, false, false)
        } // fn default()
    } // impl Default for Request

    impl<'a> ::Encodable for Request<'a> {
        fn encoded_size(&self) -> usize {
            [2, ::Encodable::encoded_size(&self.realm)]
                .iter()
                .sum()
        } // fn encoded_size()
    } // impl Encodable

    impl<'a> ::ProtocolMethodPayload for Request<'a> {
        fn class_id(&self) -> u16 {
            30
        } // fn class_id()
        fn method_id(&self) -> u16 {
            10
        } // fn method_id()
    } // impl ::Payload for Request
    impl<'a> ::method::access::SetRequestMethodFields<'a> for Request<'a> {
        fn set_realm<V>(&mut self, realm: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_realm(realm.into())
        } // set_realm()
        fn set_exclusive(&mut self, exclusive: bool) {
            self.set_exclusive(exclusive)
        } // set_exclusive()
        fn set_passive(&mut self, passive: bool) {
            self.set_passive(passive)
        } // set_passive()
        fn set_active(&mut self, active: bool) {
            self.set_active(active)
        } // set_active()
        fn set_write(&mut self, write: bool) {
            self.set_write(write)
        } // set_write()
        fn set_read(&mut self, read: bool) {
            self.set_read(read)
        } // set_read()
    } // impl<'a> ::method::access::SetRequestMethodFields<'a> for Request<'a>
    impl ::method::access::RequestOkMethod for ::Amqp8_0 {
        type Payload = RequestOk;
    } // impl ::method::access::RequestOkMethod for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct RequestOk {
        ticket: u16,
    } // struct RequestOk

    impl RequestOk {
        pub fn new(ticket: u16) -> Self {
            RequestOk { ticket: ticket } // RequestOk
        } // fn new()
        impl_properties! {
(ticket, set_ticket) -> u16,
} // impl_properties
    } // impl RequestOk
    impl Default for RequestOk {
        fn default() -> Self {
            RequestOk::new(0)
        } // fn default()
    } // impl Default for RequestOk

    impl ::Encodable for RequestOk {
        fn encoded_size(&self) -> usize {
            2
        } // fn encoded_size()
    } // impl Encodable

    impl ::ProtocolMethodPayload for RequestOk {
        fn class_id(&self) -> u16 {
            30
        } // fn class_id()
        fn method_id(&self) -> u16 {
            11
        } // fn method_id()
    } // impl ::Payload for RequestOk
    impl ::method::access::SetRequestOkMethodFields for RequestOk {
        fn set_ticket(&mut self, ticket: u16) {
            self.set_ticket(ticket)
        } // set_ticket()
    } // impl ::method::access::SetRequestOkMethodFields for RequestOk

    #[derive(Debug)]
    pub enum ClassMethod<'a> {
        Request(Request<'a>),
        RequestOk(RequestOk),
    } // enum ClassMethod


    impl<'a> ::Encodable for ClassMethod<'a> {
        fn encoded_size(&self) -> usize {
            match *self {
                ClassMethod::Request(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::RequestOk(ref method) => ::Encodable::encoded_size(method),

            } // match *self

        } // fn encoded_size
    } // impl ::Encodable for ClassMethod<'a>

    impl<'a> ::ProtocolMethodPayload for ClassMethod<'a> {
        fn class_id(&self) -> u16 {
            match *self {
                ClassMethod::Request(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::RequestOk(ref method) => ::ProtocolMethodPayload::class_id(method),

            } // match *self

        } // fn class_id

        fn method_id(&self) -> u16 {
            match *self {
                ClassMethod::Request(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::RequestOk(ref method) => ::ProtocolMethodPayload::method_id(method),

            } // match *self

        } // fn method_id
    } // impl ProtocolMethodPayload for ClassMethod
} // mod access

// generated by primalgen::codegen::spec_module::class_mod::ClassModuleWriter
pub mod basic {

    // Generated by primalgen::spec::frame_payload_enum::ClassEnumWriter
    #[derive(Debug)]
    pub struct Header<'a> {
        content_type: Option<::std::borrow::Cow<'a, str>>,
        content_encoding: Option<::std::borrow::Cow<'a, str>>,
        headers: Option<::field::TableEntries<'a>>,
        delivery_mode: Option<u8>,
        priority: Option<u8>,
        correlation_id: Option<::std::borrow::Cow<'a, str>>,
        reply_to: Option<::std::borrow::Cow<'a, str>>,
        expiration: Option<::std::borrow::Cow<'a, str>>,
        message_id: Option<::std::borrow::Cow<'a, str>>,
        timestamp: Option<u64>,
        ty: Option<::std::borrow::Cow<'a, str>>,
        user_id: Option<::std::borrow::Cow<'a, str>>,
        app_id: Option<::std::borrow::Cow<'a, str>>,
        cluster_id: Option<::std::borrow::Cow<'a, str>>,
    } // struct Header

    impl<'a> Header<'a> {
        impl_properties! {
(content_type, content_type_mut, set_content_type, take_content_type) -> Option< Cow<str> >,
(content_encoding, content_encoding_mut, set_content_encoding, take_content_encoding) -> Option< Cow<str> >,
(headers, headers_mut, set_headers, take_headers) -> Option< &::field::TableEntries<'a> >,
(delivery_mode, delivery_mode_mut, set_delivery_mode, take_delivery_mode) -> Option< u8 >,
(priority, priority_mut, set_priority, take_priority) -> Option< u8 >,
(correlation_id, correlation_id_mut, set_correlation_id, take_correlation_id) -> Option< Cow<str> >,
(reply_to, reply_to_mut, set_reply_to, take_reply_to) -> Option< Cow<str> >,
(expiration, expiration_mut, set_expiration, take_expiration) -> Option< Cow<str> >,
(message_id, message_id_mut, set_message_id, take_message_id) -> Option< Cow<str> >,
(timestamp, timestamp_mut, set_timestamp, take_timestamp) -> Option< u64 >,
(ty, ty_mut, set_ty, take_ty) -> Option< Cow<str> >,
(user_id, user_id_mut, set_user_id, take_user_id) -> Option< Cow<str> >,
(app_id, app_id_mut, set_app_id, take_app_id) -> Option< Cow<str> >,
(cluster_id, cluster_id_mut, set_cluster_id, take_cluster_id) -> Option< Cow<str> >,
} // impl_properties
    } // impl Headers

    impl<'a> ::Encodable for Header<'a> {
        fn encoded_size(&self) -> usize {
            unimplemented!()
        } // fn encoded_size
    } // impl ::Encodable for Header<'a>
    impl ::method::basic::AckMethod for ::Amqp8_0 {
        type Payload = Ack;
    } // impl ::method::basic::AckMethod for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Ack {
        delivery_tag: u64,
        multiple: bool,
    } // struct Ack

    impl Ack {
        pub fn new(delivery_tag: u64, multiple: bool) -> Self {
            Ack {
                delivery_tag: delivery_tag,
                multiple: multiple,
            } // Ack
        } // fn new()
        impl_properties! {
(delivery_tag, set_delivery_tag) -> u64,
(multiple, set_multiple) -> bool,
} // impl_properties
    } // impl Ack
    impl Default for Ack {
        fn default() -> Self {
            Ack::new(0, false)
        } // fn default()
    } // impl Default for Ack

    impl ::Encodable for Ack {
        fn encoded_size(&self) -> usize {
            9
        } // fn encoded_size()
    } // impl Encodable

    impl ::ProtocolMethodPayload for Ack {
        fn class_id(&self) -> u16 {
            60
        } // fn class_id()
        fn method_id(&self) -> u16 {
            80
        } // fn method_id()
    } // impl ::Payload for Ack
    impl ::method::basic::SetAckMethodFields for Ack {
        fn set_delivery_tag(&mut self, delivery_tag: u64) {
            self.set_delivery_tag(delivery_tag)
        } // set_delivery_tag()
        fn set_multiple(&mut self, multiple: bool) {
            self.set_multiple(multiple)
        } // set_multiple()
    } // impl ::method::basic::SetAckMethodFields for Ack
    impl<'a> ::method::basic::CancelMethod<'a> for ::Amqp8_0 {
        type Payload = Cancel<'a>;
    } // impl<'a> ::method::basic::CancelMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Cancel<'a> {
        consumer_tag: ::std::borrow::Cow<'a, str>,
        no_wait: bool,
    } // struct Cancel<'a>

    impl<'a> Cancel<'a> {
        pub fn new<C>(consumer_tag: C, no_wait: bool) -> Self
            where C: Into<::std::borrow::Cow<'a, str>>
        {
            Cancel {
                consumer_tag: consumer_tag.into(),
                no_wait: no_wait,
            } // Cancel
        } // fn new()
        impl_properties! {
(consumer_tag, consumer_tag_mut, set_consumer_tag) -> Cow<str>,
(no_wait, set_no_wait) -> bool,
} // impl_properties
    } // impl<'a> Cancel<'a>
    impl<'a> Default for Cancel<'a> {
        fn default() -> Self {
            Cancel::new("", false)
        } // fn default()
    } // impl Default for Cancel

    impl<'a> ::Encodable for Cancel<'a> {
        fn encoded_size(&self) -> usize {
            [2, ::Encodable::encoded_size(&self.consumer_tag)]
                .iter()
                .sum()
        } // fn encoded_size()
    } // impl Encodable

    impl<'a> ::ProtocolMethodPayload for Cancel<'a> {
        fn class_id(&self) -> u16 {
            60
        } // fn class_id()
        fn method_id(&self) -> u16 {
            30
        } // fn method_id()
    } // impl ::Payload for Cancel
    impl<'a> ::method::basic::SetCancelMethodFields<'a> for Cancel<'a> {
        fn set_consumer_tag<V>(&mut self, consumer_tag: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_consumer_tag(consumer_tag.into())
        } // set_consumer_tag()
        fn set_no_wait(&mut self, no_wait: bool) {
            self.set_no_wait(no_wait)
        } // set_no_wait()
    } // impl<'a> ::method::basic::SetCancelMethodFields<'a> for Cancel<'a>
    impl<'a> ::method::basic::CancelOkMethod<'a> for ::Amqp8_0 {
        type Payload = CancelOk<'a>;
    } // impl<'a> ::method::basic::CancelOkMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct CancelOk<'a> {
        consumer_tag: ::std::borrow::Cow<'a, str>,
    } // struct CancelOk<'a>

    impl<'a> CancelOk<'a> {
        pub fn new<C>(consumer_tag: C) -> Self
            where C: Into<::std::borrow::Cow<'a, str>>
        {
            CancelOk { consumer_tag: consumer_tag.into() } // CancelOk
        } // fn new()
        impl_properties! {
(consumer_tag, consumer_tag_mut, set_consumer_tag) -> Cow<str>,
} // impl_properties
    } // impl<'a> CancelOk<'a>
    impl<'a> Default for CancelOk<'a> {
        fn default() -> Self {
            CancelOk::new("")
        } // fn default()
    } // impl Default for CancelOk

    impl<'a> ::Encodable for CancelOk<'a> {
        fn encoded_size(&self) -> usize {
            [1, ::Encodable::encoded_size(&self.consumer_tag)]
                .iter()
                .sum()
        } // fn encoded_size()
    } // impl Encodable

    impl<'a> ::ProtocolMethodPayload for CancelOk<'a> {
        fn class_id(&self) -> u16 {
            60
        } // fn class_id()
        fn method_id(&self) -> u16 {
            31
        } // fn method_id()
    } // impl ::Payload for CancelOk
    impl<'a> ::method::basic::SetCancelOkMethodFields<'a> for CancelOk<'a> {
        fn set_consumer_tag<V>(&mut self, consumer_tag: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_consumer_tag(consumer_tag.into())
        } // set_consumer_tag()
    } // impl<'a> ::method::basic::SetCancelOkMethodFields<'a> for CancelOk<'a>
    impl<'a> ::method::basic::ConsumeMethod<'a> for ::Amqp8_0 {
        type Payload = Consume<'a>;
    } // impl<'a> ::method::basic::ConsumeMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Consume<'a> {
        ticket: u16,
        queue: ::std::borrow::Cow<'a, str>,
        consumer_tag: ::std::borrow::Cow<'a, str>,
        no_local: bool,
        no_ack: bool,
        exclusive: bool,
        no_wait: bool,
    } // struct Consume<'a>

    impl<'a> Consume<'a> {
        pub fn new<Q, C>(ticket: u16,
                         queue: Q,
                         consumer_tag: C,
                         no_local: bool,
                         no_ack: bool,
                         exclusive: bool,
                         no_wait: bool)
                         -> Self
            where Q: Into<::std::borrow::Cow<'a, str>>,
                  C: Into<::std::borrow::Cow<'a, str>>
        {
            Consume {
                ticket: ticket,
                queue: queue.into(),
                consumer_tag: consumer_tag.into(),
                no_local: no_local,
                no_ack: no_ack,
                exclusive: exclusive,
                no_wait: no_wait,
            } // Consume
        } // fn new()
        impl_properties! {
(ticket, set_ticket) -> u16,
(queue, queue_mut, set_queue) -> Cow<str>,
(consumer_tag, consumer_tag_mut, set_consumer_tag) -> Cow<str>,
(no_local, set_no_local) -> bool,
(no_ack, set_no_ack) -> bool,
(exclusive, set_exclusive) -> bool,
(no_wait, set_no_wait) -> bool,
} // impl_properties
    } // impl<'a> Consume<'a>
    impl<'a> Default for Consume<'a> {
        fn default() -> Self {
            Consume::new(0, "", "", false, false, false, false)
        } // fn default()
    } // impl Default for Consume

    impl<'a> ::Encodable for Consume<'a> {
        fn encoded_size(&self) -> usize {
            [5,
             ::Encodable::encoded_size(&self.queue),
             ::Encodable::encoded_size(&self.consumer_tag)]
                .iter()
                .sum()
        } // fn encoded_size()
    } // impl Encodable

    impl<'a> ::ProtocolMethodPayload for Consume<'a> {
        fn class_id(&self) -> u16 {
            60
        } // fn class_id()
        fn method_id(&self) -> u16 {
            20
        } // fn method_id()
    } // impl ::Payload for Consume
    impl<'a> ::method::basic::SetConsumeMethodFields<'a> for Consume<'a> {
        fn set_ticket(&mut self, ticket: u16) {
            self.set_ticket(ticket)
        } // set_ticket()
        fn set_queue<V>(&mut self, queue: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_queue(queue.into())
        } // set_queue()
        fn set_consumer_tag<V>(&mut self, consumer_tag: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_consumer_tag(consumer_tag.into())
        } // set_consumer_tag()
        fn set_no_local(&mut self, no_local: bool) {
            self.set_no_local(no_local)
        } // set_no_local()
        fn set_no_ack(&mut self, no_ack: bool) {
            self.set_no_ack(no_ack)
        } // set_no_ack()
        fn set_exclusive(&mut self, exclusive: bool) {
            self.set_exclusive(exclusive)
        } // set_exclusive()
        fn set_no_wait(&mut self, no_wait: bool) {
            self.set_no_wait(no_wait)
        } // set_no_wait()
    } // impl<'a> ::method::basic::SetConsumeMethodFields<'a> for Consume<'a>
    impl<'a> ::method::basic::ConsumeOkMethod<'a> for ::Amqp8_0 {
        type Payload = ConsumeOk<'a>;
    } // impl<'a> ::method::basic::ConsumeOkMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct ConsumeOk<'a> {
        consumer_tag: ::std::borrow::Cow<'a, str>,
    } // struct ConsumeOk<'a>

    impl<'a> ConsumeOk<'a> {
        pub fn new<C>(consumer_tag: C) -> Self
            where C: Into<::std::borrow::Cow<'a, str>>
        {
            ConsumeOk { consumer_tag: consumer_tag.into() } // ConsumeOk
        } // fn new()
        impl_properties! {
(consumer_tag, consumer_tag_mut, set_consumer_tag) -> Cow<str>,
} // impl_properties
    } // impl<'a> ConsumeOk<'a>
    impl<'a> Default for ConsumeOk<'a> {
        fn default() -> Self {
            ConsumeOk::new("")
        } // fn default()
    } // impl Default for ConsumeOk

    impl<'a> ::Encodable for ConsumeOk<'a> {
        fn encoded_size(&self) -> usize {
            [1, ::Encodable::encoded_size(&self.consumer_tag)]
                .iter()
                .sum()
        } // fn encoded_size()
    } // impl Encodable

    impl<'a> ::ProtocolMethodPayload for ConsumeOk<'a> {
        fn class_id(&self) -> u16 {
            60
        } // fn class_id()
        fn method_id(&self) -> u16 {
            21
        } // fn method_id()
    } // impl ::Payload for ConsumeOk
    impl<'a> ::method::basic::SetConsumeOkMethodFields<'a> for ConsumeOk<'a> {
        fn set_consumer_tag<V>(&mut self, consumer_tag: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_consumer_tag(consumer_tag.into())
        } // set_consumer_tag()
    } // impl<'a> ::method::basic::SetConsumeOkMethodFields<'a> for ConsumeOk<'a>
    impl<'a> ::method::basic::DeliverMethod<'a> for ::Amqp8_0 {
        type Payload = Deliver<'a>;
    } // impl<'a> ::method::basic::DeliverMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Deliver<'a> {
        consumer_tag: ::std::borrow::Cow<'a, str>,
        delivery_tag: u64,
        redelivered: bool,
        exchange: ::std::borrow::Cow<'a, str>,
        routing_key: ::std::borrow::Cow<'a, str>,
    } // struct Deliver<'a>

    impl<'a> Deliver<'a> {
        pub fn new<C, E, R>(consumer_tag: C,
                            delivery_tag: u64,
                            redelivered: bool,
                            exchange: E,
                            routing_key: R)
                            -> Self
            where C: Into<::std::borrow::Cow<'a, str>>,
                  E: Into<::std::borrow::Cow<'a, str>>,
                  R: Into<::std::borrow::Cow<'a, str>>
        {
            Deliver {
                consumer_tag: consumer_tag.into(),
                delivery_tag: delivery_tag,
                redelivered: redelivered,
                exchange: exchange.into(),
                routing_key: routing_key.into(),
            } // Deliver
        } // fn new()
        impl_properties! {
(consumer_tag, consumer_tag_mut, set_consumer_tag) -> Cow<str>,
(delivery_tag, set_delivery_tag) -> u64,
(redelivered, set_redelivered) -> bool,
(exchange, exchange_mut, set_exchange) -> Cow<str>,
(routing_key, routing_key_mut, set_routing_key) -> Cow<str>,
} // impl_properties
    } // impl<'a> Deliver<'a>
    impl<'a> Default for Deliver<'a> {
        fn default() -> Self {
            Deliver::new("", 0, false, "", "")
        } // fn default()
    } // impl Default for Deliver

    impl<'a> ::Encodable for Deliver<'a> {
        fn encoded_size(&self) -> usize {
            [12,
             ::Encodable::encoded_size(&self.consumer_tag),
             ::Encodable::encoded_size(&self.exchange),
             ::Encodable::encoded_size(&self.routing_key)]
                .iter()
                .sum()
        } // fn encoded_size()
    } // impl Encodable

    impl<'a> ::ProtocolMethodPayload for Deliver<'a> {
        fn class_id(&self) -> u16 {
            60
        } // fn class_id()
        fn method_id(&self) -> u16 {
            60
        } // fn method_id()
    } // impl ::Payload for Deliver
    impl<'a> ::method::basic::SetDeliverMethodFields<'a> for Deliver<'a> {
        fn set_consumer_tag<V>(&mut self, consumer_tag: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_consumer_tag(consumer_tag.into())
        } // set_consumer_tag()
        fn set_delivery_tag(&mut self, delivery_tag: u64) {
            self.set_delivery_tag(delivery_tag)
        } // set_delivery_tag()
        fn set_redelivered(&mut self, redelivered: bool) {
            self.set_redelivered(redelivered)
        } // set_redelivered()
        fn set_exchange<V>(&mut self, exchange: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_exchange(exchange.into())
        } // set_exchange()
        fn set_routing_key<V>(&mut self, routing_key: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_routing_key(routing_key.into())
        } // set_routing_key()
    } // impl<'a> ::method::basic::SetDeliverMethodFields<'a> for Deliver<'a>
    impl<'a> ::method::basic::GetMethod<'a> for ::Amqp8_0 {
        type Payload = Get<'a>;
    } // impl<'a> ::method::basic::GetMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Get<'a> {
        ticket: u16,
        queue: ::std::borrow::Cow<'a, str>,
        no_ack: bool,
    } // struct Get<'a>

    impl<'a> Get<'a> {
        pub fn new<Q>(ticket: u16, queue: Q, no_ack: bool) -> Self
            where Q: Into<::std::borrow::Cow<'a, str>>
        {
            Get {
                ticket: ticket,
                queue: queue.into(),
                no_ack: no_ack,
            } // Get
        } // fn new()
        impl_properties! {
(ticket, set_ticket) -> u16,
(queue, queue_mut, set_queue) -> Cow<str>,
(no_ack, set_no_ack) -> bool,
} // impl_properties
    } // impl<'a> Get<'a>
    impl<'a> Default for Get<'a> {
        fn default() -> Self {
            Get::new(0, "", false)
        } // fn default()
    } // impl Default for Get

    impl<'a> ::Encodable for Get<'a> {
        fn encoded_size(&self) -> usize {
            [4, ::Encodable::encoded_size(&self.queue)]
                .iter()
                .sum()
        } // fn encoded_size()
    } // impl Encodable

    impl<'a> ::ProtocolMethodPayload for Get<'a> {
        fn class_id(&self) -> u16 {
            60
        } // fn class_id()
        fn method_id(&self) -> u16 {
            70
        } // fn method_id()
    } // impl ::Payload for Get
    impl<'a> ::method::basic::SetGetMethodFields<'a> for Get<'a> {
        fn set_ticket(&mut self, ticket: u16) {
            self.set_ticket(ticket)
        } // set_ticket()
        fn set_queue<V>(&mut self, queue: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_queue(queue.into())
        } // set_queue()
        fn set_no_ack(&mut self, no_ack: bool) {
            self.set_no_ack(no_ack)
        } // set_no_ack()
    } // impl<'a> ::method::basic::SetGetMethodFields<'a> for Get<'a>
    impl<'a> ::method::basic::GetEmptyMethod<'a> for ::Amqp8_0 {
        type Payload = GetEmpty<'a>;
    } // impl<'a> ::method::basic::GetEmptyMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct GetEmpty<'a> {
        cluster_id: ::std::borrow::Cow<'a, str>,
    } // struct GetEmpty<'a>

    impl<'a> GetEmpty<'a> {
        pub fn new<C>(cluster_id: C) -> Self
            where C: Into<::std::borrow::Cow<'a, str>>
        {
            GetEmpty { cluster_id: cluster_id.into() } // GetEmpty
        } // fn new()
        impl_properties! {
(cluster_id, cluster_id_mut, set_cluster_id) -> Cow<str>,
} // impl_properties
    } // impl<'a> GetEmpty<'a>
    impl<'a> Default for GetEmpty<'a> {
        fn default() -> Self {
            GetEmpty::new("")
        } // fn default()
    } // impl Default for GetEmpty

    impl<'a> ::Encodable for GetEmpty<'a> {
        fn encoded_size(&self) -> usize {
            [1, ::Encodable::encoded_size(&self.cluster_id)]
                .iter()
                .sum()
        } // fn encoded_size()
    } // impl Encodable

    impl<'a> ::ProtocolMethodPayload for GetEmpty<'a> {
        fn class_id(&self) -> u16 {
            60
        } // fn class_id()
        fn method_id(&self) -> u16 {
            72
        } // fn method_id()
    } // impl ::Payload for GetEmpty
    impl<'a> ::method::basic::SetGetEmptyMethodFields<'a> for GetEmpty<'a> {
        fn set_cluster_id<V>(&mut self, cluster_id: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_cluster_id(cluster_id.into())
        } // set_cluster_id()
    } // impl<'a> ::method::basic::SetGetEmptyMethodFields<'a> for GetEmpty<'a>
    impl<'a> ::method::basic::GetOkMethod<'a> for ::Amqp8_0 {
        type Payload = GetOk<'a>;
    } // impl<'a> ::method::basic::GetOkMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct GetOk<'a> {
        delivery_tag: u64,
        redelivered: bool,
        exchange: ::std::borrow::Cow<'a, str>,
        routing_key: ::std::borrow::Cow<'a, str>,
        message_count: u32,
    } // struct GetOk<'a>

    impl<'a> GetOk<'a> {
        pub fn new<E, R>(delivery_tag: u64,
                         redelivered: bool,
                         exchange: E,
                         routing_key: R,
                         message_count: u32)
                         -> Self
            where E: Into<::std::borrow::Cow<'a, str>>,
                  R: Into<::std::borrow::Cow<'a, str>>
        {
            GetOk {
                delivery_tag: delivery_tag,
                redelivered: redelivered,
                exchange: exchange.into(),
                routing_key: routing_key.into(),
                message_count: message_count,
            } // GetOk
        } // fn new()
        impl_properties! {
(delivery_tag, set_delivery_tag) -> u64,
(redelivered, set_redelivered) -> bool,
(exchange, exchange_mut, set_exchange) -> Cow<str>,
(routing_key, routing_key_mut, set_routing_key) -> Cow<str>,
(message_count, set_message_count) -> u32,
} // impl_properties
    } // impl<'a> GetOk<'a>
    impl<'a> Default for GetOk<'a> {
        fn default() -> Self {
            GetOk::new(0, false, "", "", 0)
        } // fn default()
    } // impl Default for GetOk

    impl<'a> ::Encodable for GetOk<'a> {
        fn encoded_size(&self) -> usize {
            [15,
             ::Encodable::encoded_size(&self.exchange),
             ::Encodable::encoded_size(&self.routing_key)]
                .iter()
                .sum()
        } // fn encoded_size()
    } // impl Encodable

    impl<'a> ::ProtocolMethodPayload for GetOk<'a> {
        fn class_id(&self) -> u16 {
            60
        } // fn class_id()
        fn method_id(&self) -> u16 {
            71
        } // fn method_id()
    } // impl ::Payload for GetOk
    impl<'a> ::method::basic::SetGetOkMethodFields<'a> for GetOk<'a> {
        fn set_delivery_tag(&mut self, delivery_tag: u64) {
            self.set_delivery_tag(delivery_tag)
        } // set_delivery_tag()
        fn set_redelivered(&mut self, redelivered: bool) {
            self.set_redelivered(redelivered)
        } // set_redelivered()
        fn set_exchange<V>(&mut self, exchange: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_exchange(exchange.into())
        } // set_exchange()
        fn set_routing_key<V>(&mut self, routing_key: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_routing_key(routing_key.into())
        } // set_routing_key()
        fn set_message_count(&mut self, message_count: u32) {
            self.set_message_count(message_count)
        } // set_message_count()
    } // impl<'a> ::method::basic::SetGetOkMethodFields<'a> for GetOk<'a>
    impl<'a> ::method::basic::PublishMethod<'a> for ::Amqp8_0 {
        type Payload = Publish<'a>;
    } // impl<'a> ::method::basic::PublishMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Publish<'a> {
        ticket: u16,
        exchange: ::std::borrow::Cow<'a, str>,
        routing_key: ::std::borrow::Cow<'a, str>,
        mandatory: bool,
        immediate: bool,
    } // struct Publish<'a>

    impl<'a> Publish<'a> {
        pub fn new<E, R>(ticket: u16,
                         exchange: E,
                         routing_key: R,
                         mandatory: bool,
                         immediate: bool)
                         -> Self
            where E: Into<::std::borrow::Cow<'a, str>>,
                  R: Into<::std::borrow::Cow<'a, str>>
        {
            Publish {
                ticket: ticket,
                exchange: exchange.into(),
                routing_key: routing_key.into(),
                mandatory: mandatory,
                immediate: immediate,
            } // Publish
        } // fn new()
        impl_properties! {
(ticket, set_ticket) -> u16,
(exchange, exchange_mut, set_exchange) -> Cow<str>,
(routing_key, routing_key_mut, set_routing_key) -> Cow<str>,
(mandatory, set_mandatory) -> bool,
(immediate, set_immediate) -> bool,
} // impl_properties
    } // impl<'a> Publish<'a>
    impl<'a> Default for Publish<'a> {
        fn default() -> Self {
            Publish::new(0, "", "", false, false)
        } // fn default()
    } // impl Default for Publish

    impl<'a> ::Encodable for Publish<'a> {
        fn encoded_size(&self) -> usize {
            [5,
             ::Encodable::encoded_size(&self.exchange),
             ::Encodable::encoded_size(&self.routing_key)]
                .iter()
                .sum()
        } // fn encoded_size()
    } // impl Encodable

    impl<'a> ::ProtocolMethodPayload for Publish<'a> {
        fn class_id(&self) -> u16 {
            60
        } // fn class_id()
        fn method_id(&self) -> u16 {
            40
        } // fn method_id()
    } // impl ::Payload for Publish
    impl<'a> ::method::basic::SetPublishMethodFields<'a> for Publish<'a> {
        fn set_ticket(&mut self, ticket: u16) {
            self.set_ticket(ticket)
        } // set_ticket()
        fn set_exchange<V>(&mut self, exchange: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_exchange(exchange.into())
        } // set_exchange()
        fn set_routing_key<V>(&mut self, routing_key: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_routing_key(routing_key.into())
        } // set_routing_key()
        fn set_mandatory(&mut self, mandatory: bool) {
            self.set_mandatory(mandatory)
        } // set_mandatory()
        fn set_immediate(&mut self, immediate: bool) {
            self.set_immediate(immediate)
        } // set_immediate()
    } // impl<'a> ::method::basic::SetPublishMethodFields<'a> for Publish<'a>
    impl ::method::basic::QosMethod for ::Amqp8_0 {
        type Payload = Qos;
    } // impl ::method::basic::QosMethod for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Qos {
        prefetch_size: u32,
        prefetch_count: u16,
        global: bool,
    } // struct Qos

    impl Qos {
        pub fn new(prefetch_size: u32, prefetch_count: u16, global: bool) -> Self {
            Qos {
                prefetch_size: prefetch_size,
                prefetch_count: prefetch_count,
                global: global,
            } // Qos
        } // fn new()
        impl_properties! {
(prefetch_size, set_prefetch_size) -> u32,
(prefetch_count, set_prefetch_count) -> u16,
(global, set_global) -> bool,
} // impl_properties
    } // impl Qos
    impl Default for Qos {
        fn default() -> Self {
            Qos::new(0, 0, false)
        } // fn default()
    } // impl Default for Qos

    impl ::Encodable for Qos {
        fn encoded_size(&self) -> usize {
            7
        } // fn encoded_size()
    } // impl Encodable

    impl ::ProtocolMethodPayload for Qos {
        fn class_id(&self) -> u16 {
            60
        } // fn class_id()
        fn method_id(&self) -> u16 {
            10
        } // fn method_id()
    } // impl ::Payload for Qos
    impl ::method::basic::SetQosMethodFields for Qos {
        fn set_prefetch_size(&mut self, prefetch_size: u32) {
            self.set_prefetch_size(prefetch_size)
        } // set_prefetch_size()
        fn set_prefetch_count(&mut self, prefetch_count: u16) {
            self.set_prefetch_count(prefetch_count)
        } // set_prefetch_count()
        fn set_global(&mut self, global: bool) {
            self.set_global(global)
        } // set_global()
    } // impl ::method::basic::SetQosMethodFields for Qos
    impl ::method::basic::QosOkMethod for ::Amqp8_0 {
        type Payload = QosOk;
    } // impl ::method::basic::QosOkMethod for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct QosOk;

    impl QosOk {
        pub fn new() -> Self {
            QosOk
        } // fn new()
    } // impl QosOk
    impl Default for QosOk {
        fn default() -> Self {
            QosOk::new()
        } // fn default()
    } // impl Default for QosOk

    impl ::Encodable for QosOk {
        fn encoded_size(&self) -> usize {
            0
        } // fn encoded_size()
    } // impl Encodable

    impl ::ProtocolMethodPayload for QosOk {
        fn class_id(&self) -> u16 {
            60
        } // fn class_id()
        fn method_id(&self) -> u16 {
            11
        } // fn method_id()
    } // impl ::Payload for QosOk
    impl ::method::basic::RecoverMethod for ::Amqp8_0 {
        type Payload = Recover;
    } // impl ::method::basic::RecoverMethod for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Recover {
        requeue: bool,
    } // struct Recover

    impl Recover {
        pub fn new(requeue: bool) -> Self {
            Recover { requeue: requeue } // Recover
        } // fn new()
        impl_properties! {
(requeue, set_requeue) -> bool,
} // impl_properties
    } // impl Recover
    impl Default for Recover {
        fn default() -> Self {
            Recover::new(false)
        } // fn default()
    } // impl Default for Recover

    impl ::Encodable for Recover {
        fn encoded_size(&self) -> usize {
            1
        } // fn encoded_size()
    } // impl Encodable

    impl ::ProtocolMethodPayload for Recover {
        fn class_id(&self) -> u16 {
            60
        } // fn class_id()
        fn method_id(&self) -> u16 {
            100
        } // fn method_id()
    } // impl ::Payload for Recover
    impl ::method::basic::SetRecoverMethodFields for Recover {
        fn set_requeue(&mut self, requeue: bool) {
            self.set_requeue(requeue)
        } // set_requeue()
    } // impl ::method::basic::SetRecoverMethodFields for Recover
    impl ::method::basic::RejectMethod for ::Amqp8_0 {
        type Payload = Reject;
    } // impl ::method::basic::RejectMethod for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Reject {
        delivery_tag: u64,
        requeue: bool,
    } // struct Reject

    impl Reject {
        pub fn new(delivery_tag: u64, requeue: bool) -> Self {
            Reject {
                delivery_tag: delivery_tag,
                requeue: requeue,
            } // Reject
        } // fn new()
        impl_properties! {
(delivery_tag, set_delivery_tag) -> u64,
(requeue, set_requeue) -> bool,
} // impl_properties
    } // impl Reject
    impl Default for Reject {
        fn default() -> Self {
            Reject::new(0, false)
        } // fn default()
    } // impl Default for Reject

    impl ::Encodable for Reject {
        fn encoded_size(&self) -> usize {
            9
        } // fn encoded_size()
    } // impl Encodable

    impl ::ProtocolMethodPayload for Reject {
        fn class_id(&self) -> u16 {
            60
        } // fn class_id()
        fn method_id(&self) -> u16 {
            90
        } // fn method_id()
    } // impl ::Payload for Reject
    impl ::method::basic::SetRejectMethodFields for Reject {
        fn set_delivery_tag(&mut self, delivery_tag: u64) {
            self.set_delivery_tag(delivery_tag)
        } // set_delivery_tag()
        fn set_requeue(&mut self, requeue: bool) {
            self.set_requeue(requeue)
        } // set_requeue()
    } // impl ::method::basic::SetRejectMethodFields for Reject
    impl<'a> ::method::basic::ReturnMethod<'a> for ::Amqp8_0 {
        type Payload = Return<'a>;
    } // impl<'a> ::method::basic::ReturnMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Return<'a> {
        reply_code: u16,
        reply_text: ::std::borrow::Cow<'a, str>,
        exchange: ::std::borrow::Cow<'a, str>,
        routing_key: ::std::borrow::Cow<'a, str>,
    } // struct Return<'a>

    impl<'a> Return<'a> {
        pub fn new<R, E, R0>(reply_code: u16, reply_text: R, exchange: E, routing_key: R0) -> Self
            where R: Into<::std::borrow::Cow<'a, str>>,
                  E: Into<::std::borrow::Cow<'a, str>>,
                  R0: Into<::std::borrow::Cow<'a, str>>
        {
            Return {
                reply_code: reply_code,
                reply_text: reply_text.into(),
                exchange: exchange.into(),
                routing_key: routing_key.into(),
            } // Return
        } // fn new()
        impl_properties! {
(reply_code, set_reply_code) -> u16,
(reply_text, reply_text_mut, set_reply_text) -> Cow<str>,
(exchange, exchange_mut, set_exchange) -> Cow<str>,
(routing_key, routing_key_mut, set_routing_key) -> Cow<str>,
} // impl_properties
    } // impl<'a> Return<'a>
    impl<'a> Default for Return<'a> {
        fn default() -> Self {
            Return::new(0, "", "", "")
        } // fn default()
    } // impl Default for Return

    impl<'a> ::Encodable for Return<'a> {
        fn encoded_size(&self) -> usize {
            [5,
             ::Encodable::encoded_size(&self.reply_text),
             ::Encodable::encoded_size(&self.exchange),
             ::Encodable::encoded_size(&self.routing_key)]
                .iter()
                .sum()
        } // fn encoded_size()
    } // impl Encodable

    impl<'a> ::ProtocolMethodPayload for Return<'a> {
        fn class_id(&self) -> u16 {
            60
        } // fn class_id()
        fn method_id(&self) -> u16 {
            50
        } // fn method_id()
    } // impl ::Payload for Return
    impl<'a> ::method::basic::SetReturnMethodFields<'a> for Return<'a> {
        fn set_reply_code(&mut self, reply_code: u16) {
            self.set_reply_code(reply_code)
        } // set_reply_code()
        fn set_reply_text<V>(&mut self, reply_text: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_reply_text(reply_text.into())
        } // set_reply_text()
        fn set_exchange<V>(&mut self, exchange: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_exchange(exchange.into())
        } // set_exchange()
        fn set_routing_key<V>(&mut self, routing_key: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_routing_key(routing_key.into())
        } // set_routing_key()
    } // impl<'a> ::method::basic::SetReturnMethodFields<'a> for Return<'a>

    #[derive(Debug)]
    pub enum ClassMethod<'a> {
        Ack(Ack),
        Cancel(Cancel<'a>),
        CancelOk(CancelOk<'a>),
        Consume(Consume<'a>),
        ConsumeOk(ConsumeOk<'a>),
        Deliver(Deliver<'a>),
        Get(Get<'a>),
        GetEmpty(GetEmpty<'a>),
        GetOk(GetOk<'a>),
        Publish(Publish<'a>),
        Qos(Qos),
        QosOk(QosOk),
        Recover(Recover),
        Reject(Reject),
        Return(Return<'a>),
    } // enum ClassMethod


    impl<'a> ::Encodable for ClassMethod<'a> {
        fn encoded_size(&self) -> usize {
            match *self {
                ClassMethod::Ack(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::Cancel(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::CancelOk(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::Consume(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::ConsumeOk(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::Deliver(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::Get(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::GetEmpty(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::GetOk(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::Publish(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::Qos(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::QosOk(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::Recover(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::Reject(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::Return(ref method) => ::Encodable::encoded_size(method),

            } // match *self

        } // fn encoded_size
    } // impl ::Encodable for ClassMethod<'a>

    impl<'a> ::ProtocolMethodPayload for ClassMethod<'a> {
        fn class_id(&self) -> u16 {
            match *self {
                ClassMethod::Ack(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::Cancel(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::CancelOk(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::Consume(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::ConsumeOk(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::Deliver(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::Get(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::GetEmpty(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::GetOk(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::Publish(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::Qos(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::QosOk(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::Recover(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::Reject(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::Return(ref method) => ::ProtocolMethodPayload::class_id(method),

            } // match *self

        } // fn class_id

        fn method_id(&self) -> u16 {
            match *self {
                ClassMethod::Ack(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::Cancel(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::CancelOk(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::Consume(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::ConsumeOk(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::Deliver(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::Get(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::GetEmpty(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::GetOk(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::Publish(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::Qos(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::QosOk(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::Recover(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::Reject(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::Return(ref method) => ::ProtocolMethodPayload::method_id(method),

            } // match *self

        } // fn method_id
    } // impl ProtocolMethodPayload for ClassMethod
} // mod basic

// generated by primalgen::codegen::spec_module::class_mod::ClassModuleWriter
pub mod channel {
    impl<'a> ::method::channel::AlertMethod<'a> for ::Amqp8_0 {
        type Payload = Alert<'a>;
    } // impl<'a> ::method::channel::AlertMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Alert<'a> {
        reply_code: u16,
        reply_text: ::std::borrow::Cow<'a, str>,
        details: ::field::TableEntries<'a>,
    } // struct Alert<'a>

    impl<'a> Alert<'a> {
        pub fn new<R, D>(reply_code: u16, reply_text: R, details: D) -> Self
            where R: Into<::std::borrow::Cow<'a, str>>,
                  D: Into<::field::TableEntries<'a>>
        {
            Alert {
                reply_code: reply_code,
                reply_text: reply_text.into(),
                details: details.into(),
            } // Alert
        } // fn new()
        impl_properties! {
(reply_code, set_reply_code) -> u16,
(reply_text, reply_text_mut, set_reply_text) -> Cow<str>,
(details, details_mut, set_details) -> &::field::TableEntries<'a>,
} // impl_properties
    } // impl<'a> Alert<'a>
    impl<'a> Default for Alert<'a> {
        fn default() -> Self {
            Alert::new(0, "", ::field::TableEntries::new())
        } // fn default()
    } // impl Default for Alert

    impl<'a> ::Encodable for Alert<'a> {
        fn encoded_size(&self) -> usize {
            [3,
             ::Encodable::encoded_size(&self.reply_text),
             ::Encodable::encoded_size(&self.details)]
                .iter()
                .sum()
        } // fn encoded_size()
    } // impl Encodable

    impl<'a> ::ProtocolMethodPayload for Alert<'a> {
        fn class_id(&self) -> u16 {
            20
        } // fn class_id()
        fn method_id(&self) -> u16 {
            30
        } // fn method_id()
    } // impl ::Payload for Alert
    impl<'a> ::method::channel::SetAlertMethodFields<'a> for Alert<'a> {
        fn set_reply_code(&mut self, reply_code: u16) {
            self.set_reply_code(reply_code)
        } // set_reply_code()
        fn set_reply_text<V>(&mut self, reply_text: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_reply_text(reply_text.into())
        } // set_reply_text()
        fn set_details<V>(&mut self, details: V)
            where V: Into<::field::TableEntries<'a>>
        {
            self.set_details(details.into())
        } // set_details()
    } // impl<'a> ::method::channel::SetAlertMethodFields<'a> for Alert<'a>
    impl<'a> ::method::channel::CloseMethod<'a> for ::Amqp8_0 {
        type Payload = Close<'a>;
    } // impl<'a> ::method::channel::CloseMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Close<'a> {
        reply_code: u16,
        reply_text: ::std::borrow::Cow<'a, str>,
        class_id: u16,
        method_id: u16,
    } // struct Close<'a>

    impl<'a> Close<'a> {
        pub fn new<R>(reply_code: u16, reply_text: R, class_id: u16, method_id: u16) -> Self
            where R: Into<::std::borrow::Cow<'a, str>>
        {
            Close {
                reply_code: reply_code,
                reply_text: reply_text.into(),
                class_id: class_id,
                method_id: method_id,
            } // Close
        } // fn new()
        impl_properties! {
(reply_code, set_reply_code) -> u16,
(reply_text, reply_text_mut, set_reply_text) -> Cow<str>,
(class_id, set_class_id) -> u16,
(method_id, set_method_id) -> u16,
} // impl_properties
    } // impl<'a> Close<'a>
    impl<'a> Default for Close<'a> {
        fn default() -> Self {
            Close::new(0, "", 0, 0)
        } // fn default()
    } // impl Default for Close

    impl<'a> ::Encodable for Close<'a> {
        fn encoded_size(&self) -> usize {
            [7, ::Encodable::encoded_size(&self.reply_text)]
                .iter()
                .sum()
        } // fn encoded_size()
    } // impl Encodable

    impl<'a> ::ProtocolMethodPayload for Close<'a> {
        fn class_id(&self) -> u16 {
            20
        } // fn class_id()
        fn method_id(&self) -> u16 {
            40
        } // fn method_id()
    } // impl ::Payload for Close
    impl<'a> ::method::channel::SetCloseMethodFields<'a> for Close<'a> {
        fn set_reply_code(&mut self, reply_code: u16) {
            self.set_reply_code(reply_code)
        } // set_reply_code()
        fn set_reply_text<V>(&mut self, reply_text: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_reply_text(reply_text.into())
        } // set_reply_text()
        fn set_class_id(&mut self, class_id: u16) {
            self.set_class_id(class_id)
        } // set_class_id()
        fn set_method_id(&mut self, method_id: u16) {
            self.set_method_id(method_id)
        } // set_method_id()
    } // impl<'a> ::method::channel::SetCloseMethodFields<'a> for Close<'a>
    impl ::method::channel::CloseOkMethod for ::Amqp8_0 {
        type Payload = CloseOk;
    } // impl ::method::channel::CloseOkMethod for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct CloseOk;

    impl CloseOk {
        pub fn new() -> Self {
            CloseOk
        } // fn new()
    } // impl CloseOk
    impl Default for CloseOk {
        fn default() -> Self {
            CloseOk::new()
        } // fn default()
    } // impl Default for CloseOk

    impl ::Encodable for CloseOk {
        fn encoded_size(&self) -> usize {
            0
        } // fn encoded_size()
    } // impl Encodable

    impl ::ProtocolMethodPayload for CloseOk {
        fn class_id(&self) -> u16 {
            20
        } // fn class_id()
        fn method_id(&self) -> u16 {
            41
        } // fn method_id()
    } // impl ::Payload for CloseOk
    impl ::method::channel::FlowMethod for ::Amqp8_0 {
        type Payload = Flow;
    } // impl ::method::channel::FlowMethod for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Flow {
        active: bool,
    } // struct Flow

    impl Flow {
        pub fn new(active: bool) -> Self {
            Flow { active: active } // Flow
        } // fn new()
        impl_properties! {
(active, set_active) -> bool,
} // impl_properties
    } // impl Flow
    impl Default for Flow {
        fn default() -> Self {
            Flow::new(false)
        } // fn default()
    } // impl Default for Flow

    impl ::Encodable for Flow {
        fn encoded_size(&self) -> usize {
            1
        } // fn encoded_size()
    } // impl Encodable

    impl ::ProtocolMethodPayload for Flow {
        fn class_id(&self) -> u16 {
            20
        } // fn class_id()
        fn method_id(&self) -> u16 {
            20
        } // fn method_id()
    } // impl ::Payload for Flow
    impl ::method::channel::SetFlowMethodFields for Flow {
        fn set_active(&mut self, active: bool) {
            self.set_active(active)
        } // set_active()
    } // impl ::method::channel::SetFlowMethodFields for Flow
    impl ::method::channel::FlowOkMethod for ::Amqp8_0 {
        type Payload = FlowOk;
    } // impl ::method::channel::FlowOkMethod for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct FlowOk {
        active: bool,
    } // struct FlowOk

    impl FlowOk {
        pub fn new(active: bool) -> Self {
            FlowOk { active: active } // FlowOk
        } // fn new()
        impl_properties! {
(active, set_active) -> bool,
} // impl_properties
    } // impl FlowOk
    impl Default for FlowOk {
        fn default() -> Self {
            FlowOk::new(false)
        } // fn default()
    } // impl Default for FlowOk

    impl ::Encodable for FlowOk {
        fn encoded_size(&self) -> usize {
            1
        } // fn encoded_size()
    } // impl Encodable

    impl ::ProtocolMethodPayload for FlowOk {
        fn class_id(&self) -> u16 {
            20
        } // fn class_id()
        fn method_id(&self) -> u16 {
            21
        } // fn method_id()
    } // impl ::Payload for FlowOk
    impl ::method::channel::SetFlowOkMethodFields for FlowOk {
        fn set_active(&mut self, active: bool) {
            self.set_active(active)
        } // set_active()
    } // impl ::method::channel::SetFlowOkMethodFields for FlowOk
    impl<'a> ::method::channel::OpenMethod<'a> for ::Amqp8_0 {
        type Payload = Open<'a>;
    } // impl<'a> ::method::channel::OpenMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Open<'a> {
        out_of_band: ::std::borrow::Cow<'a, str>,
    } // struct Open<'a>

    impl<'a> Open<'a> {
        pub fn new<O>(out_of_band: O) -> Self
            where O: Into<::std::borrow::Cow<'a, str>>
        {
            Open { out_of_band: out_of_band.into() } // Open
        } // fn new()
        impl_properties! {
(out_of_band, out_of_band_mut, set_out_of_band) -> Cow<str>,
} // impl_properties
    } // impl<'a> Open<'a>
    impl<'a> Default for Open<'a> {
        fn default() -> Self {
            Open::new("")
        } // fn default()
    } // impl Default for Open

    impl<'a> ::Encodable for Open<'a> {
        fn encoded_size(&self) -> usize {
            [1, ::Encodable::encoded_size(&self.out_of_band)]
                .iter()
                .sum()
        } // fn encoded_size()
    } // impl Encodable

    impl<'a> ::ProtocolMethodPayload for Open<'a> {
        fn class_id(&self) -> u16 {
            20
        } // fn class_id()
        fn method_id(&self) -> u16 {
            10
        } // fn method_id()
    } // impl ::Payload for Open
    impl<'a> ::method::channel::SetOpenMethodFields<'a> for Open<'a> {
        fn set_out_of_band<V>(&mut self, out_of_band: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_out_of_band(out_of_band.into())
        } // set_out_of_band()
    } // impl<'a> ::method::channel::SetOpenMethodFields<'a> for Open<'a>
    impl<'a> ::method::channel::OpenOkMethod<'a> for ::Amqp8_0 {
        type Payload = OpenOk;
    } // impl<'a> ::method::channel::OpenOkMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct OpenOk;

    impl OpenOk {
        pub fn new() -> Self {
            OpenOk
        } // fn new()
    } // impl OpenOk
    impl Default for OpenOk {
        fn default() -> Self {
            OpenOk::new()
        } // fn default()
    } // impl Default for OpenOk

    impl ::Encodable for OpenOk {
        fn encoded_size(&self) -> usize {
            0
        } // fn encoded_size()
    } // impl Encodable

    impl ::ProtocolMethodPayload for OpenOk {
        fn class_id(&self) -> u16 {
            20
        } // fn class_id()
        fn method_id(&self) -> u16 {
            11
        } // fn method_id()
    } // impl ::Payload for OpenOk
    impl<'a> ::method::channel::SetOpenOkMethodFields<'a> for OpenOk {} // impl<'a> ::method::channel::SetOpenOkMethodFields<'a> for OpenOk

    #[derive(Debug)]
    pub enum ClassMethod<'a> {
        Alert(Alert<'a>),
        Close(Close<'a>),
        CloseOk(CloseOk),
        Flow(Flow),
        FlowOk(FlowOk),
        Open(Open<'a>),
        OpenOk(OpenOk),
    } // enum ClassMethod


    impl<'a> ::Encodable for ClassMethod<'a> {
        fn encoded_size(&self) -> usize {
            match *self {
                ClassMethod::Alert(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::Close(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::CloseOk(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::Flow(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::FlowOk(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::Open(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::OpenOk(ref method) => ::Encodable::encoded_size(method),

            } // match *self

        } // fn encoded_size
    } // impl ::Encodable for ClassMethod<'a>

    impl<'a> ::ProtocolMethodPayload for ClassMethod<'a> {
        fn class_id(&self) -> u16 {
            match *self {
                ClassMethod::Alert(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::Close(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::CloseOk(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::Flow(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::FlowOk(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::Open(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::OpenOk(ref method) => ::ProtocolMethodPayload::class_id(method),

            } // match *self

        } // fn class_id

        fn method_id(&self) -> u16 {
            match *self {
                ClassMethod::Alert(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::Close(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::CloseOk(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::Flow(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::FlowOk(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::Open(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::OpenOk(ref method) => ::ProtocolMethodPayload::method_id(method),

            } // match *self

        } // fn method_id
    } // impl ProtocolMethodPayload for ClassMethod
} // mod channel

// generated by primalgen::codegen::spec_module::class_mod::ClassModuleWriter
pub mod connection {
    impl<'a> ::method::connection::CloseMethod<'a> for ::Amqp8_0 {
        type Payload = Close<'a>;
    } // impl<'a> ::method::connection::CloseMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Close<'a> {
        reply_code: u16,
        reply_text: ::std::borrow::Cow<'a, str>,
        class_id: u16,
        method_id: u16,
    } // struct Close<'a>

    impl<'a> Close<'a> {
        pub fn new<R>(reply_code: u16, reply_text: R, class_id: u16, method_id: u16) -> Self
            where R: Into<::std::borrow::Cow<'a, str>>
        {
            Close {
                reply_code: reply_code,
                reply_text: reply_text.into(),
                class_id: class_id,
                method_id: method_id,
            } // Close
        } // fn new()
        impl_properties! {
(reply_code, set_reply_code) -> u16,
(reply_text, reply_text_mut, set_reply_text) -> Cow<str>,
(class_id, set_class_id) -> u16,
(method_id, set_method_id) -> u16,
} // impl_properties
    } // impl<'a> Close<'a>
    impl<'a> Default for Close<'a> {
        fn default() -> Self {
            Close::new(0, "", 0, 0)
        } // fn default()
    } // impl Default for Close

    impl<'a> ::Encodable for Close<'a> {
        fn encoded_size(&self) -> usize {
            [7, ::Encodable::encoded_size(&self.reply_text)]
                .iter()
                .sum()
        } // fn encoded_size()
    } // impl Encodable

    impl<'a> ::ProtocolMethodPayload for Close<'a> {
        fn class_id(&self) -> u16 {
            10
        } // fn class_id()
        fn method_id(&self) -> u16 {
            60
        } // fn method_id()
    } // impl ::Payload for Close
    impl<'a> ::method::connection::SetCloseMethodFields<'a> for Close<'a> {
        fn set_reply_code(&mut self, reply_code: u16) {
            self.set_reply_code(reply_code)
        } // set_reply_code()
        fn set_reply_text<V>(&mut self, reply_text: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_reply_text(reply_text.into())
        } // set_reply_text()
        fn set_class_id(&mut self, class_id: u16) {
            self.set_class_id(class_id)
        } // set_class_id()
        fn set_method_id(&mut self, method_id: u16) {
            self.set_method_id(method_id)
        } // set_method_id()
    } // impl<'a> ::method::connection::SetCloseMethodFields<'a> for Close<'a>
    impl ::method::connection::CloseOkMethod for ::Amqp8_0 {
        type Payload = CloseOk;
    } // impl ::method::connection::CloseOkMethod for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct CloseOk;

    impl CloseOk {
        pub fn new() -> Self {
            CloseOk
        } // fn new()
    } // impl CloseOk
    impl Default for CloseOk {
        fn default() -> Self {
            CloseOk::new()
        } // fn default()
    } // impl Default for CloseOk

    impl ::Encodable for CloseOk {
        fn encoded_size(&self) -> usize {
            0
        } // fn encoded_size()
    } // impl Encodable

    impl ::ProtocolMethodPayload for CloseOk {
        fn class_id(&self) -> u16 {
            10
        } // fn class_id()
        fn method_id(&self) -> u16 {
            61
        } // fn method_id()
    } // impl ::Payload for CloseOk
    impl<'a> ::method::connection::OpenMethod<'a> for ::Amqp8_0 {
        type Payload = Open<'a>;
    } // impl<'a> ::method::connection::OpenMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Open<'a> {
        virtual_host: ::std::borrow::Cow<'a, str>,
        capabilities: ::std::borrow::Cow<'a, str>,
        insist: bool,
    } // struct Open<'a>

    impl<'a> Open<'a> {
        pub fn new<V, C>(virtual_host: V, capabilities: C, insist: bool) -> Self
            where V: Into<::std::borrow::Cow<'a, str>>,
                  C: Into<::std::borrow::Cow<'a, str>>
        {
            Open {
                virtual_host: virtual_host.into(),
                capabilities: capabilities.into(),
                insist: insist,
            } // Open
        } // fn new()
        impl_properties! {
(virtual_host, virtual_host_mut, set_virtual_host) -> Cow<str>,
(capabilities, capabilities_mut, set_capabilities) -> Cow<str>,
(insist, set_insist) -> bool,
} // impl_properties
    } // impl<'a> Open<'a>
    impl<'a> Default for Open<'a> {
        fn default() -> Self {
            Open::new("", "", false)
        } // fn default()
    } // impl Default for Open

    impl<'a> ::Encodable for Open<'a> {
        fn encoded_size(&self) -> usize {
            [3,
             ::Encodable::encoded_size(&self.virtual_host),
             ::Encodable::encoded_size(&self.capabilities)]
                .iter()
                .sum()
        } // fn encoded_size()
    } // impl Encodable

    impl<'a> ::ProtocolMethodPayload for Open<'a> {
        fn class_id(&self) -> u16 {
            10
        } // fn class_id()
        fn method_id(&self) -> u16 {
            40
        } // fn method_id()
    } // impl ::Payload for Open
    impl<'a> ::method::connection::SetOpenMethodFields<'a> for Open<'a> {
        fn set_virtual_host<V>(&mut self, virtual_host: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_virtual_host(virtual_host.into())
        } // set_virtual_host()
        fn set_capabilities<V>(&mut self, capabilities: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_capabilities(capabilities.into())
        } // set_capabilities()
        fn set_insist(&mut self, insist: bool) {
            self.set_insist(insist)
        } // set_insist()
    } // impl<'a> ::method::connection::SetOpenMethodFields<'a> for Open<'a>
    impl<'a> ::method::connection::OpenOkMethod<'a> for ::Amqp8_0 {
        type Payload = OpenOk<'a>;
    } // impl<'a> ::method::connection::OpenOkMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct OpenOk<'a> {
        known_hosts: ::std::borrow::Cow<'a, str>,
    } // struct OpenOk<'a>

    impl<'a> OpenOk<'a> {
        pub fn new<K>(known_hosts: K) -> Self
            where K: Into<::std::borrow::Cow<'a, str>>
        {
            OpenOk { known_hosts: known_hosts.into() } // OpenOk
        } // fn new()
        impl_properties! {
(known_hosts, known_hosts_mut, set_known_hosts) -> Cow<str>,
} // impl_properties
    } // impl<'a> OpenOk<'a>
    impl<'a> Default for OpenOk<'a> {
        fn default() -> Self {
            OpenOk::new("")
        } // fn default()
    } // impl Default for OpenOk

    impl<'a> ::Encodable for OpenOk<'a> {
        fn encoded_size(&self) -> usize {
            [1, ::Encodable::encoded_size(&self.known_hosts)]
                .iter()
                .sum()
        } // fn encoded_size()
    } // impl Encodable

    impl<'a> ::ProtocolMethodPayload for OpenOk<'a> {
        fn class_id(&self) -> u16 {
            10
        } // fn class_id()
        fn method_id(&self) -> u16 {
            41
        } // fn method_id()
    } // impl ::Payload for OpenOk
    impl<'a> ::method::connection::SetOpenOkMethodFields<'a> for OpenOk<'a> {
        fn set_known_hosts<V>(&mut self, known_hosts: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_known_hosts(known_hosts.into())
        } // set_known_hosts()
    } // impl<'a> ::method::connection::SetOpenOkMethodFields<'a> for OpenOk<'a>
    impl<'a> ::method::connection::RedirectMethod<'a> for ::Amqp8_0 {
        type Payload = Redirect<'a>;
    } // impl<'a> ::method::connection::RedirectMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Redirect<'a> {
        host: ::std::borrow::Cow<'a, str>,
        known_hosts: ::std::borrow::Cow<'a, str>,
    } // struct Redirect<'a>

    impl<'a> Redirect<'a> {
        pub fn new<H, K>(host: H, known_hosts: K) -> Self
            where H: Into<::std::borrow::Cow<'a, str>>,
                  K: Into<::std::borrow::Cow<'a, str>>
        {
            Redirect {
                host: host.into(),
                known_hosts: known_hosts.into(),
            } // Redirect
        } // fn new()
        impl_properties! {
(host, host_mut, set_host) -> Cow<str>,
(known_hosts, known_hosts_mut, set_known_hosts) -> Cow<str>,
} // impl_properties
    } // impl<'a> Redirect<'a>
    impl<'a> Default for Redirect<'a> {
        fn default() -> Self {
            Redirect::new("", "")
        } // fn default()
    } // impl Default for Redirect

    impl<'a> ::Encodable for Redirect<'a> {
        fn encoded_size(&self) -> usize {
            [2, ::Encodable::encoded_size(&self.host), ::Encodable::encoded_size(&self.known_hosts)]
                .iter()
                .sum()
        } // fn encoded_size()
    } // impl Encodable

    impl<'a> ::ProtocolMethodPayload for Redirect<'a> {
        fn class_id(&self) -> u16 {
            10
        } // fn class_id()
        fn method_id(&self) -> u16 {
            50
        } // fn method_id()
    } // impl ::Payload for Redirect
    impl<'a> ::method::connection::SetRedirectMethodFields<'a> for Redirect<'a> {
        fn set_host<V>(&mut self, host: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_host(host.into())
        } // set_host()
        fn set_known_hosts<V>(&mut self, known_hosts: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_known_hosts(known_hosts.into())
        } // set_known_hosts()
    } // impl<'a> ::method::connection::SetRedirectMethodFields<'a> for Redirect<'a>
    impl<'a> ::method::connection::SecureMethod<'a> for ::Amqp8_0 {
        type Payload = Secure<'a>;
    } // impl<'a> ::method::connection::SecureMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Secure<'a> {
        challenge: ::std::borrow::Cow<'a, [u8]>,
    } // struct Secure<'a>

    impl<'a> Secure<'a> {
        pub fn new<C>(challenge: C) -> Self
            where C: Into<::std::borrow::Cow<'a, [u8]>>
        {
            Secure { challenge: challenge.into() } // Secure
        } // fn new()
        impl_properties! {
(challenge, challenge_mut, set_challenge) -> Cow<[u8]>,
} // impl_properties
    } // impl<'a> Secure<'a>
    impl<'a> Default for Secure<'a> {
        fn default() -> Self {
            Secure::new(&[][..])
        } // fn default()
    } // impl Default for Secure

    impl<'a> ::Encodable for Secure<'a> {
        fn encoded_size(&self) -> usize {
            [2, ::Encodable::encoded_size(&self.challenge)]
                .iter()
                .sum()
        } // fn encoded_size()
    } // impl Encodable

    impl<'a> ::ProtocolMethodPayload for Secure<'a> {
        fn class_id(&self) -> u16 {
            10
        } // fn class_id()
        fn method_id(&self) -> u16 {
            20
        } // fn method_id()
    } // impl ::Payload for Secure
    impl<'a> ::method::connection::SetSecureMethodFields<'a> for Secure<'a> {
        fn set_challenge<V>(&mut self, challenge: V)
            where V: Into<::std::borrow::Cow<'a, [u8]>>
        {
            self.set_challenge(challenge.into())
        } // set_challenge()
    } // impl<'a> ::method::connection::SetSecureMethodFields<'a> for Secure<'a>
    impl<'a> ::method::connection::SecureOkMethod<'a> for ::Amqp8_0 {
        type Payload = SecureOk<'a>;
    } // impl<'a> ::method::connection::SecureOkMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct SecureOk<'a> {
        response: ::std::borrow::Cow<'a, [u8]>,
    } // struct SecureOk<'a>

    impl<'a> SecureOk<'a> {
        pub fn new<R>(response: R) -> Self
            where R: Into<::std::borrow::Cow<'a, [u8]>>
        {
            SecureOk { response: response.into() } // SecureOk
        } // fn new()
        impl_properties! {
(response, response_mut, set_response) -> Cow<[u8]>,
} // impl_properties
    } // impl<'a> SecureOk<'a>
    impl<'a> Default for SecureOk<'a> {
        fn default() -> Self {
            SecureOk::new(&[][..])
        } // fn default()
    } // impl Default for SecureOk

    impl<'a> ::Encodable for SecureOk<'a> {
        fn encoded_size(&self) -> usize {
            [2, ::Encodable::encoded_size(&self.response)]
                .iter()
                .sum()
        } // fn encoded_size()
    } // impl Encodable

    impl<'a> ::ProtocolMethodPayload for SecureOk<'a> {
        fn class_id(&self) -> u16 {
            10
        } // fn class_id()
        fn method_id(&self) -> u16 {
            21
        } // fn method_id()
    } // impl ::Payload for SecureOk
    impl<'a> ::method::connection::SetSecureOkMethodFields<'a> for SecureOk<'a> {
        fn set_response<V>(&mut self, response: V)
            where V: Into<::std::borrow::Cow<'a, [u8]>>
        {
            self.set_response(response.into())
        } // set_response()
    } // impl<'a> ::method::connection::SetSecureOkMethodFields<'a> for SecureOk<'a>
    impl<'a> ::method::connection::StartMethod<'a> for ::Amqp8_0 {
        type Payload = Start<'a>;
    } // impl<'a> ::method::connection::StartMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Start<'a> {
        version_major: u8,
        version_minor: u8,
        server_properties: ::field::TableEntries<'a>,
        mechanisms: ::std::borrow::Cow<'a, [u8]>,
        locales: ::std::borrow::Cow<'a, [u8]>,
    } // struct Start<'a>

    impl<'a> Start<'a> {
        pub fn new<S, M, L>(version_major: u8,
                            version_minor: u8,
                            server_properties: S,
                            mechanisms: M,
                            locales: L)
                            -> Self
            where S: Into<::field::TableEntries<'a>>,
                  M: Into<::std::borrow::Cow<'a, [u8]>>,
                  L: Into<::std::borrow::Cow<'a, [u8]>>
        {
            Start {
                version_major: version_major,
                version_minor: version_minor,
                server_properties: server_properties.into(),
                mechanisms: mechanisms.into(),
                locales: locales.into(),
            } // Start
        } // fn new()
        impl_properties! {
(version_major, set_version_major) -> u8,
(version_minor, set_version_minor) -> u8,
(server_properties, server_properties_mut, set_server_properties) -> &::field::TableEntries<'a>,
(mechanisms, mechanisms_mut, set_mechanisms) -> Cow<[u8]>,
(locales, locales_mut, set_locales) -> Cow<[u8]>,
} // impl_properties
    } // impl<'a> Start<'a>
    impl<'a> Default for Start<'a> {
        fn default() -> Self {
            Start::new(0, 0, ::field::TableEntries::new(), &[][..], &[][..])
        } // fn default()
    } // impl Default for Start

    impl<'a> ::Encodable for Start<'a> {
        fn encoded_size(&self) -> usize {
            [6,
             ::Encodable::encoded_size(&self.server_properties),
             ::Encodable::encoded_size(&self.mechanisms),
             ::Encodable::encoded_size(&self.locales)]
                .iter()
                .sum()
        } // fn encoded_size()
    } // impl Encodable

    impl<'a> ::ProtocolMethodPayload for Start<'a> {
        fn class_id(&self) -> u16 {
            10
        } // fn class_id()
        fn method_id(&self) -> u16 {
            10
        } // fn method_id()
    } // impl ::Payload for Start
    impl<'a> ::method::connection::SetStartMethodFields<'a> for Start<'a> {
        fn set_version_major(&mut self, version_major: u8) {
            self.set_version_major(version_major)
        } // set_version_major()
        fn set_version_minor(&mut self, version_minor: u8) {
            self.set_version_minor(version_minor)
        } // set_version_minor()
        fn set_server_properties<V>(&mut self, server_properties: V)
            where V: Into<::field::TableEntries<'a>>
        {
            self.set_server_properties(server_properties.into())
        } // set_server_properties()
        fn set_mechanisms<V>(&mut self, mechanisms: V)
            where V: Into<::std::borrow::Cow<'a, [u8]>>
        {
            self.set_mechanisms(mechanisms.into())
        } // set_mechanisms()
        fn set_locales<V>(&mut self, locales: V)
            where V: Into<::std::borrow::Cow<'a, [u8]>>
        {
            self.set_locales(locales.into())
        } // set_locales()
    } // impl<'a> ::method::connection::SetStartMethodFields<'a> for Start<'a>
    impl<'a> ::method::connection::StartOkMethod<'a> for ::Amqp8_0 {
        type Payload = StartOk<'a>;
    } // impl<'a> ::method::connection::StartOkMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct StartOk<'a> {
        client_properties: ::field::TableEntries<'a>,
        mechanism: ::std::borrow::Cow<'a, str>,
        response: ::std::borrow::Cow<'a, [u8]>,
        locale: ::std::borrow::Cow<'a, str>,
    } // struct StartOk<'a>

    impl<'a> StartOk<'a> {
        pub fn new<C, M, R, L>(client_properties: C, mechanism: M, response: R, locale: L) -> Self
            where C: Into<::field::TableEntries<'a>>,
                  M: Into<::std::borrow::Cow<'a, str>>,
                  R: Into<::std::borrow::Cow<'a, [u8]>>,
                  L: Into<::std::borrow::Cow<'a, str>>
        {
            StartOk {
                client_properties: client_properties.into(),
                mechanism: mechanism.into(),
                response: response.into(),
                locale: locale.into(),
            } // StartOk
        } // fn new()
        impl_properties! {
(client_properties, client_properties_mut, set_client_properties) -> &::field::TableEntries<'a>,
(mechanism, mechanism_mut, set_mechanism) -> Cow<str>,
(response, response_mut, set_response) -> Cow<[u8]>,
(locale, locale_mut, set_locale) -> Cow<str>,
} // impl_properties
    } // impl<'a> StartOk<'a>
    impl<'a> Default for StartOk<'a> {
        fn default() -> Self {
            StartOk::new(::field::TableEntries::new(), "", &[][..], "")
        } // fn default()
    } // impl Default for StartOk

    impl<'a> ::Encodable for StartOk<'a> {
        fn encoded_size(&self) -> usize {
            [4,
             ::Encodable::encoded_size(&self.client_properties),
             ::Encodable::encoded_size(&self.mechanism),
             ::Encodable::encoded_size(&self.response),
             ::Encodable::encoded_size(&self.locale)]
                .iter()
                .sum()
        } // fn encoded_size()
    } // impl Encodable

    impl<'a> ::ProtocolMethodPayload for StartOk<'a> {
        fn class_id(&self) -> u16 {
            10
        } // fn class_id()
        fn method_id(&self) -> u16 {
            11
        } // fn method_id()
    } // impl ::Payload for StartOk
    impl<'a> ::method::connection::SetStartOkMethodFields<'a> for StartOk<'a> {
        fn set_client_properties<V>(&mut self, client_properties: V)
            where V: Into<::field::TableEntries<'a>>
        {
            self.set_client_properties(client_properties.into())
        } // set_client_properties()
        fn set_mechanism<V>(&mut self, mechanism: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_mechanism(mechanism.into())
        } // set_mechanism()
        fn set_response<V>(&mut self, response: V)
            where V: Into<::std::borrow::Cow<'a, [u8]>>
        {
            self.set_response(response.into())
        } // set_response()
        fn set_locale<V>(&mut self, locale: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_locale(locale.into())
        } // set_locale()
    } // impl<'a> ::method::connection::SetStartOkMethodFields<'a> for StartOk<'a>
    impl ::method::connection::TuneMethod for ::Amqp8_0 {
        type Payload = Tune;
    } // impl ::method::connection::TuneMethod for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Tune {
        channel_max: u16,
        frame_max: u32,
        heartbeat: u16,
    } // struct Tune

    impl Tune {
        pub fn new(channel_max: u16, frame_max: u32, heartbeat: u16) -> Self {
            Tune {
                channel_max: channel_max,
                frame_max: frame_max,
                heartbeat: heartbeat,
            } // Tune
        } // fn new()
        impl_properties! {
(channel_max, set_channel_max) -> u16,
(frame_max, set_frame_max) -> u32,
(heartbeat, set_heartbeat) -> u16,
} // impl_properties
    } // impl Tune
    impl Default for Tune {
        fn default() -> Self {
            Tune::new(0, 0, 0)
        } // fn default()
    } // impl Default for Tune

    impl ::Encodable for Tune {
        fn encoded_size(&self) -> usize {
            8
        } // fn encoded_size()
    } // impl Encodable

    impl ::ProtocolMethodPayload for Tune {
        fn class_id(&self) -> u16 {
            10
        } // fn class_id()
        fn method_id(&self) -> u16 {
            30
        } // fn method_id()
    } // impl ::Payload for Tune
    impl ::method::connection::SetTuneMethodFields for Tune {
        fn set_channel_max(&mut self, channel_max: u16) {
            self.set_channel_max(channel_max)
        } // set_channel_max()
        fn set_frame_max(&mut self, frame_max: u32) {
            self.set_frame_max(frame_max)
        } // set_frame_max()
        fn set_heartbeat(&mut self, heartbeat: u16) {
            self.set_heartbeat(heartbeat)
        } // set_heartbeat()
    } // impl ::method::connection::SetTuneMethodFields for Tune
    impl ::method::connection::TuneOkMethod for ::Amqp8_0 {
        type Payload = TuneOk;
    } // impl ::method::connection::TuneOkMethod for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct TuneOk {
        channel_max: u16,
        frame_max: u32,
        heartbeat: u16,
    } // struct TuneOk

    impl TuneOk {
        pub fn new(channel_max: u16, frame_max: u32, heartbeat: u16) -> Self {
            TuneOk {
                channel_max: channel_max,
                frame_max: frame_max,
                heartbeat: heartbeat,
            } // TuneOk
        } // fn new()
        impl_properties! {
(channel_max, set_channel_max) -> u16,
(frame_max, set_frame_max) -> u32,
(heartbeat, set_heartbeat) -> u16,
} // impl_properties
    } // impl TuneOk
    impl Default for TuneOk {
        fn default() -> Self {
            TuneOk::new(0, 0, 0)
        } // fn default()
    } // impl Default for TuneOk

    impl ::Encodable for TuneOk {
        fn encoded_size(&self) -> usize {
            8
        } // fn encoded_size()
    } // impl Encodable

    impl ::ProtocolMethodPayload for TuneOk {
        fn class_id(&self) -> u16 {
            10
        } // fn class_id()
        fn method_id(&self) -> u16 {
            31
        } // fn method_id()
    } // impl ::Payload for TuneOk
    impl ::method::connection::SetTuneOkMethodFields for TuneOk {
        fn set_channel_max(&mut self, channel_max: u16) {
            self.set_channel_max(channel_max)
        } // set_channel_max()
        fn set_frame_max(&mut self, frame_max: u32) {
            self.set_frame_max(frame_max)
        } // set_frame_max()
        fn set_heartbeat(&mut self, heartbeat: u16) {
            self.set_heartbeat(heartbeat)
        } // set_heartbeat()
    } // impl ::method::connection::SetTuneOkMethodFields for TuneOk

    #[derive(Debug)]
    pub enum ClassMethod<'a> {
        Close(Close<'a>),
        CloseOk(CloseOk),
        Open(Open<'a>),
        OpenOk(OpenOk<'a>),
        Redirect(Redirect<'a>),
        Secure(Secure<'a>),
        SecureOk(SecureOk<'a>),
        Start(Start<'a>),
        StartOk(StartOk<'a>),
        Tune(Tune),
        TuneOk(TuneOk),
    } // enum ClassMethod


    impl<'a> ::Encodable for ClassMethod<'a> {
        fn encoded_size(&self) -> usize {
            match *self {
                ClassMethod::Close(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::CloseOk(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::Open(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::OpenOk(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::Redirect(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::Secure(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::SecureOk(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::Start(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::StartOk(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::Tune(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::TuneOk(ref method) => ::Encodable::encoded_size(method),

            } // match *self

        } // fn encoded_size
    } // impl ::Encodable for ClassMethod<'a>

    impl<'a> ::ProtocolMethodPayload for ClassMethod<'a> {
        fn class_id(&self) -> u16 {
            match *self {
                ClassMethod::Close(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::CloseOk(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::Open(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::OpenOk(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::Redirect(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::Secure(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::SecureOk(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::Start(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::StartOk(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::Tune(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::TuneOk(ref method) => ::ProtocolMethodPayload::class_id(method),

            } // match *self

        } // fn class_id

        fn method_id(&self) -> u16 {
            match *self {
                ClassMethod::Close(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::CloseOk(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::Open(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::OpenOk(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::Redirect(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::Secure(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::SecureOk(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::Start(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::StartOk(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::Tune(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::TuneOk(ref method) => ::ProtocolMethodPayload::method_id(method),

            } // match *self

        } // fn method_id
    } // impl ProtocolMethodPayload for ClassMethod
} // mod connection

// generated by primalgen::codegen::spec_module::class_mod::ClassModuleWriter
pub mod dtx {
    impl ::method::dtx::SelectMethod for ::Amqp8_0 {
        type Payload = Select;
    } // impl ::method::dtx::SelectMethod for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Select;

    impl Select {
        pub fn new() -> Self {
            Select
        } // fn new()
    } // impl Select
    impl Default for Select {
        fn default() -> Self {
            Select::new()
        } // fn default()
    } // impl Default for Select

    impl ::Encodable for Select {
        fn encoded_size(&self) -> usize {
            0
        } // fn encoded_size()
    } // impl Encodable

    impl ::ProtocolMethodPayload for Select {
        fn class_id(&self) -> u16 {
            100
        } // fn class_id()
        fn method_id(&self) -> u16 {
            10
        } // fn method_id()
    } // impl ::Payload for Select
    impl ::method::dtx::SelectOkMethod for ::Amqp8_0 {
        type Payload = SelectOk;
    } // impl ::method::dtx::SelectOkMethod for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct SelectOk;

    impl SelectOk {
        pub fn new() -> Self {
            SelectOk
        } // fn new()
    } // impl SelectOk
    impl Default for SelectOk {
        fn default() -> Self {
            SelectOk::new()
        } // fn default()
    } // impl Default for SelectOk

    impl ::Encodable for SelectOk {
        fn encoded_size(&self) -> usize {
            0
        } // fn encoded_size()
    } // impl Encodable

    impl ::ProtocolMethodPayload for SelectOk {
        fn class_id(&self) -> u16 {
            100
        } // fn class_id()
        fn method_id(&self) -> u16 {
            11
        } // fn method_id()
    } // impl ::Payload for SelectOk
    impl<'a> ::method::dtx::StartMethod<'a> for ::Amqp8_0 {
        type Payload = Start<'a>;
    } // impl<'a> ::method::dtx::StartMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Start<'a> {
        dtx_identifier: ::std::borrow::Cow<'a, str>,
    } // struct Start<'a>

    impl<'a> Start<'a> {
        pub fn new<D>(dtx_identifier: D) -> Self
            where D: Into<::std::borrow::Cow<'a, str>>
        {
            Start { dtx_identifier: dtx_identifier.into() } // Start
        } // fn new()
        impl_properties! {
(dtx_identifier, dtx_identifier_mut, set_dtx_identifier) -> Cow<str>,
} // impl_properties
    } // impl<'a> Start<'a>
    impl<'a> Default for Start<'a> {
        fn default() -> Self {
            Start::new("")
        } // fn default()
    } // impl Default for Start

    impl<'a> ::Encodable for Start<'a> {
        fn encoded_size(&self) -> usize {
            [1, ::Encodable::encoded_size(&self.dtx_identifier)]
                .iter()
                .sum()
        } // fn encoded_size()
    } // impl Encodable

    impl<'a> ::ProtocolMethodPayload for Start<'a> {
        fn class_id(&self) -> u16 {
            100
        } // fn class_id()
        fn method_id(&self) -> u16 {
            20
        } // fn method_id()
    } // impl ::Payload for Start
    impl<'a> ::method::dtx::SetStartMethodFields<'a> for Start<'a> {
        fn set_dtx_identifier<V>(&mut self, dtx_identifier: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_dtx_identifier(dtx_identifier.into())
        } // set_dtx_identifier()
    } // impl<'a> ::method::dtx::SetStartMethodFields<'a> for Start<'a>
    impl ::method::dtx::StartOkMethod for ::Amqp8_0 {
        type Payload = StartOk;
    } // impl ::method::dtx::StartOkMethod for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct StartOk;

    impl StartOk {
        pub fn new() -> Self {
            StartOk
        } // fn new()
    } // impl StartOk
    impl Default for StartOk {
        fn default() -> Self {
            StartOk::new()
        } // fn default()
    } // impl Default for StartOk

    impl ::Encodable for StartOk {
        fn encoded_size(&self) -> usize {
            0
        } // fn encoded_size()
    } // impl Encodable

    impl ::ProtocolMethodPayload for StartOk {
        fn class_id(&self) -> u16 {
            100
        } // fn class_id()
        fn method_id(&self) -> u16 {
            21
        } // fn method_id()
    } // impl ::Payload for StartOk

    #[derive(Debug)]
    pub enum ClassMethod<'a> {
        Select(Select),
        SelectOk(SelectOk),
        Start(Start<'a>),
        StartOk(StartOk),
    } // enum ClassMethod


    impl<'a> ::Encodable for ClassMethod<'a> {
        fn encoded_size(&self) -> usize {
            match *self {
                ClassMethod::Select(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::SelectOk(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::Start(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::StartOk(ref method) => ::Encodable::encoded_size(method),

            } // match *self

        } // fn encoded_size
    } // impl ::Encodable for ClassMethod<'a>

    impl<'a> ::ProtocolMethodPayload for ClassMethod<'a> {
        fn class_id(&self) -> u16 {
            match *self {
                ClassMethod::Select(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::SelectOk(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::Start(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::StartOk(ref method) => ::ProtocolMethodPayload::class_id(method),

            } // match *self

        } // fn class_id

        fn method_id(&self) -> u16 {
            match *self {
                ClassMethod::Select(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::SelectOk(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::Start(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::StartOk(ref method) => ::ProtocolMethodPayload::method_id(method),

            } // match *self

        } // fn method_id
    } // impl ProtocolMethodPayload for ClassMethod
} // mod dtx

// generated by primalgen::codegen::spec_module::class_mod::ClassModuleWriter
pub mod exchange {
    impl<'a> ::method::exchange::DeclareMethod<'a> for ::Amqp8_0 {
        type Payload = Declare<'a>;
    } // impl<'a> ::method::exchange::DeclareMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Declare<'a> {
        ticket: u16,
        exchange: ::std::borrow::Cow<'a, str>,
        ty: ::std::borrow::Cow<'a, str>,
        passive: bool,
        durable: bool,
        auto_delete: bool,
        internal: bool,
        no_wait: bool,
        arguments: ::field::TableEntries<'a>,
    } // struct Declare<'a>

    impl<'a> Declare<'a> {
        pub fn new<E, T, A>(ticket: u16,
                            exchange: E,
                            ty: T,
                            passive: bool,
                            durable: bool,
                            auto_delete: bool,
                            internal: bool,
                            no_wait: bool,
                            arguments: A)
                            -> Self
            where E: Into<::std::borrow::Cow<'a, str>>,
                  T: Into<::std::borrow::Cow<'a, str>>,
                  A: Into<::field::TableEntries<'a>>
        {
            Declare {
                ticket: ticket,
                exchange: exchange.into(),
                ty: ty.into(),
                passive: passive,
                durable: durable,
                auto_delete: auto_delete,
                internal: internal,
                no_wait: no_wait,
                arguments: arguments.into(),
            } // Declare
        } // fn new()
        impl_properties! {
(ticket, set_ticket) -> u16,
(exchange, exchange_mut, set_exchange) -> Cow<str>,
(ty, ty_mut, set_ty) -> Cow<str>,
(passive, set_passive) -> bool,
(durable, set_durable) -> bool,
(auto_delete, set_auto_delete) -> bool,
(internal, set_internal) -> bool,
(no_wait, set_no_wait) -> bool,
(arguments, arguments_mut, set_arguments) -> &::field::TableEntries<'a>,
} // impl_properties
    } // impl<'a> Declare<'a>
    impl<'a> Default for Declare<'a> {
        fn default() -> Self {
            Declare::new(0,
                         "",
                         "",
                         false,
                         false,
                         false,
                         false,
                         false,
                         ::field::TableEntries::new())
        } // fn default()
    } // impl Default for Declare

    impl<'a> ::Encodable for Declare<'a> {
        fn encoded_size(&self) -> usize {
            [5,
             ::Encodable::encoded_size(&self.exchange),
             ::Encodable::encoded_size(&self.ty),
             ::Encodable::encoded_size(&self.arguments)]
                .iter()
                .sum()
        } // fn encoded_size()
    } // impl Encodable

    impl<'a> ::ProtocolMethodPayload for Declare<'a> {
        fn class_id(&self) -> u16 {
            40
        } // fn class_id()
        fn method_id(&self) -> u16 {
            10
        } // fn method_id()
    } // impl ::Payload for Declare
    impl<'a> ::method::exchange::SetDeclareMethodFields<'a> for Declare<'a> {
        fn set_ticket(&mut self, ticket: u16) {
            self.set_ticket(ticket)
        } // set_ticket()
        fn set_exchange<V>(&mut self, exchange: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_exchange(exchange.into())
        } // set_exchange()
        fn set_ty<V>(&mut self, ty: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_ty(ty.into())
        } // set_ty()
        fn set_passive(&mut self, passive: bool) {
            self.set_passive(passive)
        } // set_passive()
        fn set_durable(&mut self, durable: bool) {
            self.set_durable(durable)
        } // set_durable()
        fn set_auto_delete(&mut self, auto_delete: bool) {
            self.set_auto_delete(auto_delete)
        } // set_auto_delete()
        fn set_internal(&mut self, internal: bool) {
            self.set_internal(internal)
        } // set_internal()
        fn set_no_wait(&mut self, no_wait: bool) {
            self.set_no_wait(no_wait)
        } // set_no_wait()
        fn set_arguments<V>(&mut self, arguments: V)
            where V: Into<::field::TableEntries<'a>>
        {
            self.set_arguments(arguments.into())
        } // set_arguments()
    } // impl<'a> ::method::exchange::SetDeclareMethodFields<'a> for Declare<'a>
    impl ::method::exchange::DeclareOkMethod for ::Amqp8_0 {
        type Payload = DeclareOk;
    } // impl ::method::exchange::DeclareOkMethod for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct DeclareOk;

    impl DeclareOk {
        pub fn new() -> Self {
            DeclareOk
        } // fn new()
    } // impl DeclareOk
    impl Default for DeclareOk {
        fn default() -> Self {
            DeclareOk::new()
        } // fn default()
    } // impl Default for DeclareOk

    impl ::Encodable for DeclareOk {
        fn encoded_size(&self) -> usize {
            0
        } // fn encoded_size()
    } // impl Encodable

    impl ::ProtocolMethodPayload for DeclareOk {
        fn class_id(&self) -> u16 {
            40
        } // fn class_id()
        fn method_id(&self) -> u16 {
            11
        } // fn method_id()
    } // impl ::Payload for DeclareOk
    impl<'a> ::method::exchange::DeleteMethod<'a> for ::Amqp8_0 {
        type Payload = Delete<'a>;
    } // impl<'a> ::method::exchange::DeleteMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Delete<'a> {
        ticket: u16,
        exchange: ::std::borrow::Cow<'a, str>,
        if_unused: bool,
        no_wait: bool,
    } // struct Delete<'a>

    impl<'a> Delete<'a> {
        pub fn new<E>(ticket: u16, exchange: E, if_unused: bool, no_wait: bool) -> Self
            where E: Into<::std::borrow::Cow<'a, str>>
        {
            Delete {
                ticket: ticket,
                exchange: exchange.into(),
                if_unused: if_unused,
                no_wait: no_wait,
            } // Delete
        } // fn new()
        impl_properties! {
(ticket, set_ticket) -> u16,
(exchange, exchange_mut, set_exchange) -> Cow<str>,
(if_unused, set_if_unused) -> bool,
(no_wait, set_no_wait) -> bool,
} // impl_properties
    } // impl<'a> Delete<'a>
    impl<'a> Default for Delete<'a> {
        fn default() -> Self {
            Delete::new(0, "", false, false)
        } // fn default()
    } // impl Default for Delete

    impl<'a> ::Encodable for Delete<'a> {
        fn encoded_size(&self) -> usize {
            [4, ::Encodable::encoded_size(&self.exchange)]
                .iter()
                .sum()
        } // fn encoded_size()
    } // impl Encodable

    impl<'a> ::ProtocolMethodPayload for Delete<'a> {
        fn class_id(&self) -> u16 {
            40
        } // fn class_id()
        fn method_id(&self) -> u16 {
            20
        } // fn method_id()
    } // impl ::Payload for Delete
    impl<'a> ::method::exchange::SetDeleteMethodFields<'a> for Delete<'a> {
        fn set_ticket(&mut self, ticket: u16) {
            self.set_ticket(ticket)
        } // set_ticket()
        fn set_exchange<V>(&mut self, exchange: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_exchange(exchange.into())
        } // set_exchange()
        fn set_if_unused(&mut self, if_unused: bool) {
            self.set_if_unused(if_unused)
        } // set_if_unused()
        fn set_no_wait(&mut self, no_wait: bool) {
            self.set_no_wait(no_wait)
        } // set_no_wait()
    } // impl<'a> ::method::exchange::SetDeleteMethodFields<'a> for Delete<'a>
    impl ::method::exchange::DeleteOkMethod for ::Amqp8_0 {
        type Payload = DeleteOk;
    } // impl ::method::exchange::DeleteOkMethod for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct DeleteOk;

    impl DeleteOk {
        pub fn new() -> Self {
            DeleteOk
        } // fn new()
    } // impl DeleteOk
    impl Default for DeleteOk {
        fn default() -> Self {
            DeleteOk::new()
        } // fn default()
    } // impl Default for DeleteOk

    impl ::Encodable for DeleteOk {
        fn encoded_size(&self) -> usize {
            0
        } // fn encoded_size()
    } // impl Encodable

    impl ::ProtocolMethodPayload for DeleteOk {
        fn class_id(&self) -> u16 {
            40
        } // fn class_id()
        fn method_id(&self) -> u16 {
            21
        } // fn method_id()
    } // impl ::Payload for DeleteOk

    #[derive(Debug)]
    pub enum ClassMethod<'a> {
        Declare(Declare<'a>),
        DeclareOk(DeclareOk),
        Delete(Delete<'a>),
        DeleteOk(DeleteOk),
    } // enum ClassMethod


    impl<'a> ::Encodable for ClassMethod<'a> {
        fn encoded_size(&self) -> usize {
            match *self {
                ClassMethod::Declare(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::DeclareOk(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::Delete(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::DeleteOk(ref method) => ::Encodable::encoded_size(method),

            } // match *self

        } // fn encoded_size
    } // impl ::Encodable for ClassMethod<'a>

    impl<'a> ::ProtocolMethodPayload for ClassMethod<'a> {
        fn class_id(&self) -> u16 {
            match *self {
                ClassMethod::Declare(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::DeclareOk(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::Delete(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::DeleteOk(ref method) => ::ProtocolMethodPayload::class_id(method),

            } // match *self

        } // fn class_id

        fn method_id(&self) -> u16 {
            match *self {
                ClassMethod::Declare(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::DeclareOk(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::Delete(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::DeleteOk(ref method) => ::ProtocolMethodPayload::method_id(method),

            } // match *self

        } // fn method_id
    } // impl ProtocolMethodPayload for ClassMethod
} // mod exchange

// generated by primalgen::codegen::spec_module::class_mod::ClassModuleWriter
pub mod file {

    // Generated by primalgen::spec::frame_payload_enum::ClassEnumWriter
    #[derive(Debug)]
    pub struct Header<'a> {
        content_type: Option<::std::borrow::Cow<'a, str>>,
        content_encoding: Option<::std::borrow::Cow<'a, str>>,
        headers: Option<::field::TableEntries<'a>>,
        priority: Option<u8>,
        reply_to: Option<::std::borrow::Cow<'a, str>>,
        message_id: Option<::std::borrow::Cow<'a, str>>,
        filename: Option<::std::borrow::Cow<'a, str>>,
        timestamp: Option<u64>,
        cluster_id: Option<::std::borrow::Cow<'a, str>>,
    } // struct Header

    impl<'a> Header<'a> {
        impl_properties! {
(content_type, content_type_mut, set_content_type, take_content_type) -> Option< Cow<str> >,
(content_encoding, content_encoding_mut, set_content_encoding, take_content_encoding) -> Option< Cow<str> >,
(headers, headers_mut, set_headers, take_headers) -> Option< &::field::TableEntries<'a> >,
(priority, priority_mut, set_priority, take_priority) -> Option< u8 >,
(reply_to, reply_to_mut, set_reply_to, take_reply_to) -> Option< Cow<str> >,
(message_id, message_id_mut, set_message_id, take_message_id) -> Option< Cow<str> >,
(filename, filename_mut, set_filename, take_filename) -> Option< Cow<str> >,
(timestamp, timestamp_mut, set_timestamp, take_timestamp) -> Option< u64 >,
(cluster_id, cluster_id_mut, set_cluster_id, take_cluster_id) -> Option< Cow<str> >,
} // impl_properties
    } // impl Headers

    impl<'a> ::Encodable for Header<'a> {
        fn encoded_size(&self) -> usize {
            unimplemented!()
        } // fn encoded_size
    } // impl ::Encodable for Header<'a>
    impl ::method::file::AckMethod for ::Amqp8_0 {
        type Payload = Ack;
    } // impl ::method::file::AckMethod for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Ack {
        delivery_tag: u64,
        multiple: bool,
    } // struct Ack

    impl Ack {
        pub fn new(delivery_tag: u64, multiple: bool) -> Self {
            Ack {
                delivery_tag: delivery_tag,
                multiple: multiple,
            } // Ack
        } // fn new()
        impl_properties! {
(delivery_tag, set_delivery_tag) -> u64,
(multiple, set_multiple) -> bool,
} // impl_properties
    } // impl Ack
    impl Default for Ack {
        fn default() -> Self {
            Ack::new(0, false)
        } // fn default()
    } // impl Default for Ack

    impl ::Encodable for Ack {
        fn encoded_size(&self) -> usize {
            9
        } // fn encoded_size()
    } // impl Encodable

    impl ::ProtocolMethodPayload for Ack {
        fn class_id(&self) -> u16 {
            70
        } // fn class_id()
        fn method_id(&self) -> u16 {
            90
        } // fn method_id()
    } // impl ::Payload for Ack
    impl ::method::file::SetAckMethodFields for Ack {
        fn set_delivery_tag(&mut self, delivery_tag: u64) {
            self.set_delivery_tag(delivery_tag)
        } // set_delivery_tag()
        fn set_multiple(&mut self, multiple: bool) {
            self.set_multiple(multiple)
        } // set_multiple()
    } // impl ::method::file::SetAckMethodFields for Ack
    impl<'a> ::method::file::CancelMethod<'a> for ::Amqp8_0 {
        type Payload = Cancel<'a>;
    } // impl<'a> ::method::file::CancelMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Cancel<'a> {
        consumer_tag: ::std::borrow::Cow<'a, str>,
        no_wait: bool,
    } // struct Cancel<'a>

    impl<'a> Cancel<'a> {
        pub fn new<C>(consumer_tag: C, no_wait: bool) -> Self
            where C: Into<::std::borrow::Cow<'a, str>>
        {
            Cancel {
                consumer_tag: consumer_tag.into(),
                no_wait: no_wait,
            } // Cancel
        } // fn new()
        impl_properties! {
(consumer_tag, consumer_tag_mut, set_consumer_tag) -> Cow<str>,
(no_wait, set_no_wait) -> bool,
} // impl_properties
    } // impl<'a> Cancel<'a>
    impl<'a> Default for Cancel<'a> {
        fn default() -> Self {
            Cancel::new("", false)
        } // fn default()
    } // impl Default for Cancel

    impl<'a> ::Encodable for Cancel<'a> {
        fn encoded_size(&self) -> usize {
            [2, ::Encodable::encoded_size(&self.consumer_tag)]
                .iter()
                .sum()
        } // fn encoded_size()
    } // impl Encodable

    impl<'a> ::ProtocolMethodPayload for Cancel<'a> {
        fn class_id(&self) -> u16 {
            70
        } // fn class_id()
        fn method_id(&self) -> u16 {
            30
        } // fn method_id()
    } // impl ::Payload for Cancel
    impl<'a> ::method::file::SetCancelMethodFields<'a> for Cancel<'a> {
        fn set_consumer_tag<V>(&mut self, consumer_tag: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_consumer_tag(consumer_tag.into())
        } // set_consumer_tag()
        fn set_no_wait(&mut self, no_wait: bool) {
            self.set_no_wait(no_wait)
        } // set_no_wait()
    } // impl<'a> ::method::file::SetCancelMethodFields<'a> for Cancel<'a>
    impl<'a> ::method::file::CancelOkMethod<'a> for ::Amqp8_0 {
        type Payload = CancelOk<'a>;
    } // impl<'a> ::method::file::CancelOkMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct CancelOk<'a> {
        consumer_tag: ::std::borrow::Cow<'a, str>,
    } // struct CancelOk<'a>

    impl<'a> CancelOk<'a> {
        pub fn new<C>(consumer_tag: C) -> Self
            where C: Into<::std::borrow::Cow<'a, str>>
        {
            CancelOk { consumer_tag: consumer_tag.into() } // CancelOk
        } // fn new()
        impl_properties! {
(consumer_tag, consumer_tag_mut, set_consumer_tag) -> Cow<str>,
} // impl_properties
    } // impl<'a> CancelOk<'a>
    impl<'a> Default for CancelOk<'a> {
        fn default() -> Self {
            CancelOk::new("")
        } // fn default()
    } // impl Default for CancelOk

    impl<'a> ::Encodable for CancelOk<'a> {
        fn encoded_size(&self) -> usize {
            [1, ::Encodable::encoded_size(&self.consumer_tag)]
                .iter()
                .sum()
        } // fn encoded_size()
    } // impl Encodable

    impl<'a> ::ProtocolMethodPayload for CancelOk<'a> {
        fn class_id(&self) -> u16 {
            70
        } // fn class_id()
        fn method_id(&self) -> u16 {
            31
        } // fn method_id()
    } // impl ::Payload for CancelOk
    impl<'a> ::method::file::SetCancelOkMethodFields<'a> for CancelOk<'a> {
        fn set_consumer_tag<V>(&mut self, consumer_tag: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_consumer_tag(consumer_tag.into())
        } // set_consumer_tag()
    } // impl<'a> ::method::file::SetCancelOkMethodFields<'a> for CancelOk<'a>
    impl<'a> ::method::file::ConsumeMethod<'a> for ::Amqp8_0 {
        type Payload = Consume<'a>;
    } // impl<'a> ::method::file::ConsumeMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Consume<'a> {
        ticket: u16,
        queue: ::std::borrow::Cow<'a, str>,
        consumer_tag: ::std::borrow::Cow<'a, str>,
        no_local: bool,
        no_ack: bool,
        exclusive: bool,
        no_wait: bool,
    } // struct Consume<'a>

    impl<'a> Consume<'a> {
        pub fn new<Q, C>(ticket: u16,
                         queue: Q,
                         consumer_tag: C,
                         no_local: bool,
                         no_ack: bool,
                         exclusive: bool,
                         no_wait: bool)
                         -> Self
            where Q: Into<::std::borrow::Cow<'a, str>>,
                  C: Into<::std::borrow::Cow<'a, str>>
        {
            Consume {
                ticket: ticket,
                queue: queue.into(),
                consumer_tag: consumer_tag.into(),
                no_local: no_local,
                no_ack: no_ack,
                exclusive: exclusive,
                no_wait: no_wait,
            } // Consume
        } // fn new()
        impl_properties! {
(ticket, set_ticket) -> u16,
(queue, queue_mut, set_queue) -> Cow<str>,
(consumer_tag, consumer_tag_mut, set_consumer_tag) -> Cow<str>,
(no_local, set_no_local) -> bool,
(no_ack, set_no_ack) -> bool,
(exclusive, set_exclusive) -> bool,
(no_wait, set_no_wait) -> bool,
} // impl_properties
    } // impl<'a> Consume<'a>
    impl<'a> Default for Consume<'a> {
        fn default() -> Self {
            Consume::new(0, "", "", false, false, false, false)
        } // fn default()
    } // impl Default for Consume

    impl<'a> ::Encodable for Consume<'a> {
        fn encoded_size(&self) -> usize {
            [5,
             ::Encodable::encoded_size(&self.queue),
             ::Encodable::encoded_size(&self.consumer_tag)]
                .iter()
                .sum()
        } // fn encoded_size()
    } // impl Encodable

    impl<'a> ::ProtocolMethodPayload for Consume<'a> {
        fn class_id(&self) -> u16 {
            70
        } // fn class_id()
        fn method_id(&self) -> u16 {
            20
        } // fn method_id()
    } // impl ::Payload for Consume
    impl<'a> ::method::file::SetConsumeMethodFields<'a> for Consume<'a> {
        fn set_ticket(&mut self, ticket: u16) {
            self.set_ticket(ticket)
        } // set_ticket()
        fn set_queue<V>(&mut self, queue: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_queue(queue.into())
        } // set_queue()
        fn set_consumer_tag<V>(&mut self, consumer_tag: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_consumer_tag(consumer_tag.into())
        } // set_consumer_tag()
        fn set_no_local(&mut self, no_local: bool) {
            self.set_no_local(no_local)
        } // set_no_local()
        fn set_no_ack(&mut self, no_ack: bool) {
            self.set_no_ack(no_ack)
        } // set_no_ack()
        fn set_exclusive(&mut self, exclusive: bool) {
            self.set_exclusive(exclusive)
        } // set_exclusive()
        fn set_no_wait(&mut self, no_wait: bool) {
            self.set_no_wait(no_wait)
        } // set_no_wait()
    } // impl<'a> ::method::file::SetConsumeMethodFields<'a> for Consume<'a>
    impl<'a> ::method::file::ConsumeOkMethod<'a> for ::Amqp8_0 {
        type Payload = ConsumeOk<'a>;
    } // impl<'a> ::method::file::ConsumeOkMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct ConsumeOk<'a> {
        consumer_tag: ::std::borrow::Cow<'a, str>,
    } // struct ConsumeOk<'a>

    impl<'a> ConsumeOk<'a> {
        pub fn new<C>(consumer_tag: C) -> Self
            where C: Into<::std::borrow::Cow<'a, str>>
        {
            ConsumeOk { consumer_tag: consumer_tag.into() } // ConsumeOk
        } // fn new()
        impl_properties! {
(consumer_tag, consumer_tag_mut, set_consumer_tag) -> Cow<str>,
} // impl_properties
    } // impl<'a> ConsumeOk<'a>
    impl<'a> Default for ConsumeOk<'a> {
        fn default() -> Self {
            ConsumeOk::new("")
        } // fn default()
    } // impl Default for ConsumeOk

    impl<'a> ::Encodable for ConsumeOk<'a> {
        fn encoded_size(&self) -> usize {
            [1, ::Encodable::encoded_size(&self.consumer_tag)]
                .iter()
                .sum()
        } // fn encoded_size()
    } // impl Encodable

    impl<'a> ::ProtocolMethodPayload for ConsumeOk<'a> {
        fn class_id(&self) -> u16 {
            70
        } // fn class_id()
        fn method_id(&self) -> u16 {
            21
        } // fn method_id()
    } // impl ::Payload for ConsumeOk
    impl<'a> ::method::file::SetConsumeOkMethodFields<'a> for ConsumeOk<'a> {
        fn set_consumer_tag<V>(&mut self, consumer_tag: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_consumer_tag(consumer_tag.into())
        } // set_consumer_tag()
    } // impl<'a> ::method::file::SetConsumeOkMethodFields<'a> for ConsumeOk<'a>
    impl<'a> ::method::file::DeliverMethod<'a> for ::Amqp8_0 {
        type Payload = Deliver<'a>;
    } // impl<'a> ::method::file::DeliverMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Deliver<'a> {
        consumer_tag: ::std::borrow::Cow<'a, str>,
        delivery_tag: u64,
        redelivered: bool,
        exchange: ::std::borrow::Cow<'a, str>,
        routing_key: ::std::borrow::Cow<'a, str>,
        identifier: ::std::borrow::Cow<'a, str>,
    } // struct Deliver<'a>

    impl<'a> Deliver<'a> {
        pub fn new<C, E, R, I>(consumer_tag: C,
                               delivery_tag: u64,
                               redelivered: bool,
                               exchange: E,
                               routing_key: R,
                               identifier: I)
                               -> Self
            where C: Into<::std::borrow::Cow<'a, str>>,
                  E: Into<::std::borrow::Cow<'a, str>>,
                  R: Into<::std::borrow::Cow<'a, str>>,
                  I: Into<::std::borrow::Cow<'a, str>>
        {
            Deliver {
                consumer_tag: consumer_tag.into(),
                delivery_tag: delivery_tag,
                redelivered: redelivered,
                exchange: exchange.into(),
                routing_key: routing_key.into(),
                identifier: identifier.into(),
            } // Deliver
        } // fn new()
        impl_properties! {
(consumer_tag, consumer_tag_mut, set_consumer_tag) -> Cow<str>,
(delivery_tag, set_delivery_tag) -> u64,
(redelivered, set_redelivered) -> bool,
(exchange, exchange_mut, set_exchange) -> Cow<str>,
(routing_key, routing_key_mut, set_routing_key) -> Cow<str>,
(identifier, identifier_mut, set_identifier) -> Cow<str>,
} // impl_properties
    } // impl<'a> Deliver<'a>
    impl<'a> Default for Deliver<'a> {
        fn default() -> Self {
            Deliver::new("", 0, false, "", "", "")
        } // fn default()
    } // impl Default for Deliver

    impl<'a> ::Encodable for Deliver<'a> {
        fn encoded_size(&self) -> usize {
            [13,
             ::Encodable::encoded_size(&self.consumer_tag),
             ::Encodable::encoded_size(&self.exchange),
             ::Encodable::encoded_size(&self.routing_key),
             ::Encodable::encoded_size(&self.identifier)]
                .iter()
                .sum()
        } // fn encoded_size()
    } // impl Encodable

    impl<'a> ::ProtocolMethodPayload for Deliver<'a> {
        fn class_id(&self) -> u16 {
            70
        } // fn class_id()
        fn method_id(&self) -> u16 {
            80
        } // fn method_id()
    } // impl ::Payload for Deliver
    impl<'a> ::method::file::SetDeliverMethodFields<'a> for Deliver<'a> {
        fn set_consumer_tag<V>(&mut self, consumer_tag: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_consumer_tag(consumer_tag.into())
        } // set_consumer_tag()
        fn set_delivery_tag(&mut self, delivery_tag: u64) {
            self.set_delivery_tag(delivery_tag)
        } // set_delivery_tag()
        fn set_redelivered(&mut self, redelivered: bool) {
            self.set_redelivered(redelivered)
        } // set_redelivered()
        fn set_exchange<V>(&mut self, exchange: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_exchange(exchange.into())
        } // set_exchange()
        fn set_routing_key<V>(&mut self, routing_key: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_routing_key(routing_key.into())
        } // set_routing_key()
        fn set_identifier<V>(&mut self, identifier: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_identifier(identifier.into())
        } // set_identifier()
    } // impl<'a> ::method::file::SetDeliverMethodFields<'a> for Deliver<'a>
    impl<'a> ::method::file::OpenMethod<'a> for ::Amqp8_0 {
        type Payload = Open<'a>;
    } // impl<'a> ::method::file::OpenMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Open<'a> {
        identifier: ::std::borrow::Cow<'a, str>,
        content_size: u64,
    } // struct Open<'a>

    impl<'a> Open<'a> {
        pub fn new<I>(identifier: I, content_size: u64) -> Self
            where I: Into<::std::borrow::Cow<'a, str>>
        {
            Open {
                identifier: identifier.into(),
                content_size: content_size,
            } // Open
        } // fn new()
        impl_properties! {
(identifier, identifier_mut, set_identifier) -> Cow<str>,
(content_size, set_content_size) -> u64,
} // impl_properties
    } // impl<'a> Open<'a>
    impl<'a> Default for Open<'a> {
        fn default() -> Self {
            Open::new("", 0)
        } // fn default()
    } // impl Default for Open

    impl<'a> ::Encodable for Open<'a> {
        fn encoded_size(&self) -> usize {
            [9, ::Encodable::encoded_size(&self.identifier)]
                .iter()
                .sum()
        } // fn encoded_size()
    } // impl Encodable

    impl<'a> ::ProtocolMethodPayload for Open<'a> {
        fn class_id(&self) -> u16 {
            70
        } // fn class_id()
        fn method_id(&self) -> u16 {
            40
        } // fn method_id()
    } // impl ::Payload for Open
    impl<'a> ::method::file::SetOpenMethodFields<'a> for Open<'a> {
        fn set_identifier<V>(&mut self, identifier: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_identifier(identifier.into())
        } // set_identifier()
        fn set_content_size(&mut self, content_size: u64) {
            self.set_content_size(content_size)
        } // set_content_size()
    } // impl<'a> ::method::file::SetOpenMethodFields<'a> for Open<'a>
    impl ::method::file::OpenOkMethod for ::Amqp8_0 {
        type Payload = OpenOk;
    } // impl ::method::file::OpenOkMethod for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct OpenOk {
        staged_size: u64,
    } // struct OpenOk

    impl OpenOk {
        pub fn new(staged_size: u64) -> Self {
            OpenOk { staged_size: staged_size } // OpenOk
        } // fn new()
        impl_properties! {
(staged_size, set_staged_size) -> u64,
} // impl_properties
    } // impl OpenOk
    impl Default for OpenOk {
        fn default() -> Self {
            OpenOk::new(0)
        } // fn default()
    } // impl Default for OpenOk

    impl ::Encodable for OpenOk {
        fn encoded_size(&self) -> usize {
            8
        } // fn encoded_size()
    } // impl Encodable

    impl ::ProtocolMethodPayload for OpenOk {
        fn class_id(&self) -> u16 {
            70
        } // fn class_id()
        fn method_id(&self) -> u16 {
            41
        } // fn method_id()
    } // impl ::Payload for OpenOk
    impl ::method::file::SetOpenOkMethodFields for OpenOk {
        fn set_staged_size(&mut self, staged_size: u64) {
            self.set_staged_size(staged_size)
        } // set_staged_size()
    } // impl ::method::file::SetOpenOkMethodFields for OpenOk
    impl<'a> ::method::file::PublishMethod<'a> for ::Amqp8_0 {
        type Payload = Publish<'a>;
    } // impl<'a> ::method::file::PublishMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Publish<'a> {
        ticket: u16,
        exchange: ::std::borrow::Cow<'a, str>,
        routing_key: ::std::borrow::Cow<'a, str>,
        mandatory: bool,
        immediate: bool,
        identifier: ::std::borrow::Cow<'a, str>,
    } // struct Publish<'a>

    impl<'a> Publish<'a> {
        pub fn new<E, R, I>(ticket: u16,
                            exchange: E,
                            routing_key: R,
                            mandatory: bool,
                            immediate: bool,
                            identifier: I)
                            -> Self
            where E: Into<::std::borrow::Cow<'a, str>>,
                  R: Into<::std::borrow::Cow<'a, str>>,
                  I: Into<::std::borrow::Cow<'a, str>>
        {
            Publish {
                ticket: ticket,
                exchange: exchange.into(),
                routing_key: routing_key.into(),
                mandatory: mandatory,
                immediate: immediate,
                identifier: identifier.into(),
            } // Publish
        } // fn new()
        impl_properties! {
(ticket, set_ticket) -> u16,
(exchange, exchange_mut, set_exchange) -> Cow<str>,
(routing_key, routing_key_mut, set_routing_key) -> Cow<str>,
(mandatory, set_mandatory) -> bool,
(immediate, set_immediate) -> bool,
(identifier, identifier_mut, set_identifier) -> Cow<str>,
} // impl_properties
    } // impl<'a> Publish<'a>
    impl<'a> Default for Publish<'a> {
        fn default() -> Self {
            Publish::new(0, "", "", false, false, "")
        } // fn default()
    } // impl Default for Publish

    impl<'a> ::Encodable for Publish<'a> {
        fn encoded_size(&self) -> usize {
            [6,
             ::Encodable::encoded_size(&self.exchange),
             ::Encodable::encoded_size(&self.routing_key),
             ::Encodable::encoded_size(&self.identifier)]
                .iter()
                .sum()
        } // fn encoded_size()
    } // impl Encodable

    impl<'a> ::ProtocolMethodPayload for Publish<'a> {
        fn class_id(&self) -> u16 {
            70
        } // fn class_id()
        fn method_id(&self) -> u16 {
            60
        } // fn method_id()
    } // impl ::Payload for Publish
    impl<'a> ::method::file::SetPublishMethodFields<'a> for Publish<'a> {
        fn set_ticket(&mut self, ticket: u16) {
            self.set_ticket(ticket)
        } // set_ticket()
        fn set_exchange<V>(&mut self, exchange: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_exchange(exchange.into())
        } // set_exchange()
        fn set_routing_key<V>(&mut self, routing_key: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_routing_key(routing_key.into())
        } // set_routing_key()
        fn set_mandatory(&mut self, mandatory: bool) {
            self.set_mandatory(mandatory)
        } // set_mandatory()
        fn set_immediate(&mut self, immediate: bool) {
            self.set_immediate(immediate)
        } // set_immediate()
        fn set_identifier<V>(&mut self, identifier: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_identifier(identifier.into())
        } // set_identifier()
    } // impl<'a> ::method::file::SetPublishMethodFields<'a> for Publish<'a>
    impl ::method::file::QosMethod for ::Amqp8_0 {
        type Payload = Qos;
    } // impl ::method::file::QosMethod for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Qos {
        prefetch_size: u32,
        prefetch_count: u16,
        global: bool,
    } // struct Qos

    impl Qos {
        pub fn new(prefetch_size: u32, prefetch_count: u16, global: bool) -> Self {
            Qos {
                prefetch_size: prefetch_size,
                prefetch_count: prefetch_count,
                global: global,
            } // Qos
        } // fn new()
        impl_properties! {
(prefetch_size, set_prefetch_size) -> u32,
(prefetch_count, set_prefetch_count) -> u16,
(global, set_global) -> bool,
} // impl_properties
    } // impl Qos
    impl Default for Qos {
        fn default() -> Self {
            Qos::new(0, 0, false)
        } // fn default()
    } // impl Default for Qos

    impl ::Encodable for Qos {
        fn encoded_size(&self) -> usize {
            7
        } // fn encoded_size()
    } // impl Encodable

    impl ::ProtocolMethodPayload for Qos {
        fn class_id(&self) -> u16 {
            70
        } // fn class_id()
        fn method_id(&self) -> u16 {
            10
        } // fn method_id()
    } // impl ::Payload for Qos
    impl ::method::file::SetQosMethodFields for Qos {
        fn set_prefetch_size(&mut self, prefetch_size: u32) {
            self.set_prefetch_size(prefetch_size)
        } // set_prefetch_size()
        fn set_prefetch_count(&mut self, prefetch_count: u16) {
            self.set_prefetch_count(prefetch_count)
        } // set_prefetch_count()
        fn set_global(&mut self, global: bool) {
            self.set_global(global)
        } // set_global()
    } // impl ::method::file::SetQosMethodFields for Qos
    impl ::method::file::QosOkMethod for ::Amqp8_0 {
        type Payload = QosOk;
    } // impl ::method::file::QosOkMethod for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct QosOk;

    impl QosOk {
        pub fn new() -> Self {
            QosOk
        } // fn new()
    } // impl QosOk
    impl Default for QosOk {
        fn default() -> Self {
            QosOk::new()
        } // fn default()
    } // impl Default for QosOk

    impl ::Encodable for QosOk {
        fn encoded_size(&self) -> usize {
            0
        } // fn encoded_size()
    } // impl Encodable

    impl ::ProtocolMethodPayload for QosOk {
        fn class_id(&self) -> u16 {
            70
        } // fn class_id()
        fn method_id(&self) -> u16 {
            11
        } // fn method_id()
    } // impl ::Payload for QosOk
    impl ::method::file::RejectMethod for ::Amqp8_0 {
        type Payload = Reject;
    } // impl ::method::file::RejectMethod for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Reject {
        delivery_tag: u64,
        requeue: bool,
    } // struct Reject

    impl Reject {
        pub fn new(delivery_tag: u64, requeue: bool) -> Self {
            Reject {
                delivery_tag: delivery_tag,
                requeue: requeue,
            } // Reject
        } // fn new()
        impl_properties! {
(delivery_tag, set_delivery_tag) -> u64,
(requeue, set_requeue) -> bool,
} // impl_properties
    } // impl Reject
    impl Default for Reject {
        fn default() -> Self {
            Reject::new(0, false)
        } // fn default()
    } // impl Default for Reject

    impl ::Encodable for Reject {
        fn encoded_size(&self) -> usize {
            9
        } // fn encoded_size()
    } // impl Encodable

    impl ::ProtocolMethodPayload for Reject {
        fn class_id(&self) -> u16 {
            70
        } // fn class_id()
        fn method_id(&self) -> u16 {
            100
        } // fn method_id()
    } // impl ::Payload for Reject
    impl ::method::file::SetRejectMethodFields for Reject {
        fn set_delivery_tag(&mut self, delivery_tag: u64) {
            self.set_delivery_tag(delivery_tag)
        } // set_delivery_tag()
        fn set_requeue(&mut self, requeue: bool) {
            self.set_requeue(requeue)
        } // set_requeue()
    } // impl ::method::file::SetRejectMethodFields for Reject
    impl<'a> ::method::file::ReturnMethod<'a> for ::Amqp8_0 {
        type Payload = Return<'a>;
    } // impl<'a> ::method::file::ReturnMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Return<'a> {
        reply_code: u16,
        reply_text: ::std::borrow::Cow<'a, str>,
        exchange: ::std::borrow::Cow<'a, str>,
        routing_key: ::std::borrow::Cow<'a, str>,
    } // struct Return<'a>

    impl<'a> Return<'a> {
        pub fn new<R, E, R0>(reply_code: u16, reply_text: R, exchange: E, routing_key: R0) -> Self
            where R: Into<::std::borrow::Cow<'a, str>>,
                  E: Into<::std::borrow::Cow<'a, str>>,
                  R0: Into<::std::borrow::Cow<'a, str>>
        {
            Return {
                reply_code: reply_code,
                reply_text: reply_text.into(),
                exchange: exchange.into(),
                routing_key: routing_key.into(),
            } // Return
        } // fn new()
        impl_properties! {
(reply_code, set_reply_code) -> u16,
(reply_text, reply_text_mut, set_reply_text) -> Cow<str>,
(exchange, exchange_mut, set_exchange) -> Cow<str>,
(routing_key, routing_key_mut, set_routing_key) -> Cow<str>,
} // impl_properties
    } // impl<'a> Return<'a>
    impl<'a> Default for Return<'a> {
        fn default() -> Self {
            Return::new(0, "", "", "")
        } // fn default()
    } // impl Default for Return

    impl<'a> ::Encodable for Return<'a> {
        fn encoded_size(&self) -> usize {
            [5,
             ::Encodable::encoded_size(&self.reply_text),
             ::Encodable::encoded_size(&self.exchange),
             ::Encodable::encoded_size(&self.routing_key)]
                .iter()
                .sum()
        } // fn encoded_size()
    } // impl Encodable

    impl<'a> ::ProtocolMethodPayload for Return<'a> {
        fn class_id(&self) -> u16 {
            70
        } // fn class_id()
        fn method_id(&self) -> u16 {
            70
        } // fn method_id()
    } // impl ::Payload for Return
    impl<'a> ::method::file::SetReturnMethodFields<'a> for Return<'a> {
        fn set_reply_code(&mut self, reply_code: u16) {
            self.set_reply_code(reply_code)
        } // set_reply_code()
        fn set_reply_text<V>(&mut self, reply_text: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_reply_text(reply_text.into())
        } // set_reply_text()
        fn set_exchange<V>(&mut self, exchange: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_exchange(exchange.into())
        } // set_exchange()
        fn set_routing_key<V>(&mut self, routing_key: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_routing_key(routing_key.into())
        } // set_routing_key()
    } // impl<'a> ::method::file::SetReturnMethodFields<'a> for Return<'a>
    impl ::method::file::StageMethod for ::Amqp8_0 {
        type Payload = Stage;
    } // impl ::method::file::StageMethod for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Stage;

    impl Stage {
        pub fn new() -> Self {
            Stage
        } // fn new()
    } // impl Stage
    impl Default for Stage {
        fn default() -> Self {
            Stage::new()
        } // fn default()
    } // impl Default for Stage

    impl ::Encodable for Stage {
        fn encoded_size(&self) -> usize {
            0
        } // fn encoded_size()
    } // impl Encodable

    impl ::ProtocolMethodPayload for Stage {
        fn class_id(&self) -> u16 {
            70
        } // fn class_id()
        fn method_id(&self) -> u16 {
            50
        } // fn method_id()
    } // impl ::Payload for Stage

    #[derive(Debug)]
    pub enum ClassMethod<'a> {
        Ack(Ack),
        Cancel(Cancel<'a>),
        CancelOk(CancelOk<'a>),
        Consume(Consume<'a>),
        ConsumeOk(ConsumeOk<'a>),
        Deliver(Deliver<'a>),
        Open(Open<'a>),
        OpenOk(OpenOk),
        Publish(Publish<'a>),
        Qos(Qos),
        QosOk(QosOk),
        Reject(Reject),
        Return(Return<'a>),
        Stage(Stage),
    } // enum ClassMethod


    impl<'a> ::Encodable for ClassMethod<'a> {
        fn encoded_size(&self) -> usize {
            match *self {
                ClassMethod::Ack(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::Cancel(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::CancelOk(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::Consume(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::ConsumeOk(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::Deliver(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::Open(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::OpenOk(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::Publish(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::Qos(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::QosOk(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::Reject(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::Return(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::Stage(ref method) => ::Encodable::encoded_size(method),

            } // match *self

        } // fn encoded_size
    } // impl ::Encodable for ClassMethod<'a>

    impl<'a> ::ProtocolMethodPayload for ClassMethod<'a> {
        fn class_id(&self) -> u16 {
            match *self {
                ClassMethod::Ack(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::Cancel(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::CancelOk(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::Consume(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::ConsumeOk(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::Deliver(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::Open(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::OpenOk(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::Publish(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::Qos(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::QosOk(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::Reject(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::Return(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::Stage(ref method) => ::ProtocolMethodPayload::class_id(method),

            } // match *self

        } // fn class_id

        fn method_id(&self) -> u16 {
            match *self {
                ClassMethod::Ack(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::Cancel(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::CancelOk(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::Consume(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::ConsumeOk(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::Deliver(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::Open(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::OpenOk(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::Publish(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::Qos(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::QosOk(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::Reject(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::Return(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::Stage(ref method) => ::ProtocolMethodPayload::method_id(method),

            } // match *self

        } // fn method_id
    } // impl ProtocolMethodPayload for ClassMethod
} // mod file

// generated by primalgen::codegen::spec_module::class_mod::ClassModuleWriter
pub mod queue {
    impl<'a> ::method::queue::BindMethod<'a> for ::Amqp8_0 {
        type Payload = Bind<'a>;
    } // impl<'a> ::method::queue::BindMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Bind<'a> {
        ticket: u16,
        queue: ::std::borrow::Cow<'a, str>,
        exchange: ::std::borrow::Cow<'a, str>,
        routing_key: ::std::borrow::Cow<'a, str>,
        no_wait: bool,
        arguments: ::field::TableEntries<'a>,
    } // struct Bind<'a>

    impl<'a> Bind<'a> {
        pub fn new<Q, E, R, A>(ticket: u16,
                               queue: Q,
                               exchange: E,
                               routing_key: R,
                               no_wait: bool,
                               arguments: A)
                               -> Self
            where Q: Into<::std::borrow::Cow<'a, str>>,
                  E: Into<::std::borrow::Cow<'a, str>>,
                  R: Into<::std::borrow::Cow<'a, str>>,
                  A: Into<::field::TableEntries<'a>>
        {
            Bind {
                ticket: ticket,
                queue: queue.into(),
                exchange: exchange.into(),
                routing_key: routing_key.into(),
                no_wait: no_wait,
                arguments: arguments.into(),
            } // Bind
        } // fn new()
        impl_properties! {
(ticket, set_ticket) -> u16,
(queue, queue_mut, set_queue) -> Cow<str>,
(exchange, exchange_mut, set_exchange) -> Cow<str>,
(routing_key, routing_key_mut, set_routing_key) -> Cow<str>,
(no_wait, set_no_wait) -> bool,
(arguments, arguments_mut, set_arguments) -> &::field::TableEntries<'a>,
} // impl_properties
    } // impl<'a> Bind<'a>
    impl<'a> Default for Bind<'a> {
        fn default() -> Self {
            Bind::new(0, "", "", "", false, ::field::TableEntries::new())
        } // fn default()
    } // impl Default for Bind

    impl<'a> ::Encodable for Bind<'a> {
        fn encoded_size(&self) -> usize {
            [6,
             ::Encodable::encoded_size(&self.queue),
             ::Encodable::encoded_size(&self.exchange),
             ::Encodable::encoded_size(&self.routing_key),
             ::Encodable::encoded_size(&self.arguments)]
                .iter()
                .sum()
        } // fn encoded_size()
    } // impl Encodable

    impl<'a> ::ProtocolMethodPayload for Bind<'a> {
        fn class_id(&self) -> u16 {
            50
        } // fn class_id()
        fn method_id(&self) -> u16 {
            20
        } // fn method_id()
    } // impl ::Payload for Bind
    impl<'a> ::method::queue::SetBindMethodFields<'a> for Bind<'a> {
        fn set_ticket(&mut self, ticket: u16) {
            self.set_ticket(ticket)
        } // set_ticket()
        fn set_queue<V>(&mut self, queue: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_queue(queue.into())
        } // set_queue()
        fn set_exchange<V>(&mut self, exchange: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_exchange(exchange.into())
        } // set_exchange()
        fn set_routing_key<V>(&mut self, routing_key: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_routing_key(routing_key.into())
        } // set_routing_key()
        fn set_no_wait(&mut self, no_wait: bool) {
            self.set_no_wait(no_wait)
        } // set_no_wait()
        fn set_arguments<V>(&mut self, arguments: V)
            where V: Into<::field::TableEntries<'a>>
        {
            self.set_arguments(arguments.into())
        } // set_arguments()
    } // impl<'a> ::method::queue::SetBindMethodFields<'a> for Bind<'a>
    impl ::method::queue::BindOkMethod for ::Amqp8_0 {
        type Payload = BindOk;
    } // impl ::method::queue::BindOkMethod for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct BindOk;

    impl BindOk {
        pub fn new() -> Self {
            BindOk
        } // fn new()
    } // impl BindOk
    impl Default for BindOk {
        fn default() -> Self {
            BindOk::new()
        } // fn default()
    } // impl Default for BindOk

    impl ::Encodable for BindOk {
        fn encoded_size(&self) -> usize {
            0
        } // fn encoded_size()
    } // impl Encodable

    impl ::ProtocolMethodPayload for BindOk {
        fn class_id(&self) -> u16 {
            50
        } // fn class_id()
        fn method_id(&self) -> u16 {
            21
        } // fn method_id()
    } // impl ::Payload for BindOk
    impl<'a> ::method::queue::DeclareMethod<'a> for ::Amqp8_0 {
        type Payload = Declare<'a>;
    } // impl<'a> ::method::queue::DeclareMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Declare<'a> {
        ticket: u16,
        queue: ::std::borrow::Cow<'a, str>,
        passive: bool,
        durable: bool,
        exclusive: bool,
        auto_delete: bool,
        no_wait: bool,
        arguments: ::field::TableEntries<'a>,
    } // struct Declare<'a>

    impl<'a> Declare<'a> {
        pub fn new<Q, A>(ticket: u16,
                         queue: Q,
                         passive: bool,
                         durable: bool,
                         exclusive: bool,
                         auto_delete: bool,
                         no_wait: bool,
                         arguments: A)
                         -> Self
            where Q: Into<::std::borrow::Cow<'a, str>>,
                  A: Into<::field::TableEntries<'a>>
        {
            Declare {
                ticket: ticket,
                queue: queue.into(),
                passive: passive,
                durable: durable,
                exclusive: exclusive,
                auto_delete: auto_delete,
                no_wait: no_wait,
                arguments: arguments.into(),
            } // Declare
        } // fn new()
        impl_properties! {
(ticket, set_ticket) -> u16,
(queue, queue_mut, set_queue) -> Cow<str>,
(passive, set_passive) -> bool,
(durable, set_durable) -> bool,
(exclusive, set_exclusive) -> bool,
(auto_delete, set_auto_delete) -> bool,
(no_wait, set_no_wait) -> bool,
(arguments, arguments_mut, set_arguments) -> &::field::TableEntries<'a>,
} // impl_properties
    } // impl<'a> Declare<'a>
    impl<'a> Default for Declare<'a> {
        fn default() -> Self {
            Declare::new(0,
                         "",
                         false,
                         false,
                         false,
                         false,
                         false,
                         ::field::TableEntries::new())
        } // fn default()
    } // impl Default for Declare

    impl<'a> ::Encodable for Declare<'a> {
        fn encoded_size(&self) -> usize {
            [4, ::Encodable::encoded_size(&self.queue), ::Encodable::encoded_size(&self.arguments)]
                .iter()
                .sum()
        } // fn encoded_size()
    } // impl Encodable

    impl<'a> ::ProtocolMethodPayload for Declare<'a> {
        fn class_id(&self) -> u16 {
            50
        } // fn class_id()
        fn method_id(&self) -> u16 {
            10
        } // fn method_id()
    } // impl ::Payload for Declare
    impl<'a> ::method::queue::SetDeclareMethodFields<'a> for Declare<'a> {
        fn set_ticket(&mut self, ticket: u16) {
            self.set_ticket(ticket)
        } // set_ticket()
        fn set_queue<V>(&mut self, queue: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_queue(queue.into())
        } // set_queue()
        fn set_passive(&mut self, passive: bool) {
            self.set_passive(passive)
        } // set_passive()
        fn set_durable(&mut self, durable: bool) {
            self.set_durable(durable)
        } // set_durable()
        fn set_exclusive(&mut self, exclusive: bool) {
            self.set_exclusive(exclusive)
        } // set_exclusive()
        fn set_auto_delete(&mut self, auto_delete: bool) {
            self.set_auto_delete(auto_delete)
        } // set_auto_delete()
        fn set_no_wait(&mut self, no_wait: bool) {
            self.set_no_wait(no_wait)
        } // set_no_wait()
        fn set_arguments<V>(&mut self, arguments: V)
            where V: Into<::field::TableEntries<'a>>
        {
            self.set_arguments(arguments.into())
        } // set_arguments()
    } // impl<'a> ::method::queue::SetDeclareMethodFields<'a> for Declare<'a>
    impl<'a> ::method::queue::DeclareOkMethod<'a> for ::Amqp8_0 {
        type Payload = DeclareOk<'a>;
    } // impl<'a> ::method::queue::DeclareOkMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct DeclareOk<'a> {
        queue: ::std::borrow::Cow<'a, str>,
        message_count: u32,
        consumer_count: u32,
    } // struct DeclareOk<'a>

    impl<'a> DeclareOk<'a> {
        pub fn new<Q>(queue: Q, message_count: u32, consumer_count: u32) -> Self
            where Q: Into<::std::borrow::Cow<'a, str>>
        {
            DeclareOk {
                queue: queue.into(),
                message_count: message_count,
                consumer_count: consumer_count,
            } // DeclareOk
        } // fn new()
        impl_properties! {
(queue, queue_mut, set_queue) -> Cow<str>,
(message_count, set_message_count) -> u32,
(consumer_count, set_consumer_count) -> u32,
} // impl_properties
    } // impl<'a> DeclareOk<'a>
    impl<'a> Default for DeclareOk<'a> {
        fn default() -> Self {
            DeclareOk::new("", 0, 0)
        } // fn default()
    } // impl Default for DeclareOk

    impl<'a> ::Encodable for DeclareOk<'a> {
        fn encoded_size(&self) -> usize {
            [9, ::Encodable::encoded_size(&self.queue)]
                .iter()
                .sum()
        } // fn encoded_size()
    } // impl Encodable

    impl<'a> ::ProtocolMethodPayload for DeclareOk<'a> {
        fn class_id(&self) -> u16 {
            50
        } // fn class_id()
        fn method_id(&self) -> u16 {
            11
        } // fn method_id()
    } // impl ::Payload for DeclareOk
    impl<'a> ::method::queue::SetDeclareOkMethodFields<'a> for DeclareOk<'a> {
        fn set_queue<V>(&mut self, queue: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_queue(queue.into())
        } // set_queue()
        fn set_message_count(&mut self, message_count: u32) {
            self.set_message_count(message_count)
        } // set_message_count()
        fn set_consumer_count(&mut self, consumer_count: u32) {
            self.set_consumer_count(consumer_count)
        } // set_consumer_count()
    } // impl<'a> ::method::queue::SetDeclareOkMethodFields<'a> for DeclareOk<'a>
    impl<'a> ::method::queue::DeleteMethod<'a> for ::Amqp8_0 {
        type Payload = Delete<'a>;
    } // impl<'a> ::method::queue::DeleteMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Delete<'a> {
        ticket: u16,
        queue: ::std::borrow::Cow<'a, str>,
        if_unused: bool,
        if_empty: bool,
        no_wait: bool,
    } // struct Delete<'a>

    impl<'a> Delete<'a> {
        pub fn new<Q>(ticket: u16, queue: Q, if_unused: bool, if_empty: bool, no_wait: bool) -> Self
            where Q: Into<::std::borrow::Cow<'a, str>>
        {
            Delete {
                ticket: ticket,
                queue: queue.into(),
                if_unused: if_unused,
                if_empty: if_empty,
                no_wait: no_wait,
            } // Delete
        } // fn new()
        impl_properties! {
(ticket, set_ticket) -> u16,
(queue, queue_mut, set_queue) -> Cow<str>,
(if_unused, set_if_unused) -> bool,
(if_empty, set_if_empty) -> bool,
(no_wait, set_no_wait) -> bool,
} // impl_properties
    } // impl<'a> Delete<'a>
    impl<'a> Default for Delete<'a> {
        fn default() -> Self {
            Delete::new(0, "", false, false, false)
        } // fn default()
    } // impl Default for Delete

    impl<'a> ::Encodable for Delete<'a> {
        fn encoded_size(&self) -> usize {
            [4, ::Encodable::encoded_size(&self.queue)]
                .iter()
                .sum()
        } // fn encoded_size()
    } // impl Encodable

    impl<'a> ::ProtocolMethodPayload for Delete<'a> {
        fn class_id(&self) -> u16 {
            50
        } // fn class_id()
        fn method_id(&self) -> u16 {
            40
        } // fn method_id()
    } // impl ::Payload for Delete
    impl<'a> ::method::queue::SetDeleteMethodFields<'a> for Delete<'a> {
        fn set_ticket(&mut self, ticket: u16) {
            self.set_ticket(ticket)
        } // set_ticket()
        fn set_queue<V>(&mut self, queue: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_queue(queue.into())
        } // set_queue()
        fn set_if_unused(&mut self, if_unused: bool) {
            self.set_if_unused(if_unused)
        } // set_if_unused()
        fn set_if_empty(&mut self, if_empty: bool) {
            self.set_if_empty(if_empty)
        } // set_if_empty()
        fn set_no_wait(&mut self, no_wait: bool) {
            self.set_no_wait(no_wait)
        } // set_no_wait()
    } // impl<'a> ::method::queue::SetDeleteMethodFields<'a> for Delete<'a>
    impl ::method::queue::DeleteOkMethod for ::Amqp8_0 {
        type Payload = DeleteOk;
    } // impl ::method::queue::DeleteOkMethod for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct DeleteOk {
        message_count: u32,
    } // struct DeleteOk

    impl DeleteOk {
        pub fn new(message_count: u32) -> Self {
            DeleteOk { message_count: message_count } // DeleteOk
        } // fn new()
        impl_properties! {
(message_count, set_message_count) -> u32,
} // impl_properties
    } // impl DeleteOk
    impl Default for DeleteOk {
        fn default() -> Self {
            DeleteOk::new(0)
        } // fn default()
    } // impl Default for DeleteOk

    impl ::Encodable for DeleteOk {
        fn encoded_size(&self) -> usize {
            4
        } // fn encoded_size()
    } // impl Encodable

    impl ::ProtocolMethodPayload for DeleteOk {
        fn class_id(&self) -> u16 {
            50
        } // fn class_id()
        fn method_id(&self) -> u16 {
            41
        } // fn method_id()
    } // impl ::Payload for DeleteOk
    impl ::method::queue::SetDeleteOkMethodFields for DeleteOk {
        fn set_message_count(&mut self, message_count: u32) {
            self.set_message_count(message_count)
        } // set_message_count()
    } // impl ::method::queue::SetDeleteOkMethodFields for DeleteOk
    impl<'a> ::method::queue::PurgeMethod<'a> for ::Amqp8_0 {
        type Payload = Purge<'a>;
    } // impl<'a> ::method::queue::PurgeMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Purge<'a> {
        ticket: u16,
        queue: ::std::borrow::Cow<'a, str>,
        no_wait: bool,
    } // struct Purge<'a>

    impl<'a> Purge<'a> {
        pub fn new<Q>(ticket: u16, queue: Q, no_wait: bool) -> Self
            where Q: Into<::std::borrow::Cow<'a, str>>
        {
            Purge {
                ticket: ticket,
                queue: queue.into(),
                no_wait: no_wait,
            } // Purge
        } // fn new()
        impl_properties! {
(ticket, set_ticket) -> u16,
(queue, queue_mut, set_queue) -> Cow<str>,
(no_wait, set_no_wait) -> bool,
} // impl_properties
    } // impl<'a> Purge<'a>
    impl<'a> Default for Purge<'a> {
        fn default() -> Self {
            Purge::new(0, "", false)
        } // fn default()
    } // impl Default for Purge

    impl<'a> ::Encodable for Purge<'a> {
        fn encoded_size(&self) -> usize {
            [4, ::Encodable::encoded_size(&self.queue)]
                .iter()
                .sum()
        } // fn encoded_size()
    } // impl Encodable

    impl<'a> ::ProtocolMethodPayload for Purge<'a> {
        fn class_id(&self) -> u16 {
            50
        } // fn class_id()
        fn method_id(&self) -> u16 {
            30
        } // fn method_id()
    } // impl ::Payload for Purge
    impl<'a> ::method::queue::SetPurgeMethodFields<'a> for Purge<'a> {
        fn set_ticket(&mut self, ticket: u16) {
            self.set_ticket(ticket)
        } // set_ticket()
        fn set_queue<V>(&mut self, queue: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_queue(queue.into())
        } // set_queue()
        fn set_no_wait(&mut self, no_wait: bool) {
            self.set_no_wait(no_wait)
        } // set_no_wait()
    } // impl<'a> ::method::queue::SetPurgeMethodFields<'a> for Purge<'a>
    impl ::method::queue::PurgeOkMethod for ::Amqp8_0 {
        type Payload = PurgeOk;
    } // impl ::method::queue::PurgeOkMethod for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct PurgeOk {
        message_count: u32,
    } // struct PurgeOk

    impl PurgeOk {
        pub fn new(message_count: u32) -> Self {
            PurgeOk { message_count: message_count } // PurgeOk
        } // fn new()
        impl_properties! {
(message_count, set_message_count) -> u32,
} // impl_properties
    } // impl PurgeOk
    impl Default for PurgeOk {
        fn default() -> Self {
            PurgeOk::new(0)
        } // fn default()
    } // impl Default for PurgeOk

    impl ::Encodable for PurgeOk {
        fn encoded_size(&self) -> usize {
            4
        } // fn encoded_size()
    } // impl Encodable

    impl ::ProtocolMethodPayload for PurgeOk {
        fn class_id(&self) -> u16 {
            50
        } // fn class_id()
        fn method_id(&self) -> u16 {
            31
        } // fn method_id()
    } // impl ::Payload for PurgeOk
    impl ::method::queue::SetPurgeOkMethodFields for PurgeOk {
        fn set_message_count(&mut self, message_count: u32) {
            self.set_message_count(message_count)
        } // set_message_count()
    } // impl ::method::queue::SetPurgeOkMethodFields for PurgeOk

    #[derive(Debug)]
    pub enum ClassMethod<'a> {
        Bind(Bind<'a>),
        BindOk(BindOk),
        Declare(Declare<'a>),
        DeclareOk(DeclareOk<'a>),
        Delete(Delete<'a>),
        DeleteOk(DeleteOk),
        Purge(Purge<'a>),
        PurgeOk(PurgeOk),
    } // enum ClassMethod


    impl<'a> ::Encodable for ClassMethod<'a> {
        fn encoded_size(&self) -> usize {
            match *self {
                ClassMethod::Bind(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::BindOk(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::Declare(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::DeclareOk(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::Delete(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::DeleteOk(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::Purge(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::PurgeOk(ref method) => ::Encodable::encoded_size(method),

            } // match *self

        } // fn encoded_size
    } // impl ::Encodable for ClassMethod<'a>

    impl<'a> ::ProtocolMethodPayload for ClassMethod<'a> {
        fn class_id(&self) -> u16 {
            match *self {
                ClassMethod::Bind(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::BindOk(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::Declare(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::DeclareOk(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::Delete(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::DeleteOk(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::Purge(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::PurgeOk(ref method) => ::ProtocolMethodPayload::class_id(method),

            } // match *self

        } // fn class_id

        fn method_id(&self) -> u16 {
            match *self {
                ClassMethod::Bind(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::BindOk(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::Declare(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::DeclareOk(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::Delete(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::DeleteOk(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::Purge(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::PurgeOk(ref method) => ::ProtocolMethodPayload::method_id(method),

            } // match *self

        } // fn method_id
    } // impl ProtocolMethodPayload for ClassMethod
} // mod queue

// generated by primalgen::codegen::spec_module::class_mod::ClassModuleWriter
pub mod stream {

    // Generated by primalgen::spec::frame_payload_enum::ClassEnumWriter
    #[derive(Debug)]
    pub struct Header<'a> {
        content_type: Option<::std::borrow::Cow<'a, str>>,
        content_encoding: Option<::std::borrow::Cow<'a, str>>,
        headers: Option<::field::TableEntries<'a>>,
        priority: Option<u8>,
        timestamp: Option<u64>,
    } // struct Header

    impl<'a> Header<'a> {
        impl_properties! {
(content_type, content_type_mut, set_content_type, take_content_type) -> Option< Cow<str> >,
(content_encoding, content_encoding_mut, set_content_encoding, take_content_encoding) -> Option< Cow<str> >,
(headers, headers_mut, set_headers, take_headers) -> Option< &::field::TableEntries<'a> >,
(priority, priority_mut, set_priority, take_priority) -> Option< u8 >,
(timestamp, timestamp_mut, set_timestamp, take_timestamp) -> Option< u64 >,
} // impl_properties
    } // impl Headers

    impl<'a> ::Encodable for Header<'a> {
        fn encoded_size(&self) -> usize {
            unimplemented!()
        } // fn encoded_size
    } // impl ::Encodable for Header<'a>
    impl<'a> ::method::stream::CancelMethod<'a> for ::Amqp8_0 {
        type Payload = Cancel<'a>;
    } // impl<'a> ::method::stream::CancelMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Cancel<'a> {
        consumer_tag: ::std::borrow::Cow<'a, str>,
        no_wait: bool,
    } // struct Cancel<'a>

    impl<'a> Cancel<'a> {
        pub fn new<C>(consumer_tag: C, no_wait: bool) -> Self
            where C: Into<::std::borrow::Cow<'a, str>>
        {
            Cancel {
                consumer_tag: consumer_tag.into(),
                no_wait: no_wait,
            } // Cancel
        } // fn new()
        impl_properties! {
(consumer_tag, consumer_tag_mut, set_consumer_tag) -> Cow<str>,
(no_wait, set_no_wait) -> bool,
} // impl_properties
    } // impl<'a> Cancel<'a>
    impl<'a> Default for Cancel<'a> {
        fn default() -> Self {
            Cancel::new("", false)
        } // fn default()
    } // impl Default for Cancel

    impl<'a> ::Encodable for Cancel<'a> {
        fn encoded_size(&self) -> usize {
            [2, ::Encodable::encoded_size(&self.consumer_tag)]
                .iter()
                .sum()
        } // fn encoded_size()
    } // impl Encodable

    impl<'a> ::ProtocolMethodPayload for Cancel<'a> {
        fn class_id(&self) -> u16 {
            80
        } // fn class_id()
        fn method_id(&self) -> u16 {
            30
        } // fn method_id()
    } // impl ::Payload for Cancel
    impl<'a> ::method::stream::SetCancelMethodFields<'a> for Cancel<'a> {
        fn set_consumer_tag<V>(&mut self, consumer_tag: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_consumer_tag(consumer_tag.into())
        } // set_consumer_tag()
        fn set_no_wait(&mut self, no_wait: bool) {
            self.set_no_wait(no_wait)
        } // set_no_wait()
    } // impl<'a> ::method::stream::SetCancelMethodFields<'a> for Cancel<'a>
    impl<'a> ::method::stream::CancelOkMethod<'a> for ::Amqp8_0 {
        type Payload = CancelOk<'a>;
    } // impl<'a> ::method::stream::CancelOkMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct CancelOk<'a> {
        consumer_tag: ::std::borrow::Cow<'a, str>,
    } // struct CancelOk<'a>

    impl<'a> CancelOk<'a> {
        pub fn new<C>(consumer_tag: C) -> Self
            where C: Into<::std::borrow::Cow<'a, str>>
        {
            CancelOk { consumer_tag: consumer_tag.into() } // CancelOk
        } // fn new()
        impl_properties! {
(consumer_tag, consumer_tag_mut, set_consumer_tag) -> Cow<str>,
} // impl_properties
    } // impl<'a> CancelOk<'a>
    impl<'a> Default for CancelOk<'a> {
        fn default() -> Self {
            CancelOk::new("")
        } // fn default()
    } // impl Default for CancelOk

    impl<'a> ::Encodable for CancelOk<'a> {
        fn encoded_size(&self) -> usize {
            [1, ::Encodable::encoded_size(&self.consumer_tag)]
                .iter()
                .sum()
        } // fn encoded_size()
    } // impl Encodable

    impl<'a> ::ProtocolMethodPayload for CancelOk<'a> {
        fn class_id(&self) -> u16 {
            80
        } // fn class_id()
        fn method_id(&self) -> u16 {
            31
        } // fn method_id()
    } // impl ::Payload for CancelOk
    impl<'a> ::method::stream::SetCancelOkMethodFields<'a> for CancelOk<'a> {
        fn set_consumer_tag<V>(&mut self, consumer_tag: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_consumer_tag(consumer_tag.into())
        } // set_consumer_tag()
    } // impl<'a> ::method::stream::SetCancelOkMethodFields<'a> for CancelOk<'a>
    impl<'a> ::method::stream::ConsumeMethod<'a> for ::Amqp8_0 {
        type Payload = Consume<'a>;
    } // impl<'a> ::method::stream::ConsumeMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Consume<'a> {
        ticket: u16,
        queue: ::std::borrow::Cow<'a, str>,
        consumer_tag: ::std::borrow::Cow<'a, str>,
        no_local: bool,
        exclusive: bool,
        no_wait: bool,
    } // struct Consume<'a>

    impl<'a> Consume<'a> {
        pub fn new<Q, C>(ticket: u16,
                         queue: Q,
                         consumer_tag: C,
                         no_local: bool,
                         exclusive: bool,
                         no_wait: bool)
                         -> Self
            where Q: Into<::std::borrow::Cow<'a, str>>,
                  C: Into<::std::borrow::Cow<'a, str>>
        {
            Consume {
                ticket: ticket,
                queue: queue.into(),
                consumer_tag: consumer_tag.into(),
                no_local: no_local,
                exclusive: exclusive,
                no_wait: no_wait,
            } // Consume
        } // fn new()
        impl_properties! {
(ticket, set_ticket) -> u16,
(queue, queue_mut, set_queue) -> Cow<str>,
(consumer_tag, consumer_tag_mut, set_consumer_tag) -> Cow<str>,
(no_local, set_no_local) -> bool,
(exclusive, set_exclusive) -> bool,
(no_wait, set_no_wait) -> bool,
} // impl_properties
    } // impl<'a> Consume<'a>
    impl<'a> Default for Consume<'a> {
        fn default() -> Self {
            Consume::new(0, "", "", false, false, false)
        } // fn default()
    } // impl Default for Consume

    impl<'a> ::Encodable for Consume<'a> {
        fn encoded_size(&self) -> usize {
            [5,
             ::Encodable::encoded_size(&self.queue),
             ::Encodable::encoded_size(&self.consumer_tag)]
                .iter()
                .sum()
        } // fn encoded_size()
    } // impl Encodable

    impl<'a> ::ProtocolMethodPayload for Consume<'a> {
        fn class_id(&self) -> u16 {
            80
        } // fn class_id()
        fn method_id(&self) -> u16 {
            20
        } // fn method_id()
    } // impl ::Payload for Consume
    impl<'a> ::method::stream::SetConsumeMethodFields<'a> for Consume<'a> {
        fn set_ticket(&mut self, ticket: u16) {
            self.set_ticket(ticket)
        } // set_ticket()
        fn set_queue<V>(&mut self, queue: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_queue(queue.into())
        } // set_queue()
        fn set_consumer_tag<V>(&mut self, consumer_tag: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_consumer_tag(consumer_tag.into())
        } // set_consumer_tag()
        fn set_no_local(&mut self, no_local: bool) {
            self.set_no_local(no_local)
        } // set_no_local()
        fn set_exclusive(&mut self, exclusive: bool) {
            self.set_exclusive(exclusive)
        } // set_exclusive()
        fn set_no_wait(&mut self, no_wait: bool) {
            self.set_no_wait(no_wait)
        } // set_no_wait()
    } // impl<'a> ::method::stream::SetConsumeMethodFields<'a> for Consume<'a>
    impl<'a> ::method::stream::ConsumeOkMethod<'a> for ::Amqp8_0 {
        type Payload = ConsumeOk<'a>;
    } // impl<'a> ::method::stream::ConsumeOkMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct ConsumeOk<'a> {
        consumer_tag: ::std::borrow::Cow<'a, str>,
    } // struct ConsumeOk<'a>

    impl<'a> ConsumeOk<'a> {
        pub fn new<C>(consumer_tag: C) -> Self
            where C: Into<::std::borrow::Cow<'a, str>>
        {
            ConsumeOk { consumer_tag: consumer_tag.into() } // ConsumeOk
        } // fn new()
        impl_properties! {
(consumer_tag, consumer_tag_mut, set_consumer_tag) -> Cow<str>,
} // impl_properties
    } // impl<'a> ConsumeOk<'a>
    impl<'a> Default for ConsumeOk<'a> {
        fn default() -> Self {
            ConsumeOk::new("")
        } // fn default()
    } // impl Default for ConsumeOk

    impl<'a> ::Encodable for ConsumeOk<'a> {
        fn encoded_size(&self) -> usize {
            [1, ::Encodable::encoded_size(&self.consumer_tag)]
                .iter()
                .sum()
        } // fn encoded_size()
    } // impl Encodable

    impl<'a> ::ProtocolMethodPayload for ConsumeOk<'a> {
        fn class_id(&self) -> u16 {
            80
        } // fn class_id()
        fn method_id(&self) -> u16 {
            21
        } // fn method_id()
    } // impl ::Payload for ConsumeOk
    impl<'a> ::method::stream::SetConsumeOkMethodFields<'a> for ConsumeOk<'a> {
        fn set_consumer_tag<V>(&mut self, consumer_tag: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_consumer_tag(consumer_tag.into())
        } // set_consumer_tag()
    } // impl<'a> ::method::stream::SetConsumeOkMethodFields<'a> for ConsumeOk<'a>
    impl<'a> ::method::stream::DeliverMethod<'a> for ::Amqp8_0 {
        type Payload = Deliver<'a>;
    } // impl<'a> ::method::stream::DeliverMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Deliver<'a> {
        consumer_tag: ::std::borrow::Cow<'a, str>,
        delivery_tag: u64,
        exchange: ::std::borrow::Cow<'a, str>,
        queue: ::std::borrow::Cow<'a, str>,
    } // struct Deliver<'a>

    impl<'a> Deliver<'a> {
        pub fn new<C, E, Q>(consumer_tag: C, delivery_tag: u64, exchange: E, queue: Q) -> Self
            where C: Into<::std::borrow::Cow<'a, str>>,
                  E: Into<::std::borrow::Cow<'a, str>>,
                  Q: Into<::std::borrow::Cow<'a, str>>
        {
            Deliver {
                consumer_tag: consumer_tag.into(),
                delivery_tag: delivery_tag,
                exchange: exchange.into(),
                queue: queue.into(),
            } // Deliver
        } // fn new()
        impl_properties! {
(consumer_tag, consumer_tag_mut, set_consumer_tag) -> Cow<str>,
(delivery_tag, set_delivery_tag) -> u64,
(exchange, exchange_mut, set_exchange) -> Cow<str>,
(queue, queue_mut, set_queue) -> Cow<str>,
} // impl_properties
    } // impl<'a> Deliver<'a>
    impl<'a> Default for Deliver<'a> {
        fn default() -> Self {
            Deliver::new("", 0, "", "")
        } // fn default()
    } // impl Default for Deliver

    impl<'a> ::Encodable for Deliver<'a> {
        fn encoded_size(&self) -> usize {
            [11,
             ::Encodable::encoded_size(&self.consumer_tag),
             ::Encodable::encoded_size(&self.exchange),
             ::Encodable::encoded_size(&self.queue)]
                .iter()
                .sum()
        } // fn encoded_size()
    } // impl Encodable

    impl<'a> ::ProtocolMethodPayload for Deliver<'a> {
        fn class_id(&self) -> u16 {
            80
        } // fn class_id()
        fn method_id(&self) -> u16 {
            60
        } // fn method_id()
    } // impl ::Payload for Deliver
    impl<'a> ::method::stream::SetDeliverMethodFields<'a> for Deliver<'a> {
        fn set_consumer_tag<V>(&mut self, consumer_tag: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_consumer_tag(consumer_tag.into())
        } // set_consumer_tag()
        fn set_delivery_tag(&mut self, delivery_tag: u64) {
            self.set_delivery_tag(delivery_tag)
        } // set_delivery_tag()
        fn set_exchange<V>(&mut self, exchange: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_exchange(exchange.into())
        } // set_exchange()
        fn set_queue<V>(&mut self, queue: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_queue(queue.into())
        } // set_queue()
    } // impl<'a> ::method::stream::SetDeliverMethodFields<'a> for Deliver<'a>
    impl<'a> ::method::stream::PublishMethod<'a> for ::Amqp8_0 {
        type Payload = Publish<'a>;
    } // impl<'a> ::method::stream::PublishMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Publish<'a> {
        ticket: u16,
        exchange: ::std::borrow::Cow<'a, str>,
        routing_key: ::std::borrow::Cow<'a, str>,
        mandatory: bool,
        immediate: bool,
    } // struct Publish<'a>

    impl<'a> Publish<'a> {
        pub fn new<E, R>(ticket: u16,
                         exchange: E,
                         routing_key: R,
                         mandatory: bool,
                         immediate: bool)
                         -> Self
            where E: Into<::std::borrow::Cow<'a, str>>,
                  R: Into<::std::borrow::Cow<'a, str>>
        {
            Publish {
                ticket: ticket,
                exchange: exchange.into(),
                routing_key: routing_key.into(),
                mandatory: mandatory,
                immediate: immediate,
            } // Publish
        } // fn new()
        impl_properties! {
(ticket, set_ticket) -> u16,
(exchange, exchange_mut, set_exchange) -> Cow<str>,
(routing_key, routing_key_mut, set_routing_key) -> Cow<str>,
(mandatory, set_mandatory) -> bool,
(immediate, set_immediate) -> bool,
} // impl_properties
    } // impl<'a> Publish<'a>
    impl<'a> Default for Publish<'a> {
        fn default() -> Self {
            Publish::new(0, "", "", false, false)
        } // fn default()
    } // impl Default for Publish

    impl<'a> ::Encodable for Publish<'a> {
        fn encoded_size(&self) -> usize {
            [5,
             ::Encodable::encoded_size(&self.exchange),
             ::Encodable::encoded_size(&self.routing_key)]
                .iter()
                .sum()
        } // fn encoded_size()
    } // impl Encodable

    impl<'a> ::ProtocolMethodPayload for Publish<'a> {
        fn class_id(&self) -> u16 {
            80
        } // fn class_id()
        fn method_id(&self) -> u16 {
            40
        } // fn method_id()
    } // impl ::Payload for Publish
    impl<'a> ::method::stream::SetPublishMethodFields<'a> for Publish<'a> {
        fn set_ticket(&mut self, ticket: u16) {
            self.set_ticket(ticket)
        } // set_ticket()
        fn set_exchange<V>(&mut self, exchange: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_exchange(exchange.into())
        } // set_exchange()
        fn set_routing_key<V>(&mut self, routing_key: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_routing_key(routing_key.into())
        } // set_routing_key()
        fn set_mandatory(&mut self, mandatory: bool) {
            self.set_mandatory(mandatory)
        } // set_mandatory()
        fn set_immediate(&mut self, immediate: bool) {
            self.set_immediate(immediate)
        } // set_immediate()
    } // impl<'a> ::method::stream::SetPublishMethodFields<'a> for Publish<'a>
    impl ::method::stream::QosMethod for ::Amqp8_0 {
        type Payload = Qos;
    } // impl ::method::stream::QosMethod for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Qos {
        prefetch_size: u32,
        prefetch_count: u16,
        consume_rate: u32,
        global: bool,
    } // struct Qos

    impl Qos {
        pub fn new(prefetch_size: u32,
                   prefetch_count: u16,
                   consume_rate: u32,
                   global: bool)
                   -> Self {
            Qos {
                prefetch_size: prefetch_size,
                prefetch_count: prefetch_count,
                consume_rate: consume_rate,
                global: global,
            } // Qos
        } // fn new()
        impl_properties! {
(prefetch_size, set_prefetch_size) -> u32,
(prefetch_count, set_prefetch_count) -> u16,
(consume_rate, set_consume_rate) -> u32,
(global, set_global) -> bool,
} // impl_properties
    } // impl Qos
    impl Default for Qos {
        fn default() -> Self {
            Qos::new(0, 0, 0, false)
        } // fn default()
    } // impl Default for Qos

    impl ::Encodable for Qos {
        fn encoded_size(&self) -> usize {
            11
        } // fn encoded_size()
    } // impl Encodable

    impl ::ProtocolMethodPayload for Qos {
        fn class_id(&self) -> u16 {
            80
        } // fn class_id()
        fn method_id(&self) -> u16 {
            10
        } // fn method_id()
    } // impl ::Payload for Qos
    impl ::method::stream::SetQosMethodFields for Qos {
        fn set_prefetch_size(&mut self, prefetch_size: u32) {
            self.set_prefetch_size(prefetch_size)
        } // set_prefetch_size()
        fn set_prefetch_count(&mut self, prefetch_count: u16) {
            self.set_prefetch_count(prefetch_count)
        } // set_prefetch_count()
        fn set_consume_rate(&mut self, consume_rate: u32) {
            self.set_consume_rate(consume_rate)
        } // set_consume_rate()
        fn set_global(&mut self, global: bool) {
            self.set_global(global)
        } // set_global()
    } // impl ::method::stream::SetQosMethodFields for Qos
    impl ::method::stream::QosOkMethod for ::Amqp8_0 {
        type Payload = QosOk;
    } // impl ::method::stream::QosOkMethod for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct QosOk;

    impl QosOk {
        pub fn new() -> Self {
            QosOk
        } // fn new()
    } // impl QosOk
    impl Default for QosOk {
        fn default() -> Self {
            QosOk::new()
        } // fn default()
    } // impl Default for QosOk

    impl ::Encodable for QosOk {
        fn encoded_size(&self) -> usize {
            0
        } // fn encoded_size()
    } // impl Encodable

    impl ::ProtocolMethodPayload for QosOk {
        fn class_id(&self) -> u16 {
            80
        } // fn class_id()
        fn method_id(&self) -> u16 {
            11
        } // fn method_id()
    } // impl ::Payload for QosOk
    impl<'a> ::method::stream::ReturnMethod<'a> for ::Amqp8_0 {
        type Payload = Return<'a>;
    } // impl<'a> ::method::stream::ReturnMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Return<'a> {
        reply_code: u16,
        reply_text: ::std::borrow::Cow<'a, str>,
        exchange: ::std::borrow::Cow<'a, str>,
        routing_key: ::std::borrow::Cow<'a, str>,
    } // struct Return<'a>

    impl<'a> Return<'a> {
        pub fn new<R, E, R0>(reply_code: u16, reply_text: R, exchange: E, routing_key: R0) -> Self
            where R: Into<::std::borrow::Cow<'a, str>>,
                  E: Into<::std::borrow::Cow<'a, str>>,
                  R0: Into<::std::borrow::Cow<'a, str>>
        {
            Return {
                reply_code: reply_code,
                reply_text: reply_text.into(),
                exchange: exchange.into(),
                routing_key: routing_key.into(),
            } // Return
        } // fn new()
        impl_properties! {
(reply_code, set_reply_code) -> u16,
(reply_text, reply_text_mut, set_reply_text) -> Cow<str>,
(exchange, exchange_mut, set_exchange) -> Cow<str>,
(routing_key, routing_key_mut, set_routing_key) -> Cow<str>,
} // impl_properties
    } // impl<'a> Return<'a>
    impl<'a> Default for Return<'a> {
        fn default() -> Self {
            Return::new(0, "", "", "")
        } // fn default()
    } // impl Default for Return

    impl<'a> ::Encodable for Return<'a> {
        fn encoded_size(&self) -> usize {
            [5,
             ::Encodable::encoded_size(&self.reply_text),
             ::Encodable::encoded_size(&self.exchange),
             ::Encodable::encoded_size(&self.routing_key)]
                .iter()
                .sum()
        } // fn encoded_size()
    } // impl Encodable

    impl<'a> ::ProtocolMethodPayload for Return<'a> {
        fn class_id(&self) -> u16 {
            80
        } // fn class_id()
        fn method_id(&self) -> u16 {
            50
        } // fn method_id()
    } // impl ::Payload for Return
    impl<'a> ::method::stream::SetReturnMethodFields<'a> for Return<'a> {
        fn set_reply_code(&mut self, reply_code: u16) {
            self.set_reply_code(reply_code)
        } // set_reply_code()
        fn set_reply_text<V>(&mut self, reply_text: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_reply_text(reply_text.into())
        } // set_reply_text()
        fn set_exchange<V>(&mut self, exchange: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_exchange(exchange.into())
        } // set_exchange()
        fn set_routing_key<V>(&mut self, routing_key: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_routing_key(routing_key.into())
        } // set_routing_key()
    } // impl<'a> ::method::stream::SetReturnMethodFields<'a> for Return<'a>

    #[derive(Debug)]
    pub enum ClassMethod<'a> {
        Cancel(Cancel<'a>),
        CancelOk(CancelOk<'a>),
        Consume(Consume<'a>),
        ConsumeOk(ConsumeOk<'a>),
        Deliver(Deliver<'a>),
        Publish(Publish<'a>),
        Qos(Qos),
        QosOk(QosOk),
        Return(Return<'a>),
    } // enum ClassMethod


    impl<'a> ::Encodable for ClassMethod<'a> {
        fn encoded_size(&self) -> usize {
            match *self {
                ClassMethod::Cancel(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::CancelOk(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::Consume(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::ConsumeOk(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::Deliver(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::Publish(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::Qos(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::QosOk(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::Return(ref method) => ::Encodable::encoded_size(method),

            } // match *self

        } // fn encoded_size
    } // impl ::Encodable for ClassMethod<'a>

    impl<'a> ::ProtocolMethodPayload for ClassMethod<'a> {
        fn class_id(&self) -> u16 {
            match *self {
                ClassMethod::Cancel(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::CancelOk(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::Consume(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::ConsumeOk(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::Deliver(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::Publish(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::Qos(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::QosOk(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::Return(ref method) => ::ProtocolMethodPayload::class_id(method),

            } // match *self

        } // fn class_id

        fn method_id(&self) -> u16 {
            match *self {
                ClassMethod::Cancel(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::CancelOk(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::Consume(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::ConsumeOk(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::Deliver(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::Publish(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::Qos(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::QosOk(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::Return(ref method) => ::ProtocolMethodPayload::method_id(method),

            } // match *self

        } // fn method_id
    } // impl ProtocolMethodPayload for ClassMethod
} // mod stream

// generated by primalgen::codegen::spec_module::class_mod::ClassModuleWriter
pub mod test {
    impl ::method::test::ContentMethod for ::Amqp8_0 {
        type Payload = Content;
    } // impl ::method::test::ContentMethod for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Content;

    impl Content {
        pub fn new() -> Self {
            Content
        } // fn new()
    } // impl Content
    impl Default for Content {
        fn default() -> Self {
            Content::new()
        } // fn default()
    } // impl Default for Content

    impl ::Encodable for Content {
        fn encoded_size(&self) -> usize {
            0
        } // fn encoded_size()
    } // impl Encodable

    impl ::ProtocolMethodPayload for Content {
        fn class_id(&self) -> u16 {
            120
        } // fn class_id()
        fn method_id(&self) -> u16 {
            40
        } // fn method_id()
    } // impl ::Payload for Content
    impl ::method::test::ContentOkMethod for ::Amqp8_0 {
        type Payload = ContentOk;
    } // impl ::method::test::ContentOkMethod for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct ContentOk {
        content_checksum: u32,
    } // struct ContentOk

    impl ContentOk {
        pub fn new(content_checksum: u32) -> Self {
            ContentOk { content_checksum: content_checksum } // ContentOk
        } // fn new()
        impl_properties! {
(content_checksum, set_content_checksum) -> u32,
} // impl_properties
    } // impl ContentOk
    impl Default for ContentOk {
        fn default() -> Self {
            ContentOk::new(0)
        } // fn default()
    } // impl Default for ContentOk

    impl ::Encodable for ContentOk {
        fn encoded_size(&self) -> usize {
            4
        } // fn encoded_size()
    } // impl Encodable

    impl ::ProtocolMethodPayload for ContentOk {
        fn class_id(&self) -> u16 {
            120
        } // fn class_id()
        fn method_id(&self) -> u16 {
            41
        } // fn method_id()
    } // impl ::Payload for ContentOk
    impl ::method::test::SetContentOkMethodFields for ContentOk {
        fn set_content_checksum(&mut self, content_checksum: u32) {
            self.set_content_checksum(content_checksum)
        } // set_content_checksum()
    } // impl ::method::test::SetContentOkMethodFields for ContentOk
    impl ::method::test::IntegerMethod for ::Amqp8_0 {
        type Payload = Integer;
    } // impl ::method::test::IntegerMethod for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Integer {
        integer_1: u8,
        integer_2: u16,
        integer_3: u32,
        integer_4: u64,
        operation: u8,
    } // struct Integer

    impl Integer {
        pub fn new(integer_1: u8,
                   integer_2: u16,
                   integer_3: u32,
                   integer_4: u64,
                   operation: u8)
                   -> Self {
            Integer {
                integer_1: integer_1,
                integer_2: integer_2,
                integer_3: integer_3,
                integer_4: integer_4,
                operation: operation,
            } // Integer
        } // fn new()
        impl_properties! {
(integer_1, set_integer_1) -> u8,
(integer_2, set_integer_2) -> u16,
(integer_3, set_integer_3) -> u32,
(integer_4, set_integer_4) -> u64,
(operation, set_operation) -> u8,
} // impl_properties
    } // impl Integer
    impl Default for Integer {
        fn default() -> Self {
            Integer::new(0, 0, 0, 0, 0)
        } // fn default()
    } // impl Default for Integer

    impl ::Encodable for Integer {
        fn encoded_size(&self) -> usize {
            16
        } // fn encoded_size()
    } // impl Encodable

    impl ::ProtocolMethodPayload for Integer {
        fn class_id(&self) -> u16 {
            120
        } // fn class_id()
        fn method_id(&self) -> u16 {
            10
        } // fn method_id()
    } // impl ::Payload for Integer
    impl ::method::test::SetIntegerMethodFields for Integer {
        fn set_integer_1(&mut self, integer_1: u8) {
            self.set_integer_1(integer_1)
        } // set_integer_1()
        fn set_integer_2(&mut self, integer_2: u16) {
            self.set_integer_2(integer_2)
        } // set_integer_2()
        fn set_integer_3(&mut self, integer_3: u32) {
            self.set_integer_3(integer_3)
        } // set_integer_3()
        fn set_integer_4(&mut self, integer_4: u64) {
            self.set_integer_4(integer_4)
        } // set_integer_4()
        fn set_operation(&mut self, operation: u8) {
            self.set_operation(operation)
        } // set_operation()
    } // impl ::method::test::SetIntegerMethodFields for Integer
    impl ::method::test::IntegerOkMethod for ::Amqp8_0 {
        type Payload = IntegerOk;
    } // impl ::method::test::IntegerOkMethod for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct IntegerOk {
        result: u64,
    } // struct IntegerOk

    impl IntegerOk {
        pub fn new(result: u64) -> Self {
            IntegerOk { result: result } // IntegerOk
        } // fn new()
        impl_properties! {
(result, set_result) -> u64,
} // impl_properties
    } // impl IntegerOk
    impl Default for IntegerOk {
        fn default() -> Self {
            IntegerOk::new(0)
        } // fn default()
    } // impl Default for IntegerOk

    impl ::Encodable for IntegerOk {
        fn encoded_size(&self) -> usize {
            8
        } // fn encoded_size()
    } // impl Encodable

    impl ::ProtocolMethodPayload for IntegerOk {
        fn class_id(&self) -> u16 {
            120
        } // fn class_id()
        fn method_id(&self) -> u16 {
            11
        } // fn method_id()
    } // impl ::Payload for IntegerOk
    impl ::method::test::SetIntegerOkMethodFields for IntegerOk {
        fn set_result(&mut self, result: u64) {
            self.set_result(result)
        } // set_result()
    } // impl ::method::test::SetIntegerOkMethodFields for IntegerOk
    impl<'a> ::method::test::StringMethod<'a> for ::Amqp8_0 {
        type Payload = String<'a>;
    } // impl<'a> ::method::test::StringMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct String<'a> {
        string_1: ::std::borrow::Cow<'a, str>,
        string_2: ::std::borrow::Cow<'a, [u8]>,
        operation: u8,
    } // struct String<'a>

    impl<'a> String<'a> {
        pub fn new<S, S0>(string_1: S, string_2: S0, operation: u8) -> Self
            where S: Into<::std::borrow::Cow<'a, str>>,
                  S0: Into<::std::borrow::Cow<'a, [u8]>>
        {
            String {
                string_1: string_1.into(),
                string_2: string_2.into(),
                operation: operation,
            } // String
        } // fn new()
        impl_properties! {
(string_1, string_1_mut, set_string_1) -> Cow<str>,
(string_2, string_2_mut, set_string_2) -> Cow<[u8]>,
(operation, set_operation) -> u8,
} // impl_properties
    } // impl<'a> String<'a>
    impl<'a> Default for String<'a> {
        fn default() -> Self {
            String::new("", &[][..], 0)
        } // fn default()
    } // impl Default for String

    impl<'a> ::Encodable for String<'a> {
        fn encoded_size(&self) -> usize {
            [4,
             ::Encodable::encoded_size(&self.string_1),
             ::Encodable::encoded_size(&self.string_2)]
                .iter()
                .sum()
        } // fn encoded_size()
    } // impl Encodable

    impl<'a> ::ProtocolMethodPayload for String<'a> {
        fn class_id(&self) -> u16 {
            120
        } // fn class_id()
        fn method_id(&self) -> u16 {
            20
        } // fn method_id()
    } // impl ::Payload for String
    impl<'a> ::method::test::SetStringMethodFields<'a> for String<'a> {
        fn set_string_1<V>(&mut self, string_1: V)
            where V: Into<::std::borrow::Cow<'a, str>>
        {
            self.set_string_1(string_1.into())
        } // set_string_1()
        fn set_string_2<V>(&mut self, string_2: V)
            where V: Into<::std::borrow::Cow<'a, [u8]>>
        {
            self.set_string_2(string_2.into())
        } // set_string_2()
        fn set_operation(&mut self, operation: u8) {
            self.set_operation(operation)
        } // set_operation()
    } // impl<'a> ::method::test::SetStringMethodFields<'a> for String<'a>
    impl<'a> ::method::test::StringOkMethod<'a> for ::Amqp8_0 {
        type Payload = StringOk<'a>;
    } // impl<'a> ::method::test::StringOkMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct StringOk<'a> {
        result: ::std::borrow::Cow<'a, [u8]>,
    } // struct StringOk<'a>

    impl<'a> StringOk<'a> {
        pub fn new<R>(result: R) -> Self
            where R: Into<::std::borrow::Cow<'a, [u8]>>
        {
            StringOk { result: result.into() } // StringOk
        } // fn new()
        impl_properties! {
(result, result_mut, set_result) -> Cow<[u8]>,
} // impl_properties
    } // impl<'a> StringOk<'a>
    impl<'a> Default for StringOk<'a> {
        fn default() -> Self {
            StringOk::new(&[][..])
        } // fn default()
    } // impl Default for StringOk

    impl<'a> ::Encodable for StringOk<'a> {
        fn encoded_size(&self) -> usize {
            [2, ::Encodable::encoded_size(&self.result)]
                .iter()
                .sum()
        } // fn encoded_size()
    } // impl Encodable

    impl<'a> ::ProtocolMethodPayload for StringOk<'a> {
        fn class_id(&self) -> u16 {
            120
        } // fn class_id()
        fn method_id(&self) -> u16 {
            21
        } // fn method_id()
    } // impl ::Payload for StringOk
    impl<'a> ::method::test::SetStringOkMethodFields<'a> for StringOk<'a> {
        fn set_result<V>(&mut self, result: V)
            where V: Into<::std::borrow::Cow<'a, [u8]>>
        {
            self.set_result(result.into())
        } // set_result()
    } // impl<'a> ::method::test::SetStringOkMethodFields<'a> for StringOk<'a>
    impl<'a> ::method::test::TableMethod<'a> for ::Amqp8_0 {
        type Payload = Table<'a>;
    } // impl<'a> ::method::test::TableMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Table<'a> {
        table: ::field::TableEntries<'a>,
        integer_op: u8,
        string_op: u8,
    } // struct Table<'a>

    impl<'a> Table<'a> {
        pub fn new<T>(table: T, integer_op: u8, string_op: u8) -> Self
            where T: Into<::field::TableEntries<'a>>
        {
            Table {
                table: table.into(),
                integer_op: integer_op,
                string_op: string_op,
            } // Table
        } // fn new()
        impl_properties! {
(table, table_mut, set_table) -> &::field::TableEntries<'a>,
(integer_op, set_integer_op) -> u8,
(string_op, set_string_op) -> u8,
} // impl_properties
    } // impl<'a> Table<'a>
    impl<'a> Default for Table<'a> {
        fn default() -> Self {
            Table::new(::field::TableEntries::new(), 0, 0)
        } // fn default()
    } // impl Default for Table

    impl<'a> ::Encodable for Table<'a> {
        fn encoded_size(&self) -> usize {
            [2, ::Encodable::encoded_size(&self.table)]
                .iter()
                .sum()
        } // fn encoded_size()
    } // impl Encodable

    impl<'a> ::ProtocolMethodPayload for Table<'a> {
        fn class_id(&self) -> u16 {
            120
        } // fn class_id()
        fn method_id(&self) -> u16 {
            30
        } // fn method_id()
    } // impl ::Payload for Table
    impl<'a> ::method::test::SetTableMethodFields<'a> for Table<'a> {
        fn set_table<V>(&mut self, table: V)
            where V: Into<::field::TableEntries<'a>>
        {
            self.set_table(table.into())
        } // set_table()
        fn set_integer_op(&mut self, integer_op: u8) {
            self.set_integer_op(integer_op)
        } // set_integer_op()
        fn set_string_op(&mut self, string_op: u8) {
            self.set_string_op(string_op)
        } // set_string_op()
    } // impl<'a> ::method::test::SetTableMethodFields<'a> for Table<'a>
    impl<'a> ::method::test::TableOkMethod<'a> for ::Amqp8_0 {
        type Payload = TableOk<'a>;
    } // impl<'a> ::method::test::TableOkMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct TableOk<'a> {
        integer_result: u64,
        string_result: ::std::borrow::Cow<'a, [u8]>,
    } // struct TableOk<'a>

    impl<'a> TableOk<'a> {
        pub fn new<S>(integer_result: u64, string_result: S) -> Self
            where S: Into<::std::borrow::Cow<'a, [u8]>>
        {
            TableOk {
                integer_result: integer_result,
                string_result: string_result.into(),
            } // TableOk
        } // fn new()
        impl_properties! {
(integer_result, set_integer_result) -> u64,
(string_result, string_result_mut, set_string_result) -> Cow<[u8]>,
} // impl_properties
    } // impl<'a> TableOk<'a>
    impl<'a> Default for TableOk<'a> {
        fn default() -> Self {
            TableOk::new(0, &[][..])
        } // fn default()
    } // impl Default for TableOk

    impl<'a> ::Encodable for TableOk<'a> {
        fn encoded_size(&self) -> usize {
            [10, ::Encodable::encoded_size(&self.string_result)]
                .iter()
                .sum()
        } // fn encoded_size()
    } // impl Encodable

    impl<'a> ::ProtocolMethodPayload for TableOk<'a> {
        fn class_id(&self) -> u16 {
            120
        } // fn class_id()
        fn method_id(&self) -> u16 {
            31
        } // fn method_id()
    } // impl ::Payload for TableOk
    impl<'a> ::method::test::SetTableOkMethodFields<'a> for TableOk<'a> {
        fn set_integer_result(&mut self, integer_result: u64) {
            self.set_integer_result(integer_result)
        } // set_integer_result()
        fn set_string_result<V>(&mut self, string_result: V)
            where V: Into<::std::borrow::Cow<'a, [u8]>>
        {
            self.set_string_result(string_result.into())
        } // set_string_result()
    } // impl<'a> ::method::test::SetTableOkMethodFields<'a> for TableOk<'a>

    #[derive(Debug)]
    pub enum ClassMethod<'a> {
        Content(Content),
        ContentOk(ContentOk),
        Integer(Integer),
        IntegerOk(IntegerOk),
        String(String<'a>),
        StringOk(StringOk<'a>),
        Table(Table<'a>),
        TableOk(TableOk<'a>),
    } // enum ClassMethod


    impl<'a> ::Encodable for ClassMethod<'a> {
        fn encoded_size(&self) -> usize {
            match *self {
                ClassMethod::Content(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::ContentOk(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::Integer(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::IntegerOk(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::String(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::StringOk(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::Table(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::TableOk(ref method) => ::Encodable::encoded_size(method),

            } // match *self

        } // fn encoded_size
    } // impl ::Encodable for ClassMethod<'a>

    impl<'a> ::ProtocolMethodPayload for ClassMethod<'a> {
        fn class_id(&self) -> u16 {
            match *self {
                ClassMethod::Content(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::ContentOk(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::Integer(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::IntegerOk(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::String(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::StringOk(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::Table(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::TableOk(ref method) => ::ProtocolMethodPayload::class_id(method),

            } // match *self

        } // fn class_id

        fn method_id(&self) -> u16 {
            match *self {
                ClassMethod::Content(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::ContentOk(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::Integer(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::IntegerOk(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::String(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::StringOk(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::Table(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::TableOk(ref method) => ::ProtocolMethodPayload::method_id(method),

            } // match *self

        } // fn method_id
    } // impl ProtocolMethodPayload for ClassMethod
} // mod test

// generated by primalgen::codegen::spec_module::class_mod::ClassModuleWriter
pub mod tunnel {

    // Generated by primalgen::spec::frame_payload_enum::ClassEnumWriter
    #[derive(Debug)]
    pub struct Header<'a> {
        headers: Option<::field::TableEntries<'a>>,
        proxy_name: Option<::std::borrow::Cow<'a, str>>,
        data_name: Option<::std::borrow::Cow<'a, str>>,
        durable: Option<u8>,
        broadcast: Option<u8>,
    } // struct Header

    impl<'a> Header<'a> {
        impl_properties! {
(headers, headers_mut, set_headers, take_headers) -> Option< &::field::TableEntries<'a> >,
(proxy_name, proxy_name_mut, set_proxy_name, take_proxy_name) -> Option< Cow<str> >,
(data_name, data_name_mut, set_data_name, take_data_name) -> Option< Cow<str> >,
(durable, durable_mut, set_durable, take_durable) -> Option< u8 >,
(broadcast, broadcast_mut, set_broadcast, take_broadcast) -> Option< u8 >,
} // impl_properties
    } // impl Headers

    impl<'a> ::Encodable for Header<'a> {
        fn encoded_size(&self) -> usize {
            unimplemented!()
        } // fn encoded_size
    } // impl ::Encodable for Header<'a>
    impl<'a> ::method::tunnel::RequestMethod<'a> for ::Amqp8_0 {
        type Payload = Request<'a>;
    } // impl<'a> ::method::tunnel::RequestMethod<'a> for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Request<'a> {
        meta_data: ::field::TableEntries<'a>,
    } // struct Request<'a>

    impl<'a> Request<'a> {
        pub fn new<M>(meta_data: M) -> Self
            where M: Into<::field::TableEntries<'a>>
        {
            Request { meta_data: meta_data.into() } // Request
        } // fn new()
        impl_properties! {
(meta_data, meta_data_mut, set_meta_data) -> &::field::TableEntries<'a>,
} // impl_properties
    } // impl<'a> Request<'a>
    impl<'a> Default for Request<'a> {
        fn default() -> Self {
            Request::new(::field::TableEntries::new())
        } // fn default()
    } // impl Default for Request

    impl<'a> ::Encodable for Request<'a> {
        fn encoded_size(&self) -> usize {
            [0, ::Encodable::encoded_size(&self.meta_data)]
                .iter()
                .sum()
        } // fn encoded_size()
    } // impl Encodable

    impl<'a> ::ProtocolMethodPayload for Request<'a> {
        fn class_id(&self) -> u16 {
            110
        } // fn class_id()
        fn method_id(&self) -> u16 {
            10
        } // fn method_id()
    } // impl ::Payload for Request
    impl<'a> ::method::tunnel::SetRequestMethodFields<'a> for Request<'a> {
        fn set_meta_data<V>(&mut self, meta_data: V)
            where V: Into<::field::TableEntries<'a>>
        {
            self.set_meta_data(meta_data.into())
        } // set_meta_data()
    } // impl<'a> ::method::tunnel::SetRequestMethodFields<'a> for Request<'a>

    #[derive(Debug)]
    pub enum ClassMethod<'a> {
        Request(Request<'a>),
    } // enum ClassMethod


    impl<'a> ::Encodable for ClassMethod<'a> {
        fn encoded_size(&self) -> usize {
            match *self {
                ClassMethod::Request(ref method) => ::Encodable::encoded_size(method),

            } // match *self

        } // fn encoded_size
    } // impl ::Encodable for ClassMethod<'a>

    impl<'a> ::ProtocolMethodPayload for ClassMethod<'a> {
        fn class_id(&self) -> u16 {
            match *self {
                ClassMethod::Request(ref method) => ::ProtocolMethodPayload::class_id(method),

            } // match *self

        } // fn class_id

        fn method_id(&self) -> u16 {
            match *self {
                ClassMethod::Request(ref method) => ::ProtocolMethodPayload::method_id(method),

            } // match *self

        } // fn method_id
    } // impl ProtocolMethodPayload for ClassMethod
} // mod tunnel

// generated by primalgen::codegen::spec_module::class_mod::ClassModuleWriter
pub mod tx {
    impl ::method::tx::CommitMethod for ::Amqp8_0 {
        type Payload = Commit;
    } // impl ::method::tx::CommitMethod for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Commit;

    impl Commit {
        pub fn new() -> Self {
            Commit
        } // fn new()
    } // impl Commit
    impl Default for Commit {
        fn default() -> Self {
            Commit::new()
        } // fn default()
    } // impl Default for Commit

    impl ::Encodable for Commit {
        fn encoded_size(&self) -> usize {
            0
        } // fn encoded_size()
    } // impl Encodable

    impl ::ProtocolMethodPayload for Commit {
        fn class_id(&self) -> u16 {
            90
        } // fn class_id()
        fn method_id(&self) -> u16 {
            20
        } // fn method_id()
    } // impl ::Payload for Commit
    impl ::method::tx::CommitOkMethod for ::Amqp8_0 {
        type Payload = CommitOk;
    } // impl ::method::tx::CommitOkMethod for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct CommitOk;

    impl CommitOk {
        pub fn new() -> Self {
            CommitOk
        } // fn new()
    } // impl CommitOk
    impl Default for CommitOk {
        fn default() -> Self {
            CommitOk::new()
        } // fn default()
    } // impl Default for CommitOk

    impl ::Encodable for CommitOk {
        fn encoded_size(&self) -> usize {
            0
        } // fn encoded_size()
    } // impl Encodable

    impl ::ProtocolMethodPayload for CommitOk {
        fn class_id(&self) -> u16 {
            90
        } // fn class_id()
        fn method_id(&self) -> u16 {
            21
        } // fn method_id()
    } // impl ::Payload for CommitOk
    impl ::method::tx::RollbackMethod for ::Amqp8_0 {
        type Payload = Rollback;
    } // impl ::method::tx::RollbackMethod for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Rollback;

    impl Rollback {
        pub fn new() -> Self {
            Rollback
        } // fn new()
    } // impl Rollback
    impl Default for Rollback {
        fn default() -> Self {
            Rollback::new()
        } // fn default()
    } // impl Default for Rollback

    impl ::Encodable for Rollback {
        fn encoded_size(&self) -> usize {
            0
        } // fn encoded_size()
    } // impl Encodable

    impl ::ProtocolMethodPayload for Rollback {
        fn class_id(&self) -> u16 {
            90
        } // fn class_id()
        fn method_id(&self) -> u16 {
            30
        } // fn method_id()
    } // impl ::Payload for Rollback
    impl ::method::tx::RollbackOkMethod for ::Amqp8_0 {
        type Payload = RollbackOk;
    } // impl ::method::tx::RollbackOkMethod for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct RollbackOk;

    impl RollbackOk {
        pub fn new() -> Self {
            RollbackOk
        } // fn new()
    } // impl RollbackOk
    impl Default for RollbackOk {
        fn default() -> Self {
            RollbackOk::new()
        } // fn default()
    } // impl Default for RollbackOk

    impl ::Encodable for RollbackOk {
        fn encoded_size(&self) -> usize {
            0
        } // fn encoded_size()
    } // impl Encodable

    impl ::ProtocolMethodPayload for RollbackOk {
        fn class_id(&self) -> u16 {
            90
        } // fn class_id()
        fn method_id(&self) -> u16 {
            31
        } // fn method_id()
    } // impl ::Payload for RollbackOk
    impl ::method::tx::SelectMethod for ::Amqp8_0 {
        type Payload = Select;
    } // impl ::method::tx::SelectMethod for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct Select;

    impl Select {
        pub fn new() -> Self {
            Select
        } // fn new()
    } // impl Select
    impl Default for Select {
        fn default() -> Self {
            Select::new()
        } // fn default()
    } // impl Default for Select

    impl ::Encodable for Select {
        fn encoded_size(&self) -> usize {
            0
        } // fn encoded_size()
    } // impl Encodable

    impl ::ProtocolMethodPayload for Select {
        fn class_id(&self) -> u16 {
            90
        } // fn class_id()
        fn method_id(&self) -> u16 {
            10
        } // fn method_id()
    } // impl ::Payload for Select
    impl ::method::tx::SelectOkMethod for ::Amqp8_0 {
        type Payload = SelectOk;
    } // impl ::method::tx::SelectOkMethod for ::Amqp8_0

    // generated by primalgen::codegen::spec-module::class_mod::method_struct
    #[derive(Debug)]
    pub struct SelectOk;

    impl SelectOk {
        pub fn new() -> Self {
            SelectOk
        } // fn new()
    } // impl SelectOk
    impl Default for SelectOk {
        fn default() -> Self {
            SelectOk::new()
        } // fn default()
    } // impl Default for SelectOk

    impl ::Encodable for SelectOk {
        fn encoded_size(&self) -> usize {
            0
        } // fn encoded_size()
    } // impl Encodable

    impl ::ProtocolMethodPayload for SelectOk {
        fn class_id(&self) -> u16 {
            90
        } // fn class_id()
        fn method_id(&self) -> u16 {
            11
        } // fn method_id()
    } // impl ::Payload for SelectOk

    #[derive(Debug)]
    pub enum ClassMethod {
        Commit(Commit),
        CommitOk(CommitOk),
        Rollback(Rollback),
        RollbackOk(RollbackOk),
        Select(Select),
        SelectOk(SelectOk),
    } // enum ClassMethod


    impl ::Encodable for ClassMethod {
        fn encoded_size(&self) -> usize {
            match *self {
                ClassMethod::Commit(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::CommitOk(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::Rollback(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::RollbackOk(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::Select(ref method) => ::Encodable::encoded_size(method),
                ClassMethod::SelectOk(ref method) => ::Encodable::encoded_size(method),

            } // match *self

        } // fn encoded_size
    } // impl ::Encodable for ClassMethod

    impl<'a> ::ProtocolMethodPayload for ClassMethod {
        fn class_id(&self) -> u16 {
            match *self {
                ClassMethod::Commit(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::CommitOk(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::Rollback(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::RollbackOk(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::Select(ref method) => ::ProtocolMethodPayload::class_id(method),
                ClassMethod::SelectOk(ref method) => ::ProtocolMethodPayload::class_id(method),

            } // match *self

        } // fn class_id

        fn method_id(&self) -> u16 {
            match *self {
                ClassMethod::Commit(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::CommitOk(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::Rollback(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::RollbackOk(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::Select(ref method) => ::ProtocolMethodPayload::method_id(method),
                ClassMethod::SelectOk(ref method) => ::ProtocolMethodPayload::method_id(method),

            } // match *self

        } // fn method_id
    } // impl ProtocolMethodPayload for ClassMethod
} // mod tx

// Class methods
pub use self::access::ClassMethod as AccessMethod;
pub use self::basic::ClassMethod as BasicMethod;
pub use self::channel::ClassMethod as ChannelMethod;
pub use self::connection::ClassMethod as ConnectionMethod;
pub use self::dtx::ClassMethod as DtxMethod;
pub use self::exchange::ClassMethod as ExchangeMethod;
pub use self::file::ClassMethod as FileMethod;
pub use self::queue::ClassMethod as QueueMethod;
pub use self::stream::ClassMethod as StreamMethod;
pub use self::test::ClassMethod as TestMethod;
pub use self::tunnel::ClassMethod as TunnelMethod;
pub use self::tx::ClassMethod as TxMethod;

// Class headers
pub use self::basic::Header as BasicHeader;
pub use self::file::Header as FileHeader;
pub use self::stream::Header as StreamHeader;
pub use self::tunnel::Header as TunnelHeader;
#[derive(Debug)]
pub enum SpecMethod<'a> {
    Access(AccessMethod<'a>),
    Basic(BasicMethod<'a>),
    Channel(ChannelMethod<'a>),
    Connection(ConnectionMethod<'a>),
    Dtx(DtxMethod<'a>),
    Exchange(ExchangeMethod<'a>),
    File(FileMethod<'a>),
    Queue(QueueMethod<'a>),
    Stream(StreamMethod<'a>),
    Test(TestMethod<'a>),
    Tunnel(TunnelMethod<'a>),
    Tx(TxMethod),
} // enum SpecMethod

impl<'a> ::Encodable for SpecMethod<'a> {
    fn encoded_size(&self) -> usize {
        match *self {
            SpecMethod::Access(ref method) => ::Encodable::encoded_size(method),
            SpecMethod::Basic(ref method) => ::Encodable::encoded_size(method),
            SpecMethod::Channel(ref method) => ::Encodable::encoded_size(method),
            SpecMethod::Connection(ref method) => ::Encodable::encoded_size(method),
            SpecMethod::Dtx(ref method) => ::Encodable::encoded_size(method),
            SpecMethod::Exchange(ref method) => ::Encodable::encoded_size(method),
            SpecMethod::File(ref method) => ::Encodable::encoded_size(method),
            SpecMethod::Queue(ref method) => ::Encodable::encoded_size(method),
            SpecMethod::Stream(ref method) => ::Encodable::encoded_size(method),
            SpecMethod::Test(ref method) => ::Encodable::encoded_size(method),
            SpecMethod::Tunnel(ref method) => ::Encodable::encoded_size(method),
            SpecMethod::Tx(ref method) => ::Encodable::encoded_size(method),

        } // match *self

    } // fn encoded_size
} // impl ::Encodable for SpecMethod<'a>

impl<'a> ::ProtocolMethodPayload for SpecMethod<'a> {
    fn class_id(&self) -> u16 {
        match *self {
            SpecMethod::Access(ref method) => ::ProtocolMethodPayload::class_id(method),
            SpecMethod::Basic(ref method) => ::ProtocolMethodPayload::class_id(method),
            SpecMethod::Channel(ref method) => ::ProtocolMethodPayload::class_id(method),
            SpecMethod::Connection(ref method) => ::ProtocolMethodPayload::class_id(method),
            SpecMethod::Dtx(ref method) => ::ProtocolMethodPayload::class_id(method),
            SpecMethod::Exchange(ref method) => ::ProtocolMethodPayload::class_id(method),
            SpecMethod::File(ref method) => ::ProtocolMethodPayload::class_id(method),
            SpecMethod::Queue(ref method) => ::ProtocolMethodPayload::class_id(method),
            SpecMethod::Stream(ref method) => ::ProtocolMethodPayload::class_id(method),
            SpecMethod::Test(ref method) => ::ProtocolMethodPayload::class_id(method),
            SpecMethod::Tunnel(ref method) => ::ProtocolMethodPayload::class_id(method),
            SpecMethod::Tx(ref method) => ::ProtocolMethodPayload::class_id(method),

        } // match *self

    } // fn class_id

    fn method_id(&self) -> u16 {
        match *self {
            SpecMethod::Access(ref method) => ::ProtocolMethodPayload::method_id(method),
            SpecMethod::Basic(ref method) => ::ProtocolMethodPayload::method_id(method),
            SpecMethod::Channel(ref method) => ::ProtocolMethodPayload::method_id(method),
            SpecMethod::Connection(ref method) => ::ProtocolMethodPayload::method_id(method),
            SpecMethod::Dtx(ref method) => ::ProtocolMethodPayload::method_id(method),
            SpecMethod::Exchange(ref method) => ::ProtocolMethodPayload::method_id(method),
            SpecMethod::File(ref method) => ::ProtocolMethodPayload::method_id(method),
            SpecMethod::Queue(ref method) => ::ProtocolMethodPayload::method_id(method),
            SpecMethod::Stream(ref method) => ::ProtocolMethodPayload::method_id(method),
            SpecMethod::Test(ref method) => ::ProtocolMethodPayload::method_id(method),
            SpecMethod::Tunnel(ref method) => ::ProtocolMethodPayload::method_id(method),
            SpecMethod::Tx(ref method) => ::ProtocolMethodPayload::method_id(method),

        } // match *self

    } // fn method_id
} // impl ProtocolMethodPayload for SpecMethod
