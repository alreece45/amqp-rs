// Copyright 2016 Alexander Reece
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

#![cfg_attr(feature="clippy", feature(plugin))]
#![cfg_attr(feature="clippy", plugin(clippy))]
#![cfg_attr(not(feature="clippy"), allow(unknown_lints))]

#[cfg(feature = "rustfmt")]
extern crate rustfmt;

#[cfg(any(feature = "amqp0-build-specs", feature = "amqp0-pregen-specs"))]
extern crate amqp0_specgen as specgen;

fn main() {
    spec0_builder::build();
}

#[cfg(not(any(feature = "amqp0-build-specs", feature = "amqp0-pregen-specs")))]
mod spec0_builder {
    pub fn build() {
        println!("Skipping build (neither amqp0-build-specs nor amqp0-pregen-specs specified)");
    }
}

#[cfg(any(feature = "amqp0-build-specs", feature = "amqp0-pregen-specs"))]
mod spec0_builder {
    extern crate env_logger;

    use std::env;
    use std::fs::{self, File};
    use std::io::{BufWriter, Write};
    use std::path::PathBuf;
    use specgen::{Spec, ParseError};

    #[cfg(feature = "rustfmt")]
    use rustfmt;

    pub fn build() {
        env_logger::init().unwrap();

        let root_out = env::var_os("OUT_DIR").map(PathBuf::from).expect("Error: OUT_DIR not set");
        let cwd = env::current_dir().expect("Unable to get current directory");
        let xml_dir = cwd.join("xml");

        // amqp0
        let out_file = root_out.join("amqp0.rs");
        {
            let file = match File::create(out_file.clone()) {
                Ok(file) => file,
                Err(e) => panic!("Failed to open {}: {:?}", out_file.display(), e),
            };
            let mut writer = BufWriter::new(file);

            writeln!(writer, "/// Generated by build script in amqp0-specs").unwrap();
            writeln!(writer, "/// Pregenerated files are used by default.").unwrap();
            writeln!(writer, "/// ").unwrap();
            writeln!(writer, "/// Build using amqp0-pregen crate using: cargo --features=\"amqp0-build-specs\"").unwrap();
            writeln!(writer, "/// Regenerate pregenerated scripts using: cargo --features=\"amqp0-pregen-specs\"").unwrap();
            writeln!(writer, "/// ").unwrap();
            writeln!(writer, "// EDITORS BEWARE: Your modifications may be overridden\n").unwrap();

            let specs = amqp0_specs().into_iter()
                .map(|(name, filename)| {
                    let path = xml_dir.join(filename.to_string());
                    println!("cargo:rerun-if-changed={}", path.display());
                    let spec = try!(Spec::parse_xml_path(path));
                    Ok((name, spec))
                })
                .collect::<Result<Vec<_>, ParseError>>()
                .unwrap();

            for &(name, ref spec) in &specs {
                {
                    let v = spec.version();
                    writeln!(writer, "pub fn {}0_{}_{}() -> Spec {{", name, v.minor(), v.revision()).unwrap();
                }
                spec.write_generated(name, &mut writer).unwrap();
                writeln!(writer, "}}").unwrap();
            }

            writeln!(writer, "pub fn specs() -> Vec<Spec> {{").unwrap();
            writeln!(writer, "vec![").unwrap();
            for &(name, ref spec) in &specs {
                let v = spec.version();
                writeln!(writer, "{}0_{}_{}(),", name, v.minor(), v.revision()).unwrap();
            }
            writeln!(writer, "]").unwrap();
            writeln!(writer, "}}").unwrap();
        }

        // file(s) needs to be dropped before reaching here
        if cfg!(feature = "rustfmt") {
            let files = vec![out_file.clone()];
            format_files(files.into_iter());
        }

        if cfg!(feature = "amqp0-pregen-specs") {
            fs::copy(out_file, "src/lib.pregen.rs").unwrap();
        }
    }

    fn amqp0_specs() -> Vec<(&'static str, &'static str)> {
        vec![
            ("amqp", "amqp0-9-1.stripped.xml"),
            ("amqp","amqp0-9.stripped.xml"),
            ("amqp","amqp0-8.stripped.xml"),
            ("rabbitmq", "amqp0-9-1.stripped.rabbitmq.xml"),
            ("qpid", "amqp0-9-qpid.stripped.xml"),
            ("qpid", "amqp0-8-qpid.stripped.xml"),
        ]
    }

    #[cfg(not(feature = "rustfmt"))]
    fn format_files<I>(_: I)
        where I: Iterator<Item = PathBuf>
    {}

    #[cfg(feature = "rustfmt")]
    fn format_files<I>(paths: I)
        where I: Iterator<Item = PathBuf>,
    {
        use rustfmt::Input;
        use rustfmt::config::{self as fmtconfig};

        let config = {
            let mut config = fmtconfig::Config::default();
            config.write_mode = fmtconfig::WriteMode::Overwrite;
            config
        };

        for path in paths {
            println!("Formatting {}", path.display());
            let summary = rustfmt::run(Input::File(path), &config);
            println!("Summary: {:?}", summary)
        }
    }
}