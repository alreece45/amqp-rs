#![cfg_attr(feature="clippy", feature(plugin))]
#![cfg_attr(feature="clippy", plugin(clippy))]
#![cfg_attr(not(feature="clippy"), allow(unknown_lints))]

extern crate env_logger;
#[cfg(feature = "rustfmt")]
extern crate rustfmt;

#[cfg(any(feature = "build-amqp-primitives", feature = "pregen-amqp-primitives"))]
extern crate amqp_primalgen as primalgen;
#[cfg(any(feature = "build-amqp-primitives", feature = "pregen-amqp-primitives"))]
extern crate amqp_specs as specs;

fn main() {
    amqp0::build();
}

#[cfg(not(any(feature = "build-amqp-primitives", feature = "pregen-amqp-primitives")))]
mod amqp0 {
    pub fn build() {
        println!("Skipping build (neither build-amqp-primitives nor pregen-amqp-primitives specified)");
    }
}

#[cfg(any(feature = "build-amqp-primitives", feature = "pregen-amqp-primitives"))]
mod amqp0 {
    use std::env;
    use std::fs::{self, File};
    use std::io::{BufWriter, Write};
    use std::path::PathBuf;

    use env_logger;
    #[cfg(feature = "rustfmt")]
    use rustfmt;

    use primalgen::amqp0::{self as primalgen, Specs, SpecWriter};
    use specs::amqp0::specs;

    pub fn build() {
        env_logger::init().unwrap();
        println!("Building primitives from amqpspec");

        let root_out = env::var_os("OUT_DIR").map(PathBuf::from).expect("Error: OUT_DIR not set");
        let out_file = root_out.join("amqp0.rs");
        println!("File: {}", out_file.display());

        {
            let specs = Specs::new(specs());

            let file = File::create(out_file.clone()).expect("Failed to open spec.rs");
            let mut writer = BufWriter::new(file);

            writeln!(writer, "/// Generated by build script in amqp-amqp-primitives").unwrap();
            writeln!(writer, "/// The file mod.pregen.rs is generated with: cargo build --features \"bulid-pregen\"").unwrap();
            writeln!(writer, "/// The \"build-amqp-primitives\" feature may be used to disable the use of the pregenerated file").unwrap();
            writeln!(writer, "// EDITORS BEWARE: Your modifications may be overridden\n").unwrap();

            primalgen::write_common(&mut writer, &specs).unwrap();

            writeln!(writer, "// Specification-specific modules").unwrap();
            for spec in specs.iter() {
                let version = spec.version();
                println!("Building primitives for Spec: {} 0.{}.{}", spec.name(), version.minor(), version.revision());
                let spec_writer = SpecWriter::new(spec);
                spec_writer.write(&mut writer).unwrap();
            }
        }

        // file(s) needs to be dropped before reaching here
        if cfg!(feature = "rustfmt") {
            let files = vec![out_file.clone()];
            format_files(files.into_iter());
        }

        if cfg!(feature = "pregen-amqp-primitives") {
            println!("Saving to src/amqp0/mod.pregen.rs");
            fs::copy(out_file, "src/amqp0/mod.pregen.rs").unwrap();
        }
    }

    #[cfg(not(feature = "rustfmt"))]
    fn format_files<I>(_: I)
        where I: Iterator<Item = PathBuf>
    {}

    #[cfg(feature = "rustfmt")]
    fn format_files<I>(paths: I)
        where I: Iterator<Item = PathBuf>,
    {
        use rustfmt::Input;
        use rustfmt::config::{self as fmtconfig};

        let config = {
            let mut config = fmtconfig::Config::default();
            config.write_mode = fmtconfig::WriteMode::Overwrite;
            config
        };

        for path in paths {
            println!("Formatting {}", path.display());
            let summary = rustfmt::run(Input::File(path), &config);
            println!("Summary: {:?}", summary)
        }
    }
}