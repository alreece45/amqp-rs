#![cfg_attr(feature="clippy", feature(plugin))]
#![cfg_attr(feature="clippy", plugin(clippy))]
#![cfg_attr(not(feature="clippy"), allow(unknown_lints))]

extern crate env_logger;
#[cfg(feature = "rustfmt")]
extern crate rustfmt;

#[cfg(any(feature = "amqp-build-primitives", feature = "amqp-pregen-primitives"))]
extern crate amqp_primalgen as primalgen;
#[cfg(any(feature = "amqp-build-primitives", feature = "amqp-pregen-primitives"))]
extern crate amqp_specs as specs;

fn main() {
    amqp0::build();
}

#[cfg(not(any(feature = "amqp-build-primitives", feature = "amqp-pregen-primitives")))]
mod amqp0 {
    pub fn build() {
        println!("Skipping build (neither amqp-build-primitives nor amqp-pregen-primitives specified)");
    }
}

#[cfg(any(feature = "amqp-build-primitives", feature = "amqp-pregen-primitives"))]
mod amqp0 {
    use std::env;
    use std::fs::{self, File};
    use std::io::{self, BufWriter};
    use std::path::{Path, PathBuf};

    use env_logger;
    #[cfg(feature = "rustfmt")]
    use rustfmt;

    use primalgen::amqp0::{self as primalgen, CommonSpecs, CommonSpecsWriter, SpecWriter};
    use specs::amqp0::specs as amqp0_specs;

    pub fn build() {
        env_logger::init().unwrap();
        println!("Building primitives from amqpspec");

        let mut paths = Vec::with_capacity(2);
        let out_path = env::var_os("OUT_DIR").map(PathBuf::from).expect("Error: OUT_DIR not set");

        // amqp0 specs
        let amqp0_specs = CommonSpecs::new(amqp0_specs());
        let amqp0_path = out_path.join("amqp0");
        write_amqp0_specs(&amqp0_path, amqp0_specs);
        paths.push(amqp0_path);

        // file(s) needs to be dropped before reaching here
        if cfg!(feature = "rustfmt") {
            format_files(paths.iter().map(|p| &*p));
        }

        if cfg!(feature = "amqp-pregen-primitives") {
            /*for (src, dst) in paths {
                println!("Saving to {} to {}", src.display(), dst);
                fs::copy(src, dst).unwrap();
            }*/
        }
    }

    #[cfg(not(feature = "rustfmt"))]
    fn format_files<'a, I>(_: I) {}

    #[cfg(feature = "rustfmt")]
    fn format_files<'a, I>(paths: I)
        where I: Iterator<Item = &'a h>,
    {
        use rustfmt::Input;
        use rustfmt::config::{self as fmtconfig};

        let config = {
            let mut config = fmtconfig::Config::default();
            config.write_mode = fmtconfig::WriteMode::Overwrite;
            config
        };

        for path in paths {
            println!("Formatting {}", path.display());
            let summary = rustfmt::run(Input::File(path), &config);
            println!("Summary: {:?}", summary)
        }
    }

    fn write_header<W>(writer: &mut W)
        where W: io::Write
    {
        writeln!(writer, "/// Generated by build script in amqp-amqp-primitives").unwrap();
        writeln!(writer, "/// The file mod.pregen.rs is generated with: cargo build --features \"bulid-pregen\"").unwrap();
        writeln!(writer, "/// The \"amqp-build-primitives\" feature may be used to disable the use of the pregenerated file").unwrap();
        writeln!(writer, "// EDITORS BEWARE: Your modifications may be overridden\n").unwrap();
    }

    fn write_amqp0_specs(path: &Path, specs: CommonSpecs) {
        if !path.is_dir() {
            println!("Creating directory: {}", path.display());
            if fs::create_dir_all(path).is_err() {
                panic!("Unable to create {}", path.display())
            }
        }

        let common = path.join("mod.rs");
        println!("amqp0: {}", path.display());
        {
            let file = File::create(common).expect("Failed to open spec.rs");
            let mut writer = BufWriter::new(file);
            write_header(&mut writer);

            let common = CommonSpecsWriter::new(&specs);
            common.write(&mut writer).unwrap();
        }

        for spec in specs.iter() {
            let spec_writer = SpecWriter::new(spec);
            println!("Spec [{}]: {}", spec_writer.mod_name(), path.display());

            let path = path.join(format!("{}.rs", spec_writer.mod_name()));
            let file = match File::create(&path) {
                Ok(f) => f,
                Err(e) => panic!("Error opening file [{}]: {:?}", path.display(), e),
            };

            let mut writer = BufWriter::new(file);
            spec_writer.write(&mut writer).unwrap();
        }
    }
}