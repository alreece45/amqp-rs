/// Generated by build script in amqp-amqp-primitives
/// The file mod.pregen.rs is generated with: cargo build --features "bulid-pregen"
/// The "build-amqp-primitives" feature may be used to disable the use of the pregenerated file
// EDITORS BEWARE: Your modifications may be overridden

// Index values for classes shared among multiple specs
//
// Sometimes, the index value is repeated in different classes, but these are not reused
// within a single protocol
//
// Classes are currently only considered common if they are used in more than one
// spec. This behavior *may* change in the future as more specs are added.
//
pub const CLASS_CONNECTION: u16 = 10;
pub const CLASS_CHANNEL: u16 = 20;
pub const CLASS_ACCESS: u16 = 30;
pub const CLASS_EXCHANGE: u16 = 40;
pub const CLASS_QUEUE: u16 = 50;
pub const CLASS_BASIC: u16 = 60;
pub const CLASS_FILE: u16 = 70;
pub const CLASS_STREAM: u16 = 80;
pub const CLASS_CONFIRM: u16 = 85;
pub const CLASS_TX: u16 = 90;
pub const CLASS_DTX: u16 = 100;
pub const CLASS_TUNNEL: u16 = 110;
pub const CLASS_MESSAGE: u16 = 120;
pub const CLASS_TEST: u16 = 120;

// Index values for methods common among the different specs
//
// Methods are only considered common when:
//
//   * The index value is consistent across all of the specs
//   * The method is used in more than one spec
//
// This may change in the future-- in that case, methods *may* be removed, or
// one of the requirements may be relaxed.
//
pub const METHOD_ACCESS_REQUEST: u16 = 10;
pub const METHOD_ACCESS_REQUEST_OK: u16 = 11;

pub const METHOD_BASIC_QOS: u16 = 10;
pub const METHOD_BASIC_QOS_OK: u16 = 11;
pub const METHOD_BASIC_CONSUME: u16 = 20;
pub const METHOD_BASIC_CONSUME_OK: u16 = 21;
pub const METHOD_BASIC_CANCEL: u16 = 30;
pub const METHOD_BASIC_CANCEL_OK: u16 = 31;
pub const METHOD_BASIC_PUBLISH: u16 = 40;
pub const METHOD_BASIC_RETURN: u16 = 50;
pub const METHOD_BASIC_DELIVER: u16 = 60;
pub const METHOD_BASIC_GET: u16 = 70;
pub const METHOD_BASIC_GET_OK: u16 = 71;
pub const METHOD_BASIC_GET_EMPTY: u16 = 72;
pub const METHOD_BASIC_ACK: u16 = 80;
pub const METHOD_BASIC_REJECT: u16 = 90;
pub const METHOD_BASIC_RECOVER_ASYNC: u16 = 100;
pub const METHOD_BASIC_RECOVER_SYNC_OK: u16 = 101;
pub const METHOD_BASIC_RECOVER_SYNC: u16 = 102;
pub const METHOD_BASIC_NACK: u16 = 120;

pub const METHOD_CHANNEL_OPEN: u16 = 10;
pub const METHOD_CHANNEL_OPEN_OK: u16 = 11;
pub const METHOD_CHANNEL_FLOW: u16 = 20;
pub const METHOD_CHANNEL_FLOW_OK: u16 = 21;
pub const METHOD_CHANNEL_ALERT: u16 = 30;
pub const METHOD_CHANNEL_CLOSE: u16 = 40;
pub const METHOD_CHANNEL_CLOSE_OK: u16 = 41;
pub const METHOD_CHANNEL_RESUME: u16 = 50;
pub const METHOD_CHANNEL_PING: u16 = 60;
pub const METHOD_CHANNEL_PONG: u16 = 70;
pub const METHOD_CHANNEL_OK: u16 = 80;

pub const METHOD_CONFIRM_SELECT: u16 = 10;
pub const METHOD_CONFIRM_SELECT_OK: u16 = 11;

pub const METHOD_CONNECTION_START: u16 = 10;
pub const METHOD_CONNECTION_START_OK: u16 = 11;
pub const METHOD_CONNECTION_SECURE: u16 = 20;
pub const METHOD_CONNECTION_SECURE_OK: u16 = 21;
pub const METHOD_CONNECTION_TUNE: u16 = 30;
pub const METHOD_CONNECTION_TUNE_OK: u16 = 31;
pub const METHOD_CONNECTION_OPEN: u16 = 40;
pub const METHOD_CONNECTION_OPEN_OK: u16 = 41;
pub const METHOD_CONNECTION_BLOCKED: u16 = 60;
pub const METHOD_CONNECTION_UNBLOCKED: u16 = 61;

pub const METHOD_DTX_SELECT: u16 = 10;
pub const METHOD_DTX_SELECT_OK: u16 = 11;
pub const METHOD_DTX_START: u16 = 20;
pub const METHOD_DTX_START_OK: u16 = 21;

pub const METHOD_EXCHANGE_DECLARE: u16 = 10;
pub const METHOD_EXCHANGE_DECLARE_OK: u16 = 11;
pub const METHOD_EXCHANGE_DELETE: u16 = 20;
pub const METHOD_EXCHANGE_DELETE_OK: u16 = 21;
pub const METHOD_EXCHANGE_BOUND: u16 = 22;
pub const METHOD_EXCHANGE_BOUND_OK: u16 = 23;
pub const METHOD_EXCHANGE_BIND: u16 = 30;
pub const METHOD_EXCHANGE_BIND_OK: u16 = 31;
pub const METHOD_EXCHANGE_UNBIND: u16 = 40;
pub const METHOD_EXCHANGE_UNBIND_OK: u16 = 51;

pub const METHOD_FILE_QOS: u16 = 10;
pub const METHOD_FILE_QOS_OK: u16 = 11;
pub const METHOD_FILE_CONSUME: u16 = 20;
pub const METHOD_FILE_CONSUME_OK: u16 = 21;
pub const METHOD_FILE_CANCEL: u16 = 30;
pub const METHOD_FILE_CANCEL_OK: u16 = 31;
pub const METHOD_FILE_OPEN: u16 = 40;
pub const METHOD_FILE_OPEN_OK: u16 = 41;
pub const METHOD_FILE_STAGE: u16 = 50;
pub const METHOD_FILE_PUBLISH: u16 = 60;
pub const METHOD_FILE_RETURN: u16 = 70;
pub const METHOD_FILE_DELIVER: u16 = 80;
pub const METHOD_FILE_ACK: u16 = 90;
pub const METHOD_FILE_REJECT: u16 = 100;

pub const METHOD_MESSAGE_TRANSFER: u16 = 10;
pub const METHOD_MESSAGE_CONSUME: u16 = 20;
pub const METHOD_MESSAGE_CANCEL: u16 = 30;
pub const METHOD_MESSAGE_GET: u16 = 40;
pub const METHOD_MESSAGE_RECOVER: u16 = 50;
pub const METHOD_MESSAGE_OPEN: u16 = 60;
pub const METHOD_MESSAGE_CLOSE: u16 = 70;
pub const METHOD_MESSAGE_APPEND: u16 = 80;
pub const METHOD_MESSAGE_CHECKPOINT: u16 = 90;
pub const METHOD_MESSAGE_RESUME: u16 = 100;
pub const METHOD_MESSAGE_QOS: u16 = 110;
pub const METHOD_MESSAGE_OK: u16 = 500;
pub const METHOD_MESSAGE_EMPTY: u16 = 510;
pub const METHOD_MESSAGE_REJECT: u16 = 520;
pub const METHOD_MESSAGE_OFFSET: u16 = 530;

pub const METHOD_QUEUE_DECLARE: u16 = 10;
pub const METHOD_QUEUE_DECLARE_OK: u16 = 11;
pub const METHOD_QUEUE_BIND: u16 = 20;
pub const METHOD_QUEUE_BIND_OK: u16 = 21;
pub const METHOD_QUEUE_PURGE: u16 = 30;
pub const METHOD_QUEUE_PURGE_OK: u16 = 31;
pub const METHOD_QUEUE_DELETE: u16 = 40;
pub const METHOD_QUEUE_DELETE_OK: u16 = 41;
pub const METHOD_QUEUE_UNBIND: u16 = 50;
pub const METHOD_QUEUE_UNBIND_OK: u16 = 51;

pub const METHOD_STREAM_QOS: u16 = 10;
pub const METHOD_STREAM_QOS_OK: u16 = 11;
pub const METHOD_STREAM_CONSUME: u16 = 20;
pub const METHOD_STREAM_CONSUME_OK: u16 = 21;
pub const METHOD_STREAM_CANCEL: u16 = 30;
pub const METHOD_STREAM_CANCEL_OK: u16 = 31;
pub const METHOD_STREAM_PUBLISH: u16 = 40;
pub const METHOD_STREAM_RETURN: u16 = 50;
pub const METHOD_STREAM_DELIVER: u16 = 60;

pub const METHOD_TEST_INTEGER: u16 = 10;
pub const METHOD_TEST_INTEGER_OK: u16 = 11;
pub const METHOD_TEST_STRING: u16 = 20;
pub const METHOD_TEST_STRING_OK: u16 = 21;
pub const METHOD_TEST_TABLE: u16 = 30;
pub const METHOD_TEST_TABLE_OK: u16 = 31;
pub const METHOD_TEST_CONTENT: u16 = 40;
pub const METHOD_TEST_CONTENT_OK: u16 = 41;

pub const METHOD_TUNNEL_REQUEST: u16 = 10;

pub const METHOD_TX_SELECT: u16 = 10;
pub const METHOD_TX_SELECT_OK: u16 = 11;
pub const METHOD_TX_COMMIT: u16 = 20;
pub const METHOD_TX_COMMIT_OK: u16 = 21;
pub const METHOD_TX_ROLLBACK: u16 = 30;
pub const METHOD_TX_ROLLBACK_OK: u16 = 31;

// Specification-specific modules
pub mod amqp9_1 {
    // Class Constants
    pub const CLASS_BASIC: u16 = 60;
    pub const CLASS_CHANNEL: u16 = 20;
    pub const CLASS_CONNECTION: u16 = 10;
    pub const CLASS_EXCHANGE: u16 = 40;
    pub const CLASS_QUEUE: u16 = 50;
    pub const CLASS_TX: u16 = 90;

    // Class Methods
    pub const METHOD_BASIC_QOS: u16 = 10;
    pub const METHOD_BASIC_QOS_OK: u16 = 11;
    pub const METHOD_BASIC_CONSUME: u16 = 20;
    pub const METHOD_BASIC_CONSUME_OK: u16 = 21;
    pub const METHOD_BASIC_CANCEL: u16 = 30;
    pub const METHOD_BASIC_CANCEL_OK: u16 = 31;
    pub const METHOD_BASIC_PUBLISH: u16 = 40;
    pub const METHOD_BASIC_RETURN: u16 = 50;
    pub const METHOD_BASIC_DELIVER: u16 = 60;
    pub const METHOD_BASIC_GET: u16 = 70;
    pub const METHOD_BASIC_GET_OK: u16 = 71;
    pub const METHOD_BASIC_GET_EMPTY: u16 = 72;
    pub const METHOD_BASIC_ACK: u16 = 80;
    pub const METHOD_BASIC_REJECT: u16 = 90;
    pub const METHOD_BASIC_RECOVER_ASYNC: u16 = 100;
    pub const METHOD_BASIC_RECOVER: u16 = 110;
    pub const METHOD_BASIC_RECOVER_OK: u16 = 111;

    pub const METHOD_CHANNEL_OPEN: u16 = 10;
    pub const METHOD_CHANNEL_OPEN_OK: u16 = 11;
    pub const METHOD_CHANNEL_FLOW: u16 = 20;
    pub const METHOD_CHANNEL_FLOW_OK: u16 = 21;
    pub const METHOD_CHANNEL_CLOSE: u16 = 40;
    pub const METHOD_CHANNEL_CLOSE_OK: u16 = 41;

    pub const METHOD_CONNECTION_START: u16 = 10;
    pub const METHOD_CONNECTION_START_OK: u16 = 11;
    pub const METHOD_CONNECTION_SECURE: u16 = 20;
    pub const METHOD_CONNECTION_SECURE_OK: u16 = 21;
    pub const METHOD_CONNECTION_TUNE: u16 = 30;
    pub const METHOD_CONNECTION_TUNE_OK: u16 = 31;
    pub const METHOD_CONNECTION_OPEN: u16 = 40;
    pub const METHOD_CONNECTION_OPEN_OK: u16 = 41;
    pub const METHOD_CONNECTION_CLOSE: u16 = 50;
    pub const METHOD_CONNECTION_CLOSE_OK: u16 = 51;

    pub const METHOD_EXCHANGE_DECLARE: u16 = 10;
    pub const METHOD_EXCHANGE_DECLARE_OK: u16 = 11;
    pub const METHOD_EXCHANGE_DELETE: u16 = 20;
    pub const METHOD_EXCHANGE_DELETE_OK: u16 = 21;

    pub const METHOD_QUEUE_DECLARE: u16 = 10;
    pub const METHOD_QUEUE_DECLARE_OK: u16 = 11;
    pub const METHOD_QUEUE_BIND: u16 = 20;
    pub const METHOD_QUEUE_BIND_OK: u16 = 21;
    pub const METHOD_QUEUE_UNBIND: u16 = 50;
    pub const METHOD_QUEUE_UNBIND_OK: u16 = 51;
    pub const METHOD_QUEUE_PURGE: u16 = 30;
    pub const METHOD_QUEUE_PURGE_OK: u16 = 31;
    pub const METHOD_QUEUE_DELETE: u16 = 40;
    pub const METHOD_QUEUE_DELETE_OK: u16 = 41;

    pub const METHOD_TX_SELECT: u16 = 10;
    pub const METHOD_TX_SELECT_OK: u16 = 11;
    pub const METHOD_TX_COMMIT: u16 = 20;
    pub const METHOD_TX_COMMIT_OK: u16 = 21;
    pub const METHOD_TX_ROLLBACK: u16 = 30;
    pub const METHOD_TX_ROLLBACK_OK: u16 = 31;
    pub mod basic {

        // Class Modules
        pub struct Qos {
            prefetch_size: u32,
            prefetch_count: u16,
            global: bool,
        }
        impl Qos {
            pub fn new(prefetch_size: u32, prefetch_count: u16, global: bool) -> Self {
                Qos {
                    prefetch_size: prefetch_size,
                    prefetch_count: prefetch_count,
                    global: global,
                }
            }
            pub fn prefetch_size(&self) -> u32 {
                self.prefetch_size
            }
            pub fn prefetch_count(&self) -> u16 {
                self.prefetch_count
            }
            pub fn global(&self) -> bool {
                self.global
            }
        }
        impl ::amqp0::Message for Qos {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                7
            }
        }

        // Class Modules
        pub struct QosOk;
        impl QosOk {
            pub fn new() -> Self {
                QosOk
            }
        }
        impl ::amqp0::Message for QosOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Consume<'a> {
            queue: ::std::borrow::Cow<'a, str>,
            consumer_tag: ::std::borrow::Cow<'a, str>,
            no_local: bool,
            no_ack: bool,
            exclusive: bool,
            no_wait: bool,
            arguments: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
        }
        impl<'a> Consume<'a> {
            pub fn new<A, C, Q>(queue: Q,
                                consumer_tag: C,
                                no_local: bool,
                                no_ack: bool,
                                exclusive: bool,
                                no_wait: bool,
                                arguments: A)
                                -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>,
                      C: Into<::std::borrow::Cow<'a, str>>,
                      A: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>
            {
                Consume {
                    queue: queue.into(),
                    consumer_tag: consumer_tag.into(),
                    no_local: no_local,
                    no_ack: no_ack,
                    exclusive: exclusive,
                    no_wait: no_wait,
                    arguments: arguments.into(),
                }
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
            pub fn no_local(&self) -> bool {
                self.no_local
            }
            pub fn no_ack(&self) -> bool {
                self.no_ack
            }
            pub fn exclusive(&self) -> bool {
                self.exclusive
            }
            pub fn no_wait(&self) -> bool {
                self.no_wait
            }
            pub fn arguments(&self) -> &::amqp0::value::Table {
                &*self.arguments
            }
        }
        impl<'a> ::amqp0::Message for Consume<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [3, self.queue.len(), self.consumer_tag.len(), self.arguments.amqp_size()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct ConsumeOk<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> ConsumeOk<'a> {
            pub fn new<C>(consumer_tag: C) -> Self
                where C: Into<::std::borrow::Cow<'a, str>>
            {
                ConsumeOk { consumer_tag: consumer_tag.into() }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
        }
        impl<'a> ::amqp0::Message for ConsumeOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [1, self.consumer_tag.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Cancel<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
            no_wait: bool,
        }
        impl<'a> Cancel<'a> {
            pub fn new<C>(consumer_tag: C, no_wait: bool) -> Self
                where C: Into<::std::borrow::Cow<'a, str>>
            {
                Cancel {
                    consumer_tag: consumer_tag.into(),
                    no_wait: no_wait,
                }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
            pub fn no_wait(&self) -> bool {
                self.no_wait
            }
        }
        impl<'a> ::amqp0::Message for Cancel<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.consumer_tag.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct CancelOk<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> CancelOk<'a> {
            pub fn new<C>(consumer_tag: C) -> Self
                where C: Into<::std::borrow::Cow<'a, str>>
            {
                CancelOk { consumer_tag: consumer_tag.into() }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
        }
        impl<'a> ::amqp0::Message for CancelOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [1, self.consumer_tag.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Publish<'a> {
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
            mandatory: bool,
            immediate: bool,
        }
        impl<'a> Publish<'a> {
            pub fn new<E, R>(exchange: E, routing_key: R, mandatory: bool, immediate: bool) -> Self
                where E: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, str>>
            {
                Publish {
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                    mandatory: mandatory,
                    immediate: immediate,
                }
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
            pub fn mandatory(&self) -> bool {
                self.mandatory
            }
            pub fn immediate(&self) -> bool {
                self.immediate
            }
        }
        impl<'a> ::amqp0::Message for Publish<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [3, self.exchange.len(), self.routing_key.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Return<'a> {
            reply_code: u16,
            reply_text: ::std::borrow::Cow<'a, str>,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Return<'a> {
            pub fn new<E, R, R0>(reply_code: u16,
                                 reply_text: R,
                                 exchange: E,
                                 routing_key: R0)
                                 -> Self
                where R: Into<::std::borrow::Cow<'a, str>>,
                      E: Into<::std::borrow::Cow<'a, str>>,
                      R0: Into<::std::borrow::Cow<'a, str>>
            {
                Return {
                    reply_code: reply_code,
                    reply_text: reply_text.into(),
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                }
            }
            pub fn reply_code(&self) -> u16 {
                self.reply_code
            }
            pub fn reply_text(&self) -> &str {
                &*self.reply_text
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
        }
        impl<'a> ::amqp0::Message for Return<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [5, self.reply_text.len(), self.exchange.len(), self.routing_key.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Deliver<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
            delivery_tag: u64,
            redelivered: bool,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Deliver<'a> {
            pub fn new<C, E, R>(consumer_tag: C,
                                delivery_tag: u64,
                                redelivered: bool,
                                exchange: E,
                                routing_key: R)
                                -> Self
                where C: Into<::std::borrow::Cow<'a, str>>,
                      E: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, str>>
            {
                Deliver {
                    consumer_tag: consumer_tag.into(),
                    delivery_tag: delivery_tag,
                    redelivered: redelivered,
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
            pub fn delivery_tag(&self) -> u64 {
                self.delivery_tag
            }
            pub fn redelivered(&self) -> bool {
                self.redelivered
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
        }
        impl<'a> ::amqp0::Message for Deliver<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [12, self.consumer_tag.len(), self.exchange.len(), self.routing_key.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Get<'a> {
            queue: ::std::borrow::Cow<'a, str>,
            no_ack: bool,
        }
        impl<'a> Get<'a> {
            pub fn new<Q>(queue: Q, no_ack: bool) -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>
            {
                Get {
                    queue: queue.into(),
                    no_ack: no_ack,
                }
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn no_ack(&self) -> bool {
                self.no_ack
            }
        }
        impl<'a> ::amqp0::Message for Get<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.queue.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct GetOk<'a> {
            delivery_tag: u64,
            redelivered: bool,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
            message_count: u32,
        }
        impl<'a> GetOk<'a> {
            pub fn new<E, R>(delivery_tag: u64,
                             redelivered: bool,
                             exchange: E,
                             routing_key: R,
                             message_count: u32)
                             -> Self
                where E: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, str>>
            {
                GetOk {
                    delivery_tag: delivery_tag,
                    redelivered: redelivered,
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                    message_count: message_count,
                }
            }
            pub fn delivery_tag(&self) -> u64 {
                self.delivery_tag
            }
            pub fn redelivered(&self) -> bool {
                self.redelivered
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
            pub fn message_count(&self) -> u32 {
                self.message_count
            }
        }
        impl<'a> ::amqp0::Message for GetOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [15, self.exchange.len(), self.routing_key.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct GetEmpty;
        impl GetEmpty {
            pub fn new() -> Self {
                GetEmpty
            }
        }
        impl ::amqp0::Message for GetEmpty {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Ack {
            delivery_tag: u64,
            multiple: bool,
        }
        impl Ack {
            pub fn new(delivery_tag: u64, multiple: bool) -> Self {
                Ack {
                    delivery_tag: delivery_tag,
                    multiple: multiple,
                }
            }
            pub fn delivery_tag(&self) -> u64 {
                self.delivery_tag
            }
            pub fn multiple(&self) -> bool {
                self.multiple
            }
        }
        impl ::amqp0::Message for Ack {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                9
            }
        }

        // Class Modules
        pub struct Reject {
            delivery_tag: u64,
            requeue: bool,
        }
        impl Reject {
            pub fn new(delivery_tag: u64, requeue: bool) -> Self {
                Reject {
                    delivery_tag: delivery_tag,
                    requeue: requeue,
                }
            }
            pub fn delivery_tag(&self) -> u64 {
                self.delivery_tag
            }
            pub fn requeue(&self) -> bool {
                self.requeue
            }
        }
        impl ::amqp0::Message for Reject {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                9
            }
        }

        // Class Modules
        pub struct RecoverAsync {
            requeue: bool,
        }
        impl RecoverAsync {
            pub fn new(requeue: bool) -> Self {
                RecoverAsync { requeue: requeue }
            }
            pub fn requeue(&self) -> bool {
                self.requeue
            }
        }
        impl ::amqp0::Message for RecoverAsync {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                1
            }
        }

        // Class Modules
        pub struct Recover {
            requeue: bool,
        }
        impl Recover {
            pub fn new(requeue: bool) -> Self {
                Recover { requeue: requeue }
            }
            pub fn requeue(&self) -> bool {
                self.requeue
            }
        }
        impl ::amqp0::Message for Recover {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                1
            }
        }

        // Class Modules
        pub struct RecoverOk;
        impl RecoverOk {
            pub fn new() -> Self {
                RecoverOk
            }
        }
        impl ::amqp0::Message for RecoverOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }
    }
    pub mod channel {

        // Class Modules
        pub struct Open;
        impl Open {
            pub fn new() -> Self {
                Open
            }
        }
        impl ::amqp0::Message for Open {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct OpenOk;
        impl OpenOk {
            pub fn new() -> Self {
                OpenOk
            }
        }
        impl ::amqp0::Message for OpenOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Flow {
            active: bool,
        }
        impl Flow {
            pub fn new(active: bool) -> Self {
                Flow { active: active }
            }
            pub fn active(&self) -> bool {
                self.active
            }
        }
        impl ::amqp0::Message for Flow {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                1
            }
        }

        // Class Modules
        pub struct FlowOk {
            active: bool,
        }
        impl FlowOk {
            pub fn new(active: bool) -> Self {
                FlowOk { active: active }
            }
            pub fn active(&self) -> bool {
                self.active
            }
        }
        impl ::amqp0::Message for FlowOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                1
            }
        }

        // Class Modules
        pub struct Close<'a> {
            reply_code: u16,
            reply_text: ::std::borrow::Cow<'a, str>,
            class_id: u16,
            method_id: u16,
        }
        impl<'a> Close<'a> {
            pub fn new<R>(reply_code: u16, reply_text: R, class_id: u16, method_id: u16) -> Self
                where R: Into<::std::borrow::Cow<'a, str>>
            {
                Close {
                    reply_code: reply_code,
                    reply_text: reply_text.into(),
                    class_id: class_id,
                    method_id: method_id,
                }
            }
            pub fn reply_code(&self) -> u16 {
                self.reply_code
            }
            pub fn reply_text(&self) -> &str {
                &*self.reply_text
            }
            pub fn class_id(&self) -> u16 {
                self.class_id
            }
            pub fn method_id(&self) -> u16 {
                self.method_id
            }
        }
        impl<'a> ::amqp0::Message for Close<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [7, self.reply_text.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct CloseOk;
        impl CloseOk {
            pub fn new() -> Self {
                CloseOk
            }
        }
        impl ::amqp0::Message for CloseOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }
    }
    pub mod connection {

        // Class Modules
        pub struct Start<'a> {
            version_major: u8,
            version_minor: u8,
            server_properties: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
            mechanisms: ::std::borrow::Cow<'a, [u8]>,
            locales: ::std::borrow::Cow<'a, [u8]>,
        }
        impl<'a> Start<'a> {
            pub fn new<L, M, S>(version_major: u8,
                                version_minor: u8,
                                server_properties: S,
                                mechanisms: M,
                                locales: L)
                                -> Self
                where S: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>,
                      M: Into<::std::borrow::Cow<'a, [u8]>>,
                      L: Into<::std::borrow::Cow<'a, [u8]>>
            {
                Start {
                    version_major: version_major,
                    version_minor: version_minor,
                    server_properties: server_properties.into(),
                    mechanisms: mechanisms.into(),
                    locales: locales.into(),
                }
            }
            pub fn version_major(&self) -> u8 {
                self.version_major
            }
            pub fn version_minor(&self) -> u8 {
                self.version_minor
            }
            pub fn server_properties(&self) -> &::amqp0::value::Table {
                &*self.server_properties
            }
            pub fn mechanisms(&self) -> &[u8] {
                &*self.mechanisms
            }
            pub fn locales(&self) -> &[u8] {
                &*self.locales
            }
        }
        impl<'a> ::amqp0::Message for Start<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [6, self.server_properties.amqp_size(), self.mechanisms.len(), self.locales.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct StartOk<'a> {
            client_properties: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
            mechanism: ::std::borrow::Cow<'a, str>,
            response: ::std::borrow::Cow<'a, [u8]>,
            locale: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> StartOk<'a> {
            pub fn new<C, L, M, R>(client_properties: C,
                                   mechanism: M,
                                   response: R,
                                   locale: L)
                                   -> Self
                where C: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>,
                      M: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, [u8]>>,
                      L: Into<::std::borrow::Cow<'a, str>>
            {
                StartOk {
                    client_properties: client_properties.into(),
                    mechanism: mechanism.into(),
                    response: response.into(),
                    locale: locale.into(),
                }
            }
            pub fn client_properties(&self) -> &::amqp0::value::Table {
                &*self.client_properties
            }
            pub fn mechanism(&self) -> &str {
                &*self.mechanism
            }
            pub fn response(&self) -> &[u8] {
                &*self.response
            }
            pub fn locale(&self) -> &str {
                &*self.locale
            }
        }
        impl<'a> ::amqp0::Message for StartOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [4,
                 self.client_properties.amqp_size(),
                 self.mechanism.len(),
                 self.response.len(),
                 self.locale.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Secure<'a> {
            challenge: ::std::borrow::Cow<'a, [u8]>,
        }
        impl<'a> Secure<'a> {
            pub fn new<C>(challenge: C) -> Self
                where C: Into<::std::borrow::Cow<'a, [u8]>>
            {
                Secure { challenge: challenge.into() }
            }
            pub fn challenge(&self) -> &[u8] {
                &*self.challenge
            }
        }
        impl<'a> ::amqp0::Message for Secure<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.challenge.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct SecureOk<'a> {
            response: ::std::borrow::Cow<'a, [u8]>,
        }
        impl<'a> SecureOk<'a> {
            pub fn new<R>(response: R) -> Self
                where R: Into<::std::borrow::Cow<'a, [u8]>>
            {
                SecureOk { response: response.into() }
            }
            pub fn response(&self) -> &[u8] {
                &*self.response
            }
        }
        impl<'a> ::amqp0::Message for SecureOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.response.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Tune {
            channel_max: u16,
            frame_max: u32,
            heartbeat: u16,
        }
        impl Tune {
            pub fn new(channel_max: u16, frame_max: u32, heartbeat: u16) -> Self {
                Tune {
                    channel_max: channel_max,
                    frame_max: frame_max,
                    heartbeat: heartbeat,
                }
            }
            pub fn channel_max(&self) -> u16 {
                self.channel_max
            }
            pub fn frame_max(&self) -> u32 {
                self.frame_max
            }
            pub fn heartbeat(&self) -> u16 {
                self.heartbeat
            }
        }
        impl ::amqp0::Message for Tune {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                8
            }
        }

        // Class Modules
        pub struct TuneOk {
            channel_max: u16,
            frame_max: u32,
            heartbeat: u16,
        }
        impl TuneOk {
            pub fn new(channel_max: u16, frame_max: u32, heartbeat: u16) -> Self {
                TuneOk {
                    channel_max: channel_max,
                    frame_max: frame_max,
                    heartbeat: heartbeat,
                }
            }
            pub fn channel_max(&self) -> u16 {
                self.channel_max
            }
            pub fn frame_max(&self) -> u32 {
                self.frame_max
            }
            pub fn heartbeat(&self) -> u16 {
                self.heartbeat
            }
        }
        impl ::amqp0::Message for TuneOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                8
            }
        }

        // Class Modules
        pub struct Open<'a> {
            virtual_host: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Open<'a> {
            pub fn new<V>(virtual_host: V) -> Self
                where V: Into<::std::borrow::Cow<'a, str>>
            {
                Open { virtual_host: virtual_host.into() }
            }
            pub fn virtual_host(&self) -> &str {
                &*self.virtual_host
            }
        }
        impl<'a> ::amqp0::Message for Open<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [1, self.virtual_host.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct OpenOk;
        impl OpenOk {
            pub fn new() -> Self {
                OpenOk
            }
        }
        impl ::amqp0::Message for OpenOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Close<'a> {
            reply_code: u16,
            reply_text: ::std::borrow::Cow<'a, str>,
            class_id: u16,
            method_id: u16,
        }
        impl<'a> Close<'a> {
            pub fn new<R>(reply_code: u16, reply_text: R, class_id: u16, method_id: u16) -> Self
                where R: Into<::std::borrow::Cow<'a, str>>
            {
                Close {
                    reply_code: reply_code,
                    reply_text: reply_text.into(),
                    class_id: class_id,
                    method_id: method_id,
                }
            }
            pub fn reply_code(&self) -> u16 {
                self.reply_code
            }
            pub fn reply_text(&self) -> &str {
                &*self.reply_text
            }
            pub fn class_id(&self) -> u16 {
                self.class_id
            }
            pub fn method_id(&self) -> u16 {
                self.method_id
            }
        }
        impl<'a> ::amqp0::Message for Close<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [7, self.reply_text.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct CloseOk;
        impl CloseOk {
            pub fn new() -> Self {
                CloseOk
            }
        }
        impl ::amqp0::Message for CloseOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }
    }
    pub mod exchange {

        // Class Modules
        pub struct Declare<'a> {
            exchange: ::std::borrow::Cow<'a, str>,
            ty: ::std::borrow::Cow<'a, str>,
            passive: bool,
            durable: bool,
            no_wait: bool,
            arguments: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
        }
        impl<'a> Declare<'a> {
            pub fn new<A, E, T>(exchange: E,
                                ty: T,
                                passive: bool,
                                durable: bool,
                                no_wait: bool,
                                arguments: A)
                                -> Self
                where E: Into<::std::borrow::Cow<'a, str>>,
                      T: Into<::std::borrow::Cow<'a, str>>,
                      A: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>
            {
                Declare {
                    exchange: exchange.into(),
                    ty: ty.into(),
                    passive: passive,
                    durable: durable,
                    no_wait: no_wait,
                    arguments: arguments.into(),
                }
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn ty(&self) -> &str {
                &*self.ty
            }
            pub fn passive(&self) -> bool {
                self.passive
            }
            pub fn durable(&self) -> bool {
                self.durable
            }
            pub fn no_wait(&self) -> bool {
                self.no_wait
            }
            pub fn arguments(&self) -> &::amqp0::value::Table {
                &*self.arguments
            }
        }
        impl<'a> ::amqp0::Message for Declare<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [3, self.exchange.len(), self.ty.len(), self.arguments.amqp_size()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct DeclareOk;
        impl DeclareOk {
            pub fn new() -> Self {
                DeclareOk
            }
        }
        impl ::amqp0::Message for DeclareOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Delete<'a> {
            exchange: ::std::borrow::Cow<'a, str>,
            if_unused: bool,
            no_wait: bool,
        }
        impl<'a> Delete<'a> {
            pub fn new<E>(exchange: E, if_unused: bool, no_wait: bool) -> Self
                where E: Into<::std::borrow::Cow<'a, str>>
            {
                Delete {
                    exchange: exchange.into(),
                    if_unused: if_unused,
                    no_wait: no_wait,
                }
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn if_unused(&self) -> bool {
                self.if_unused
            }
            pub fn no_wait(&self) -> bool {
                self.no_wait
            }
        }
        impl<'a> ::amqp0::Message for Delete<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.exchange.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct DeleteOk;
        impl DeleteOk {
            pub fn new() -> Self {
                DeleteOk
            }
        }
        impl ::amqp0::Message for DeleteOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }
    }
    pub mod queue {

        // Class Modules
        pub struct Declare<'a> {
            queue: ::std::borrow::Cow<'a, str>,
            passive: bool,
            durable: bool,
            exclusive: bool,
            auto_delete: bool,
            no_wait: bool,
            arguments: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
        }
        impl<'a> Declare<'a> {
            pub fn new<A, Q>(queue: Q,
                             passive: bool,
                             durable: bool,
                             exclusive: bool,
                             auto_delete: bool,
                             no_wait: bool,
                             arguments: A)
                             -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>,
                      A: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>
            {
                Declare {
                    queue: queue.into(),
                    passive: passive,
                    durable: durable,
                    exclusive: exclusive,
                    auto_delete: auto_delete,
                    no_wait: no_wait,
                    arguments: arguments.into(),
                }
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn passive(&self) -> bool {
                self.passive
            }
            pub fn durable(&self) -> bool {
                self.durable
            }
            pub fn exclusive(&self) -> bool {
                self.exclusive
            }
            pub fn auto_delete(&self) -> bool {
                self.auto_delete
            }
            pub fn no_wait(&self) -> bool {
                self.no_wait
            }
            pub fn arguments(&self) -> &::amqp0::value::Table {
                &*self.arguments
            }
        }
        impl<'a> ::amqp0::Message for Declare<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.queue.len(), self.arguments.amqp_size()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct DeclareOk<'a> {
            queue: ::std::borrow::Cow<'a, str>,
            message_count: u32,
            consumer_count: u32,
        }
        impl<'a> DeclareOk<'a> {
            pub fn new<Q>(queue: Q, message_count: u32, consumer_count: u32) -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>
            {
                DeclareOk {
                    queue: queue.into(),
                    message_count: message_count,
                    consumer_count: consumer_count,
                }
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn message_count(&self) -> u32 {
                self.message_count
            }
            pub fn consumer_count(&self) -> u32 {
                self.consumer_count
            }
        }
        impl<'a> ::amqp0::Message for DeclareOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [9, self.queue.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Bind<'a> {
            queue: ::std::borrow::Cow<'a, str>,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
            no_wait: bool,
            arguments: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
        }
        impl<'a> Bind<'a> {
            pub fn new<A, E, Q, R>(queue: Q,
                                   exchange: E,
                                   routing_key: R,
                                   no_wait: bool,
                                   arguments: A)
                                   -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>,
                      E: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, str>>,
                      A: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>
            {
                Bind {
                    queue: queue.into(),
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                    no_wait: no_wait,
                    arguments: arguments.into(),
                }
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
            pub fn no_wait(&self) -> bool {
                self.no_wait
            }
            pub fn arguments(&self) -> &::amqp0::value::Table {
                &*self.arguments
            }
        }
        impl<'a> ::amqp0::Message for Bind<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [4,
                 self.queue.len(),
                 self.exchange.len(),
                 self.routing_key.len(),
                 self.arguments.amqp_size()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct BindOk;
        impl BindOk {
            pub fn new() -> Self {
                BindOk
            }
        }
        impl ::amqp0::Message for BindOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Unbind<'a> {
            queue: ::std::borrow::Cow<'a, str>,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
            arguments: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
        }
        impl<'a> Unbind<'a> {
            pub fn new<A, E, Q, R>(queue: Q, exchange: E, routing_key: R, arguments: A) -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>,
                      E: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, str>>,
                      A: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>
            {
                Unbind {
                    queue: queue.into(),
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                    arguments: arguments.into(),
                }
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
            pub fn arguments(&self) -> &::amqp0::value::Table {
                &*self.arguments
            }
        }
        impl<'a> ::amqp0::Message for Unbind<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [3,
                 self.queue.len(),
                 self.exchange.len(),
                 self.routing_key.len(),
                 self.arguments.amqp_size()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct UnbindOk;
        impl UnbindOk {
            pub fn new() -> Self {
                UnbindOk
            }
        }
        impl ::amqp0::Message for UnbindOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Purge<'a> {
            queue: ::std::borrow::Cow<'a, str>,
            no_wait: bool,
        }
        impl<'a> Purge<'a> {
            pub fn new<Q>(queue: Q, no_wait: bool) -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>
            {
                Purge {
                    queue: queue.into(),
                    no_wait: no_wait,
                }
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn no_wait(&self) -> bool {
                self.no_wait
            }
        }
        impl<'a> ::amqp0::Message for Purge<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.queue.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct PurgeOk {
            message_count: u32,
        }
        impl PurgeOk {
            pub fn new(message_count: u32) -> Self {
                PurgeOk { message_count: message_count }
            }
            pub fn message_count(&self) -> u32 {
                self.message_count
            }
        }
        impl ::amqp0::Message for PurgeOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                4
            }
        }

        // Class Modules
        pub struct Delete<'a> {
            queue: ::std::borrow::Cow<'a, str>,
            if_unused: bool,
            if_empty: bool,
            no_wait: bool,
        }
        impl<'a> Delete<'a> {
            pub fn new<Q>(queue: Q, if_unused: bool, if_empty: bool, no_wait: bool) -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>
            {
                Delete {
                    queue: queue.into(),
                    if_unused: if_unused,
                    if_empty: if_empty,
                    no_wait: no_wait,
                }
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn if_unused(&self) -> bool {
                self.if_unused
            }
            pub fn if_empty(&self) -> bool {
                self.if_empty
            }
            pub fn no_wait(&self) -> bool {
                self.no_wait
            }
        }
        impl<'a> ::amqp0::Message for Delete<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.queue.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct DeleteOk {
            message_count: u32,
        }
        impl DeleteOk {
            pub fn new(message_count: u32) -> Self {
                DeleteOk { message_count: message_count }
            }
            pub fn message_count(&self) -> u32 {
                self.message_count
            }
        }
        impl ::amqp0::Message for DeleteOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                4
            }
        }
    }
    pub mod tx {

        // Class Modules
        pub struct Select;
        impl Select {
            pub fn new() -> Self {
                Select
            }
        }
        impl ::amqp0::Message for Select {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct SelectOk;
        impl SelectOk {
            pub fn new() -> Self {
                SelectOk
            }
        }
        impl ::amqp0::Message for SelectOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Commit;
        impl Commit {
            pub fn new() -> Self {
                Commit
            }
        }
        impl ::amqp0::Message for Commit {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct CommitOk;
        impl CommitOk {
            pub fn new() -> Self {
                CommitOk
            }
        }
        impl ::amqp0::Message for CommitOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Rollback;
        impl Rollback {
            pub fn new() -> Self {
                Rollback
            }
        }
        impl ::amqp0::Message for Rollback {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct RollbackOk;
        impl RollbackOk {
            pub fn new() -> Self {
                RollbackOk
            }
        }
        impl ::amqp0::Message for RollbackOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }
    }
}

#[allow(non_camel_case_types)]
pub struct Amqp9_1;
impl Spec for Amqp9_1 {}

pub mod amqp9_0 {
    // Class Constants
    pub const CLASS_ACCESS: u16 = 30;
    pub const CLASS_BASIC: u16 = 60;
    pub const CLASS_CHANNEL: u16 = 20;
    pub const CLASS_CONNECTION: u16 = 10;
    pub const CLASS_DTX: u16 = 100;
    pub const CLASS_EXCHANGE: u16 = 40;
    pub const CLASS_FILE: u16 = 70;
    pub const CLASS_MESSAGE: u16 = 120;
    pub const CLASS_QUEUE: u16 = 50;
    pub const CLASS_STREAM: u16 = 80;
    pub const CLASS_TUNNEL: u16 = 110;
    pub const CLASS_TX: u16 = 90;

    // Class Methods
    pub const METHOD_ACCESS_REQUEST: u16 = 10;
    pub const METHOD_ACCESS_REQUEST_OK: u16 = 11;

    pub const METHOD_BASIC_QOS: u16 = 10;
    pub const METHOD_BASIC_QOS_OK: u16 = 11;
    pub const METHOD_BASIC_CONSUME: u16 = 20;
    pub const METHOD_BASIC_CONSUME_OK: u16 = 21;
    pub const METHOD_BASIC_CANCEL: u16 = 30;
    pub const METHOD_BASIC_CANCEL_OK: u16 = 31;
    pub const METHOD_BASIC_PUBLISH: u16 = 40;
    pub const METHOD_BASIC_RETURN: u16 = 50;
    pub const METHOD_BASIC_DELIVER: u16 = 60;
    pub const METHOD_BASIC_GET: u16 = 70;
    pub const METHOD_BASIC_GET_OK: u16 = 71;
    pub const METHOD_BASIC_GET_EMPTY: u16 = 72;
    pub const METHOD_BASIC_ACK: u16 = 80;
    pub const METHOD_BASIC_REJECT: u16 = 90;
    pub const METHOD_BASIC_RECOVER: u16 = 100;

    pub const METHOD_CHANNEL_OPEN: u16 = 10;
    pub const METHOD_CHANNEL_OPEN_OK: u16 = 11;
    pub const METHOD_CHANNEL_FLOW: u16 = 20;
    pub const METHOD_CHANNEL_FLOW_OK: u16 = 21;
    pub const METHOD_CHANNEL_CLOSE: u16 = 40;
    pub const METHOD_CHANNEL_CLOSE_OK: u16 = 41;
    pub const METHOD_CHANNEL_RESUME: u16 = 50;
    pub const METHOD_CHANNEL_PING: u16 = 60;
    pub const METHOD_CHANNEL_PONG: u16 = 70;
    pub const METHOD_CHANNEL_OK: u16 = 80;

    pub const METHOD_CONNECTION_START: u16 = 10;
    pub const METHOD_CONNECTION_START_OK: u16 = 11;
    pub const METHOD_CONNECTION_SECURE: u16 = 20;
    pub const METHOD_CONNECTION_SECURE_OK: u16 = 21;
    pub const METHOD_CONNECTION_TUNE: u16 = 30;
    pub const METHOD_CONNECTION_TUNE_OK: u16 = 31;
    pub const METHOD_CONNECTION_OPEN: u16 = 40;
    pub const METHOD_CONNECTION_OPEN_OK: u16 = 41;
    pub const METHOD_CONNECTION_REDIRECT: u16 = 42;
    pub const METHOD_CONNECTION_CLOSE: u16 = 50;
    pub const METHOD_CONNECTION_CLOSE_OK: u16 = 51;

    pub const METHOD_DTX_SELECT: u16 = 10;
    pub const METHOD_DTX_SELECT_OK: u16 = 11;
    pub const METHOD_DTX_START: u16 = 20;
    pub const METHOD_DTX_START_OK: u16 = 21;

    pub const METHOD_EXCHANGE_DECLARE: u16 = 10;
    pub const METHOD_EXCHANGE_DECLARE_OK: u16 = 11;
    pub const METHOD_EXCHANGE_DELETE: u16 = 20;
    pub const METHOD_EXCHANGE_DELETE_OK: u16 = 21;

    pub const METHOD_FILE_QOS: u16 = 10;
    pub const METHOD_FILE_QOS_OK: u16 = 11;
    pub const METHOD_FILE_CONSUME: u16 = 20;
    pub const METHOD_FILE_CONSUME_OK: u16 = 21;
    pub const METHOD_FILE_CANCEL: u16 = 30;
    pub const METHOD_FILE_CANCEL_OK: u16 = 31;
    pub const METHOD_FILE_OPEN: u16 = 40;
    pub const METHOD_FILE_OPEN_OK: u16 = 41;
    pub const METHOD_FILE_STAGE: u16 = 50;
    pub const METHOD_FILE_PUBLISH: u16 = 60;
    pub const METHOD_FILE_RETURN: u16 = 70;
    pub const METHOD_FILE_DELIVER: u16 = 80;
    pub const METHOD_FILE_ACK: u16 = 90;
    pub const METHOD_FILE_REJECT: u16 = 100;

    pub const METHOD_MESSAGE_TRANSFER: u16 = 10;
    pub const METHOD_MESSAGE_CONSUME: u16 = 20;
    pub const METHOD_MESSAGE_CANCEL: u16 = 30;
    pub const METHOD_MESSAGE_GET: u16 = 40;
    pub const METHOD_MESSAGE_RECOVER: u16 = 50;
    pub const METHOD_MESSAGE_OPEN: u16 = 60;
    pub const METHOD_MESSAGE_CLOSE: u16 = 70;
    pub const METHOD_MESSAGE_APPEND: u16 = 80;
    pub const METHOD_MESSAGE_CHECKPOINT: u16 = 90;
    pub const METHOD_MESSAGE_RESUME: u16 = 100;
    pub const METHOD_MESSAGE_QOS: u16 = 110;
    pub const METHOD_MESSAGE_OK: u16 = 500;
    pub const METHOD_MESSAGE_EMPTY: u16 = 510;
    pub const METHOD_MESSAGE_REJECT: u16 = 520;
    pub const METHOD_MESSAGE_OFFSET: u16 = 530;

    pub const METHOD_QUEUE_DECLARE: u16 = 10;
    pub const METHOD_QUEUE_DECLARE_OK: u16 = 11;
    pub const METHOD_QUEUE_BIND: u16 = 20;
    pub const METHOD_QUEUE_BIND_OK: u16 = 21;
    pub const METHOD_QUEUE_UNBIND: u16 = 50;
    pub const METHOD_QUEUE_UNBIND_OK: u16 = 51;
    pub const METHOD_QUEUE_PURGE: u16 = 30;
    pub const METHOD_QUEUE_PURGE_OK: u16 = 31;
    pub const METHOD_QUEUE_DELETE: u16 = 40;
    pub const METHOD_QUEUE_DELETE_OK: u16 = 41;

    pub const METHOD_STREAM_QOS: u16 = 10;
    pub const METHOD_STREAM_QOS_OK: u16 = 11;
    pub const METHOD_STREAM_CONSUME: u16 = 20;
    pub const METHOD_STREAM_CONSUME_OK: u16 = 21;
    pub const METHOD_STREAM_CANCEL: u16 = 30;
    pub const METHOD_STREAM_CANCEL_OK: u16 = 31;
    pub const METHOD_STREAM_PUBLISH: u16 = 40;
    pub const METHOD_STREAM_RETURN: u16 = 50;
    pub const METHOD_STREAM_DELIVER: u16 = 60;

    pub const METHOD_TUNNEL_REQUEST: u16 = 10;

    pub const METHOD_TX_SELECT: u16 = 10;
    pub const METHOD_TX_SELECT_OK: u16 = 11;
    pub const METHOD_TX_COMMIT: u16 = 20;
    pub const METHOD_TX_COMMIT_OK: u16 = 21;
    pub const METHOD_TX_ROLLBACK: u16 = 30;
    pub const METHOD_TX_ROLLBACK_OK: u16 = 31;
    pub mod access {

        // Class Modules
        pub struct Request<'a> {
            realm: ::std::borrow::Cow<'a, str>,
            exclusive: bool,
            passive: bool,
            active: bool,
            write: bool,
            read: bool,
        }
        impl<'a> Request<'a> {
            pub fn new<R>(realm: R,
                          exclusive: bool,
                          passive: bool,
                          active: bool,
                          write: bool,
                          read: bool)
                          -> Self
                where R: Into<::std::borrow::Cow<'a, str>>
            {
                Request {
                    realm: realm.into(),
                    exclusive: exclusive,
                    passive: passive,
                    active: active,
                    write: write,
                    read: read,
                }
            }
            pub fn realm(&self) -> &str {
                &*self.realm
            }
            pub fn exclusive(&self) -> bool {
                self.exclusive
            }
            pub fn passive(&self) -> bool {
                self.passive
            }
            pub fn active(&self) -> bool {
                self.active
            }
            pub fn write(&self) -> bool {
                self.write
            }
            pub fn read(&self) -> bool {
                self.read
            }
        }
        impl<'a> ::amqp0::Message for Request<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.realm.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct RequestOk {
            ticket: u16,
        }
        impl RequestOk {
            pub fn new(ticket: u16) -> Self {
                RequestOk { ticket: ticket }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
        }
        impl ::amqp0::Message for RequestOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                2
            }
        }
    }
    pub mod basic {

        // Class Modules
        pub struct Qos {
            prefetch_size: u32,
            prefetch_count: u16,
            global: bool,
        }
        impl Qos {
            pub fn new(prefetch_size: u32, prefetch_count: u16, global: bool) -> Self {
                Qos {
                    prefetch_size: prefetch_size,
                    prefetch_count: prefetch_count,
                    global: global,
                }
            }
            pub fn prefetch_size(&self) -> u32 {
                self.prefetch_size
            }
            pub fn prefetch_count(&self) -> u16 {
                self.prefetch_count
            }
            pub fn global(&self) -> bool {
                self.global
            }
        }
        impl ::amqp0::Message for Qos {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                7
            }
        }

        // Class Modules
        pub struct QosOk;
        impl QosOk {
            pub fn new() -> Self {
                QosOk
            }
        }
        impl ::amqp0::Message for QosOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Consume<'a> {
            ticket: u16,
            queue: ::std::borrow::Cow<'a, str>,
            consumer_tag: ::std::borrow::Cow<'a, str>,
            no_local: bool,
            no_ack: bool,
            exclusive: bool,
            nowait: bool,
            filter: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
        }
        impl<'a> Consume<'a> {
            pub fn new<C, F, Q>(ticket: u16,
                                queue: Q,
                                consumer_tag: C,
                                no_local: bool,
                                no_ack: bool,
                                exclusive: bool,
                                nowait: bool,
                                filter: F)
                                -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>,
                      C: Into<::std::borrow::Cow<'a, str>>,
                      F: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>
            {
                Consume {
                    ticket: ticket,
                    queue: queue.into(),
                    consumer_tag: consumer_tag.into(),
                    no_local: no_local,
                    no_ack: no_ack,
                    exclusive: exclusive,
                    nowait: nowait,
                    filter: filter.into(),
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
            pub fn no_local(&self) -> bool {
                self.no_local
            }
            pub fn no_ack(&self) -> bool {
                self.no_ack
            }
            pub fn exclusive(&self) -> bool {
                self.exclusive
            }
            pub fn nowait(&self) -> bool {
                self.nowait
            }
            pub fn filter(&self) -> &::amqp0::value::Table {
                &*self.filter
            }
        }
        impl<'a> ::amqp0::Message for Consume<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [5, self.queue.len(), self.consumer_tag.len(), self.filter.amqp_size()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct ConsumeOk<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> ConsumeOk<'a> {
            pub fn new<C>(consumer_tag: C) -> Self
                where C: Into<::std::borrow::Cow<'a, str>>
            {
                ConsumeOk { consumer_tag: consumer_tag.into() }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
        }
        impl<'a> ::amqp0::Message for ConsumeOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [1, self.consumer_tag.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Cancel<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
            nowait: bool,
        }
        impl<'a> Cancel<'a> {
            pub fn new<C>(consumer_tag: C, nowait: bool) -> Self
                where C: Into<::std::borrow::Cow<'a, str>>
            {
                Cancel {
                    consumer_tag: consumer_tag.into(),
                    nowait: nowait,
                }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
            pub fn nowait(&self) -> bool {
                self.nowait
            }
        }
        impl<'a> ::amqp0::Message for Cancel<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.consumer_tag.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct CancelOk<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> CancelOk<'a> {
            pub fn new<C>(consumer_tag: C) -> Self
                where C: Into<::std::borrow::Cow<'a, str>>
            {
                CancelOk { consumer_tag: consumer_tag.into() }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
        }
        impl<'a> ::amqp0::Message for CancelOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [1, self.consumer_tag.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Publish<'a> {
            ticket: u16,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
            mandatory: bool,
            immediate: bool,
        }
        impl<'a> Publish<'a> {
            pub fn new<E, R>(ticket: u16,
                             exchange: E,
                             routing_key: R,
                             mandatory: bool,
                             immediate: bool)
                             -> Self
                where E: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, str>>
            {
                Publish {
                    ticket: ticket,
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                    mandatory: mandatory,
                    immediate: immediate,
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
            pub fn mandatory(&self) -> bool {
                self.mandatory
            }
            pub fn immediate(&self) -> bool {
                self.immediate
            }
        }
        impl<'a> ::amqp0::Message for Publish<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [5, self.exchange.len(), self.routing_key.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Return<'a> {
            reply_code: u16,
            reply_text: ::std::borrow::Cow<'a, str>,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Return<'a> {
            pub fn new<E, R, R0>(reply_code: u16,
                                 reply_text: R,
                                 exchange: E,
                                 routing_key: R0)
                                 -> Self
                where R: Into<::std::borrow::Cow<'a, str>>,
                      E: Into<::std::borrow::Cow<'a, str>>,
                      R0: Into<::std::borrow::Cow<'a, str>>
            {
                Return {
                    reply_code: reply_code,
                    reply_text: reply_text.into(),
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                }
            }
            pub fn reply_code(&self) -> u16 {
                self.reply_code
            }
            pub fn reply_text(&self) -> &str {
                &*self.reply_text
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
        }
        impl<'a> ::amqp0::Message for Return<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [5, self.reply_text.len(), self.exchange.len(), self.routing_key.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Deliver<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
            delivery_tag: u64,
            redelivered: bool,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Deliver<'a> {
            pub fn new<C, E, R>(consumer_tag: C,
                                delivery_tag: u64,
                                redelivered: bool,
                                exchange: E,
                                routing_key: R)
                                -> Self
                where C: Into<::std::borrow::Cow<'a, str>>,
                      E: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, str>>
            {
                Deliver {
                    consumer_tag: consumer_tag.into(),
                    delivery_tag: delivery_tag,
                    redelivered: redelivered,
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
            pub fn delivery_tag(&self) -> u64 {
                self.delivery_tag
            }
            pub fn redelivered(&self) -> bool {
                self.redelivered
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
        }
        impl<'a> ::amqp0::Message for Deliver<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [12, self.consumer_tag.len(), self.exchange.len(), self.routing_key.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Get<'a> {
            ticket: u16,
            queue: ::std::borrow::Cow<'a, str>,
            no_ack: bool,
        }
        impl<'a> Get<'a> {
            pub fn new<Q>(ticket: u16, queue: Q, no_ack: bool) -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>
            {
                Get {
                    ticket: ticket,
                    queue: queue.into(),
                    no_ack: no_ack,
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn no_ack(&self) -> bool {
                self.no_ack
            }
        }
        impl<'a> ::amqp0::Message for Get<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [4, self.queue.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct GetOk<'a> {
            delivery_tag: u64,
            redelivered: bool,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
            message_count: u32,
        }
        impl<'a> GetOk<'a> {
            pub fn new<E, R>(delivery_tag: u64,
                             redelivered: bool,
                             exchange: E,
                             routing_key: R,
                             message_count: u32)
                             -> Self
                where E: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, str>>
            {
                GetOk {
                    delivery_tag: delivery_tag,
                    redelivered: redelivered,
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                    message_count: message_count,
                }
            }
            pub fn delivery_tag(&self) -> u64 {
                self.delivery_tag
            }
            pub fn redelivered(&self) -> bool {
                self.redelivered
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
            pub fn message_count(&self) -> u32 {
                self.message_count
            }
        }
        impl<'a> ::amqp0::Message for GetOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [15, self.exchange.len(), self.routing_key.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct GetEmpty<'a> {
            cluster_id: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> GetEmpty<'a> {
            pub fn new<C>(cluster_id: C) -> Self
                where C: Into<::std::borrow::Cow<'a, str>>
            {
                GetEmpty { cluster_id: cluster_id.into() }
            }
            pub fn cluster_id(&self) -> &str {
                &*self.cluster_id
            }
        }
        impl<'a> ::amqp0::Message for GetEmpty<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [1, self.cluster_id.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Ack {
            delivery_tag: u64,
            multiple: bool,
        }
        impl Ack {
            pub fn new(delivery_tag: u64, multiple: bool) -> Self {
                Ack {
                    delivery_tag: delivery_tag,
                    multiple: multiple,
                }
            }
            pub fn delivery_tag(&self) -> u64 {
                self.delivery_tag
            }
            pub fn multiple(&self) -> bool {
                self.multiple
            }
        }
        impl ::amqp0::Message for Ack {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                9
            }
        }

        // Class Modules
        pub struct Reject {
            delivery_tag: u64,
            requeue: bool,
        }
        impl Reject {
            pub fn new(delivery_tag: u64, requeue: bool) -> Self {
                Reject {
                    delivery_tag: delivery_tag,
                    requeue: requeue,
                }
            }
            pub fn delivery_tag(&self) -> u64 {
                self.delivery_tag
            }
            pub fn requeue(&self) -> bool {
                self.requeue
            }
        }
        impl ::amqp0::Message for Reject {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                9
            }
        }

        // Class Modules
        pub struct Recover {
            requeue: bool,
        }
        impl Recover {
            pub fn new(requeue: bool) -> Self {
                Recover { requeue: requeue }
            }
            pub fn requeue(&self) -> bool {
                self.requeue
            }
        }
        impl ::amqp0::Message for Recover {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                1
            }
        }
    }
    pub mod channel {

        // Class Modules
        pub struct Open<'a> {
            out_of_band: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Open<'a> {
            pub fn new<O>(out_of_band: O) -> Self
                where O: Into<::std::borrow::Cow<'a, str>>
            {
                Open { out_of_band: out_of_band.into() }
            }
            pub fn out_of_band(&self) -> &str {
                &*self.out_of_band
            }
        }
        impl<'a> ::amqp0::Message for Open<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [1, self.out_of_band.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct OpenOk<'a> {
            channel_id: ::std::borrow::Cow<'a, [u8]>,
        }
        impl<'a> OpenOk<'a> {
            pub fn new<C>(channel_id: C) -> Self
                where C: Into<::std::borrow::Cow<'a, [u8]>>
            {
                OpenOk { channel_id: channel_id.into() }
            }
            pub fn channel_id(&self) -> &[u8] {
                &*self.channel_id
            }
        }
        impl<'a> ::amqp0::Message for OpenOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.channel_id.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Flow {
            active: bool,
        }
        impl Flow {
            pub fn new(active: bool) -> Self {
                Flow { active: active }
            }
            pub fn active(&self) -> bool {
                self.active
            }
        }
        impl ::amqp0::Message for Flow {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                1
            }
        }

        // Class Modules
        pub struct FlowOk {
            active: bool,
        }
        impl FlowOk {
            pub fn new(active: bool) -> Self {
                FlowOk { active: active }
            }
            pub fn active(&self) -> bool {
                self.active
            }
        }
        impl ::amqp0::Message for FlowOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                1
            }
        }

        // Class Modules
        pub struct Close<'a> {
            reply_code: u16,
            reply_text: ::std::borrow::Cow<'a, str>,
            class_id: u16,
            method_id: u16,
        }
        impl<'a> Close<'a> {
            pub fn new<R>(reply_code: u16, reply_text: R, class_id: u16, method_id: u16) -> Self
                where R: Into<::std::borrow::Cow<'a, str>>
            {
                Close {
                    reply_code: reply_code,
                    reply_text: reply_text.into(),
                    class_id: class_id,
                    method_id: method_id,
                }
            }
            pub fn reply_code(&self) -> u16 {
                self.reply_code
            }
            pub fn reply_text(&self) -> &str {
                &*self.reply_text
            }
            pub fn class_id(&self) -> u16 {
                self.class_id
            }
            pub fn method_id(&self) -> u16 {
                self.method_id
            }
        }
        impl<'a> ::amqp0::Message for Close<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [7, self.reply_text.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct CloseOk;
        impl CloseOk {
            pub fn new() -> Self {
                CloseOk
            }
        }
        impl ::amqp0::Message for CloseOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Resume<'a> {
            channel_id: ::std::borrow::Cow<'a, [u8]>,
        }
        impl<'a> Resume<'a> {
            pub fn new<C>(channel_id: C) -> Self
                where C: Into<::std::borrow::Cow<'a, [u8]>>
            {
                Resume { channel_id: channel_id.into() }
            }
            pub fn channel_id(&self) -> &[u8] {
                &*self.channel_id
            }
        }
        impl<'a> ::amqp0::Message for Resume<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.channel_id.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Ping;
        impl Ping {
            pub fn new() -> Self {
                Ping
            }
        }
        impl ::amqp0::Message for Ping {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Pong;
        impl Pong {
            pub fn new() -> Self {
                Pong
            }
        }
        impl ::amqp0::Message for Pong {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Ok;
        impl Ok {
            pub fn new() -> Self {
                Ok
            }
        }
        impl ::amqp0::Message for Ok {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }
    }
    pub mod connection {

        // Class Modules
        pub struct Start<'a> {
            version_major: u8,
            version_minor: u8,
            server_properties: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
            mechanisms: ::std::borrow::Cow<'a, [u8]>,
            locales: ::std::borrow::Cow<'a, [u8]>,
        }
        impl<'a> Start<'a> {
            pub fn new<L, M, S>(version_major: u8,
                                version_minor: u8,
                                server_properties: S,
                                mechanisms: M,
                                locales: L)
                                -> Self
                where S: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>,
                      M: Into<::std::borrow::Cow<'a, [u8]>>,
                      L: Into<::std::borrow::Cow<'a, [u8]>>
            {
                Start {
                    version_major: version_major,
                    version_minor: version_minor,
                    server_properties: server_properties.into(),
                    mechanisms: mechanisms.into(),
                    locales: locales.into(),
                }
            }
            pub fn version_major(&self) -> u8 {
                self.version_major
            }
            pub fn version_minor(&self) -> u8 {
                self.version_minor
            }
            pub fn server_properties(&self) -> &::amqp0::value::Table {
                &*self.server_properties
            }
            pub fn mechanisms(&self) -> &[u8] {
                &*self.mechanisms
            }
            pub fn locales(&self) -> &[u8] {
                &*self.locales
            }
        }
        impl<'a> ::amqp0::Message for Start<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [6, self.server_properties.amqp_size(), self.mechanisms.len(), self.locales.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct StartOk<'a> {
            client_properties: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
            mechanism: ::std::borrow::Cow<'a, str>,
            response: ::std::borrow::Cow<'a, [u8]>,
            locale: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> StartOk<'a> {
            pub fn new<C, L, M, R>(client_properties: C,
                                   mechanism: M,
                                   response: R,
                                   locale: L)
                                   -> Self
                where C: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>,
                      M: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, [u8]>>,
                      L: Into<::std::borrow::Cow<'a, str>>
            {
                StartOk {
                    client_properties: client_properties.into(),
                    mechanism: mechanism.into(),
                    response: response.into(),
                    locale: locale.into(),
                }
            }
            pub fn client_properties(&self) -> &::amqp0::value::Table {
                &*self.client_properties
            }
            pub fn mechanism(&self) -> &str {
                &*self.mechanism
            }
            pub fn response(&self) -> &[u8] {
                &*self.response
            }
            pub fn locale(&self) -> &str {
                &*self.locale
            }
        }
        impl<'a> ::amqp0::Message for StartOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [4,
                 self.client_properties.amqp_size(),
                 self.mechanism.len(),
                 self.response.len(),
                 self.locale.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Secure<'a> {
            challenge: ::std::borrow::Cow<'a, [u8]>,
        }
        impl<'a> Secure<'a> {
            pub fn new<C>(challenge: C) -> Self
                where C: Into<::std::borrow::Cow<'a, [u8]>>
            {
                Secure { challenge: challenge.into() }
            }
            pub fn challenge(&self) -> &[u8] {
                &*self.challenge
            }
        }
        impl<'a> ::amqp0::Message for Secure<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.challenge.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct SecureOk<'a> {
            response: ::std::borrow::Cow<'a, [u8]>,
        }
        impl<'a> SecureOk<'a> {
            pub fn new<R>(response: R) -> Self
                where R: Into<::std::borrow::Cow<'a, [u8]>>
            {
                SecureOk { response: response.into() }
            }
            pub fn response(&self) -> &[u8] {
                &*self.response
            }
        }
        impl<'a> ::amqp0::Message for SecureOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.response.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Tune {
            channel_max: u16,
            frame_max: u32,
            heartbeat: u16,
        }
        impl Tune {
            pub fn new(channel_max: u16, frame_max: u32, heartbeat: u16) -> Self {
                Tune {
                    channel_max: channel_max,
                    frame_max: frame_max,
                    heartbeat: heartbeat,
                }
            }
            pub fn channel_max(&self) -> u16 {
                self.channel_max
            }
            pub fn frame_max(&self) -> u32 {
                self.frame_max
            }
            pub fn heartbeat(&self) -> u16 {
                self.heartbeat
            }
        }
        impl ::amqp0::Message for Tune {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                8
            }
        }

        // Class Modules
        pub struct TuneOk {
            channel_max: u16,
            frame_max: u32,
            heartbeat: u16,
        }
        impl TuneOk {
            pub fn new(channel_max: u16, frame_max: u32, heartbeat: u16) -> Self {
                TuneOk {
                    channel_max: channel_max,
                    frame_max: frame_max,
                    heartbeat: heartbeat,
                }
            }
            pub fn channel_max(&self) -> u16 {
                self.channel_max
            }
            pub fn frame_max(&self) -> u32 {
                self.frame_max
            }
            pub fn heartbeat(&self) -> u16 {
                self.heartbeat
            }
        }
        impl ::amqp0::Message for TuneOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                8
            }
        }

        // Class Modules
        pub struct Open<'a> {
            virtual_host: ::std::borrow::Cow<'a, str>,
            capabilities: ::std::borrow::Cow<'a, str>,
            insist: bool,
        }
        impl<'a> Open<'a> {
            pub fn new<C, V>(virtual_host: V, capabilities: C, insist: bool) -> Self
                where V: Into<::std::borrow::Cow<'a, str>>,
                      C: Into<::std::borrow::Cow<'a, str>>
            {
                Open {
                    virtual_host: virtual_host.into(),
                    capabilities: capabilities.into(),
                    insist: insist,
                }
            }
            pub fn virtual_host(&self) -> &str {
                &*self.virtual_host
            }
            pub fn capabilities(&self) -> &str {
                &*self.capabilities
            }
            pub fn insist(&self) -> bool {
                self.insist
            }
        }
        impl<'a> ::amqp0::Message for Open<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [3, self.virtual_host.len(), self.capabilities.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct OpenOk<'a> {
            known_hosts: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> OpenOk<'a> {
            pub fn new<K>(known_hosts: K) -> Self
                where K: Into<::std::borrow::Cow<'a, str>>
            {
                OpenOk { known_hosts: known_hosts.into() }
            }
            pub fn known_hosts(&self) -> &str {
                &*self.known_hosts
            }
        }
        impl<'a> ::amqp0::Message for OpenOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [1, self.known_hosts.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Redirect<'a> {
            host: ::std::borrow::Cow<'a, str>,
            known_hosts: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Redirect<'a> {
            pub fn new<H, K>(host: H, known_hosts: K) -> Self
                where H: Into<::std::borrow::Cow<'a, str>>,
                      K: Into<::std::borrow::Cow<'a, str>>
            {
                Redirect {
                    host: host.into(),
                    known_hosts: known_hosts.into(),
                }
            }
            pub fn host(&self) -> &str {
                &*self.host
            }
            pub fn known_hosts(&self) -> &str {
                &*self.known_hosts
            }
        }
        impl<'a> ::amqp0::Message for Redirect<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.host.len(), self.known_hosts.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Close<'a> {
            reply_code: u16,
            reply_text: ::std::borrow::Cow<'a, str>,
            class_id: u16,
            method_id: u16,
        }
        impl<'a> Close<'a> {
            pub fn new<R>(reply_code: u16, reply_text: R, class_id: u16, method_id: u16) -> Self
                where R: Into<::std::borrow::Cow<'a, str>>
            {
                Close {
                    reply_code: reply_code,
                    reply_text: reply_text.into(),
                    class_id: class_id,
                    method_id: method_id,
                }
            }
            pub fn reply_code(&self) -> u16 {
                self.reply_code
            }
            pub fn reply_text(&self) -> &str {
                &*self.reply_text
            }
            pub fn class_id(&self) -> u16 {
                self.class_id
            }
            pub fn method_id(&self) -> u16 {
                self.method_id
            }
        }
        impl<'a> ::amqp0::Message for Close<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [7, self.reply_text.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct CloseOk;
        impl CloseOk {
            pub fn new() -> Self {
                CloseOk
            }
        }
        impl ::amqp0::Message for CloseOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }
    }
    pub mod dtx {

        // Class Modules
        pub struct Select;
        impl Select {
            pub fn new() -> Self {
                Select
            }
        }
        impl ::amqp0::Message for Select {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct SelectOk;
        impl SelectOk {
            pub fn new() -> Self {
                SelectOk
            }
        }
        impl ::amqp0::Message for SelectOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Start<'a> {
            dtx_identifier: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Start<'a> {
            pub fn new<D>(dtx_identifier: D) -> Self
                where D: Into<::std::borrow::Cow<'a, str>>
            {
                Start { dtx_identifier: dtx_identifier.into() }
            }
            pub fn dtx_identifier(&self) -> &str {
                &*self.dtx_identifier
            }
        }
        impl<'a> ::amqp0::Message for Start<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [1, self.dtx_identifier.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct StartOk;
        impl StartOk {
            pub fn new() -> Self {
                StartOk
            }
        }
        impl ::amqp0::Message for StartOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }
    }
    pub mod exchange {

        // Class Modules
        pub struct Declare<'a> {
            ticket: u16,
            exchange: ::std::borrow::Cow<'a, str>,
            ty: ::std::borrow::Cow<'a, str>,
            passive: bool,
            durable: bool,
            auto_delete: bool,
            internal: bool,
            nowait: bool,
            arguments: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
        }
        impl<'a> Declare<'a> {
            pub fn new<A, E, T>(ticket: u16,
                                exchange: E,
                                ty: T,
                                passive: bool,
                                durable: bool,
                                auto_delete: bool,
                                internal: bool,
                                nowait: bool,
                                arguments: A)
                                -> Self
                where E: Into<::std::borrow::Cow<'a, str>>,
                      T: Into<::std::borrow::Cow<'a, str>>,
                      A: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>
            {
                Declare {
                    ticket: ticket,
                    exchange: exchange.into(),
                    ty: ty.into(),
                    passive: passive,
                    durable: durable,
                    auto_delete: auto_delete,
                    internal: internal,
                    nowait: nowait,
                    arguments: arguments.into(),
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn ty(&self) -> &str {
                &*self.ty
            }
            pub fn passive(&self) -> bool {
                self.passive
            }
            pub fn durable(&self) -> bool {
                self.durable
            }
            pub fn auto_delete(&self) -> bool {
                self.auto_delete
            }
            pub fn internal(&self) -> bool {
                self.internal
            }
            pub fn nowait(&self) -> bool {
                self.nowait
            }
            pub fn arguments(&self) -> &::amqp0::value::Table {
                &*self.arguments
            }
        }
        impl<'a> ::amqp0::Message for Declare<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [5, self.exchange.len(), self.ty.len(), self.arguments.amqp_size()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct DeclareOk;
        impl DeclareOk {
            pub fn new() -> Self {
                DeclareOk
            }
        }
        impl ::amqp0::Message for DeclareOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Delete<'a> {
            ticket: u16,
            exchange: ::std::borrow::Cow<'a, str>,
            if_unused: bool,
            nowait: bool,
        }
        impl<'a> Delete<'a> {
            pub fn new<E>(ticket: u16, exchange: E, if_unused: bool, nowait: bool) -> Self
                where E: Into<::std::borrow::Cow<'a, str>>
            {
                Delete {
                    ticket: ticket,
                    exchange: exchange.into(),
                    if_unused: if_unused,
                    nowait: nowait,
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn if_unused(&self) -> bool {
                self.if_unused
            }
            pub fn nowait(&self) -> bool {
                self.nowait
            }
        }
        impl<'a> ::amqp0::Message for Delete<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [4, self.exchange.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct DeleteOk;
        impl DeleteOk {
            pub fn new() -> Self {
                DeleteOk
            }
        }
        impl ::amqp0::Message for DeleteOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }
    }
    pub mod file {

        // Class Modules
        pub struct Qos {
            prefetch_size: u32,
            prefetch_count: u16,
            global: bool,
        }
        impl Qos {
            pub fn new(prefetch_size: u32, prefetch_count: u16, global: bool) -> Self {
                Qos {
                    prefetch_size: prefetch_size,
                    prefetch_count: prefetch_count,
                    global: global,
                }
            }
            pub fn prefetch_size(&self) -> u32 {
                self.prefetch_size
            }
            pub fn prefetch_count(&self) -> u16 {
                self.prefetch_count
            }
            pub fn global(&self) -> bool {
                self.global
            }
        }
        impl ::amqp0::Message for Qos {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                7
            }
        }

        // Class Modules
        pub struct QosOk;
        impl QosOk {
            pub fn new() -> Self {
                QosOk
            }
        }
        impl ::amqp0::Message for QosOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Consume<'a> {
            ticket: u16,
            queue: ::std::borrow::Cow<'a, str>,
            consumer_tag: ::std::borrow::Cow<'a, str>,
            no_local: bool,
            no_ack: bool,
            exclusive: bool,
            nowait: bool,
            filter: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
        }
        impl<'a> Consume<'a> {
            pub fn new<C, F, Q>(ticket: u16,
                                queue: Q,
                                consumer_tag: C,
                                no_local: bool,
                                no_ack: bool,
                                exclusive: bool,
                                nowait: bool,
                                filter: F)
                                -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>,
                      C: Into<::std::borrow::Cow<'a, str>>,
                      F: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>
            {
                Consume {
                    ticket: ticket,
                    queue: queue.into(),
                    consumer_tag: consumer_tag.into(),
                    no_local: no_local,
                    no_ack: no_ack,
                    exclusive: exclusive,
                    nowait: nowait,
                    filter: filter.into(),
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
            pub fn no_local(&self) -> bool {
                self.no_local
            }
            pub fn no_ack(&self) -> bool {
                self.no_ack
            }
            pub fn exclusive(&self) -> bool {
                self.exclusive
            }
            pub fn nowait(&self) -> bool {
                self.nowait
            }
            pub fn filter(&self) -> &::amqp0::value::Table {
                &*self.filter
            }
        }
        impl<'a> ::amqp0::Message for Consume<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [5, self.queue.len(), self.consumer_tag.len(), self.filter.amqp_size()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct ConsumeOk<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> ConsumeOk<'a> {
            pub fn new<C>(consumer_tag: C) -> Self
                where C: Into<::std::borrow::Cow<'a, str>>
            {
                ConsumeOk { consumer_tag: consumer_tag.into() }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
        }
        impl<'a> ::amqp0::Message for ConsumeOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [1, self.consumer_tag.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Cancel<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
            nowait: bool,
        }
        impl<'a> Cancel<'a> {
            pub fn new<C>(consumer_tag: C, nowait: bool) -> Self
                where C: Into<::std::borrow::Cow<'a, str>>
            {
                Cancel {
                    consumer_tag: consumer_tag.into(),
                    nowait: nowait,
                }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
            pub fn nowait(&self) -> bool {
                self.nowait
            }
        }
        impl<'a> ::amqp0::Message for Cancel<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.consumer_tag.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct CancelOk<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> CancelOk<'a> {
            pub fn new<C>(consumer_tag: C) -> Self
                where C: Into<::std::borrow::Cow<'a, str>>
            {
                CancelOk { consumer_tag: consumer_tag.into() }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
        }
        impl<'a> ::amqp0::Message for CancelOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [1, self.consumer_tag.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Open<'a> {
            identifier: ::std::borrow::Cow<'a, str>,
            content_size: u64,
        }
        impl<'a> Open<'a> {
            pub fn new<I>(identifier: I, content_size: u64) -> Self
                where I: Into<::std::borrow::Cow<'a, str>>
            {
                Open {
                    identifier: identifier.into(),
                    content_size: content_size,
                }
            }
            pub fn identifier(&self) -> &str {
                &*self.identifier
            }
            pub fn content_size(&self) -> u64 {
                self.content_size
            }
        }
        impl<'a> ::amqp0::Message for Open<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [9, self.identifier.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct OpenOk {
            staged_size: u64,
        }
        impl OpenOk {
            pub fn new(staged_size: u64) -> Self {
                OpenOk { staged_size: staged_size }
            }
            pub fn staged_size(&self) -> u64 {
                self.staged_size
            }
        }
        impl ::amqp0::Message for OpenOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                8
            }
        }

        // Class Modules
        pub struct Stage;
        impl Stage {
            pub fn new() -> Self {
                Stage
            }
        }
        impl ::amqp0::Message for Stage {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Publish<'a> {
            ticket: u16,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
            mandatory: bool,
            immediate: bool,
            identifier: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Publish<'a> {
            pub fn new<E, I, R>(ticket: u16,
                                exchange: E,
                                routing_key: R,
                                mandatory: bool,
                                immediate: bool,
                                identifier: I)
                                -> Self
                where E: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, str>>,
                      I: Into<::std::borrow::Cow<'a, str>>
            {
                Publish {
                    ticket: ticket,
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                    mandatory: mandatory,
                    immediate: immediate,
                    identifier: identifier.into(),
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
            pub fn mandatory(&self) -> bool {
                self.mandatory
            }
            pub fn immediate(&self) -> bool {
                self.immediate
            }
            pub fn identifier(&self) -> &str {
                &*self.identifier
            }
        }
        impl<'a> ::amqp0::Message for Publish<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [6, self.exchange.len(), self.routing_key.len(), self.identifier.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Return<'a> {
            reply_code: u16,
            reply_text: ::std::borrow::Cow<'a, str>,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Return<'a> {
            pub fn new<E, R, R0>(reply_code: u16,
                                 reply_text: R,
                                 exchange: E,
                                 routing_key: R0)
                                 -> Self
                where R: Into<::std::borrow::Cow<'a, str>>,
                      E: Into<::std::borrow::Cow<'a, str>>,
                      R0: Into<::std::borrow::Cow<'a, str>>
            {
                Return {
                    reply_code: reply_code,
                    reply_text: reply_text.into(),
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                }
            }
            pub fn reply_code(&self) -> u16 {
                self.reply_code
            }
            pub fn reply_text(&self) -> &str {
                &*self.reply_text
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
        }
        impl<'a> ::amqp0::Message for Return<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [5, self.reply_text.len(), self.exchange.len(), self.routing_key.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Deliver<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
            delivery_tag: u64,
            redelivered: bool,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
            identifier: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Deliver<'a> {
            pub fn new<C, E, I, R>(consumer_tag: C,
                                   delivery_tag: u64,
                                   redelivered: bool,
                                   exchange: E,
                                   routing_key: R,
                                   identifier: I)
                                   -> Self
                where C: Into<::std::borrow::Cow<'a, str>>,
                      E: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, str>>,
                      I: Into<::std::borrow::Cow<'a, str>>
            {
                Deliver {
                    consumer_tag: consumer_tag.into(),
                    delivery_tag: delivery_tag,
                    redelivered: redelivered,
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                    identifier: identifier.into(),
                }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
            pub fn delivery_tag(&self) -> u64 {
                self.delivery_tag
            }
            pub fn redelivered(&self) -> bool {
                self.redelivered
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
            pub fn identifier(&self) -> &str {
                &*self.identifier
            }
        }
        impl<'a> ::amqp0::Message for Deliver<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [13,
                 self.consumer_tag.len(),
                 self.exchange.len(),
                 self.routing_key.len(),
                 self.identifier.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Ack {
            delivery_tag: u64,
            multiple: bool,
        }
        impl Ack {
            pub fn new(delivery_tag: u64, multiple: bool) -> Self {
                Ack {
                    delivery_tag: delivery_tag,
                    multiple: multiple,
                }
            }
            pub fn delivery_tag(&self) -> u64 {
                self.delivery_tag
            }
            pub fn multiple(&self) -> bool {
                self.multiple
            }
        }
        impl ::amqp0::Message for Ack {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                9
            }
        }

        // Class Modules
        pub struct Reject {
            delivery_tag: u64,
            requeue: bool,
        }
        impl Reject {
            pub fn new(delivery_tag: u64, requeue: bool) -> Self {
                Reject {
                    delivery_tag: delivery_tag,
                    requeue: requeue,
                }
            }
            pub fn delivery_tag(&self) -> u64 {
                self.delivery_tag
            }
            pub fn requeue(&self) -> bool {
                self.requeue
            }
        }
        impl ::amqp0::Message for Reject {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                9
            }
        }
    }
    pub mod message {

        // Class Modules
        pub struct Transfer<'a> {
            ticket: u16,
            destination: ::std::borrow::Cow<'a, str>,
            redelivered: bool,
            immediate: bool,
            ttl: u64,
            priority: u8,
            timestamp: u64,
            delivery_mode: u8,
            expiration: u64,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
            message_id: ::std::borrow::Cow<'a, str>,
            correlation_id: ::std::borrow::Cow<'a, str>,
            reply_to: ::std::borrow::Cow<'a, str>,
            content_type: ::std::borrow::Cow<'a, str>,
            content_encoding: ::std::borrow::Cow<'a, str>,
            user_id: ::std::borrow::Cow<'a, str>,
            app_id: ::std::borrow::Cow<'a, str>,
            transaction_id: ::std::borrow::Cow<'a, str>,
            security_token: ::std::borrow::Cow<'a, [u8]>,
            application_headers: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
            body: ::std::borrow::Cow<'a, [u8]>,
        }
        impl<'a> Transfer<'a> {
            pub fn new<A, A0, B, C1, C0, C, D, E, M, R0, R, S, T, U>(ticket: u16,
                                                                     destination: D,
                                                                     redelivered: bool,
                                                                     immediate: bool,
                                                                     ttl: u64,
                                                                     priority: u8,
                                                                     timestamp: u64,
                                                                     delivery_mode: u8,
                                                                     expiration: u64,
                                                                     exchange: E,
                                                                     routing_key: R,
                                                                     message_id: M,
                                                                     correlation_id: C,
                                                                     reply_to: R0,
                                                                     content_type: C0,
                                                                     content_encoding: C1,
                                                                     user_id: U,
                                                                     app_id: A,
                                                                     transaction_id: T,
                                                                     security_token: S,
                                                                     application_headers: A0,
                                                                     body: B)
                                                                     -> Self
                where D: Into<::std::borrow::Cow<'a, str>>,
                      E: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, str>>,
                      M: Into<::std::borrow::Cow<'a, str>>,
                      C: Into<::std::borrow::Cow<'a, str>>,
                      R0: Into<::std::borrow::Cow<'a, str>>,
                      C0: Into<::std::borrow::Cow<'a, str>>,
                      C1: Into<::std::borrow::Cow<'a, str>>,
                      U: Into<::std::borrow::Cow<'a, str>>,
                      A: Into<::std::borrow::Cow<'a, str>>,
                      T: Into<::std::borrow::Cow<'a, str>>,
                      S: Into<::std::borrow::Cow<'a, [u8]>>,
                      A0: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>,
                      B: Into<::std::borrow::Cow<'a, [u8]>>
            {
                Transfer {
                    ticket: ticket,
                    destination: destination.into(),
                    redelivered: redelivered,
                    immediate: immediate,
                    ttl: ttl,
                    priority: priority,
                    timestamp: timestamp,
                    delivery_mode: delivery_mode,
                    expiration: expiration,
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                    message_id: message_id.into(),
                    correlation_id: correlation_id.into(),
                    reply_to: reply_to.into(),
                    content_type: content_type.into(),
                    content_encoding: content_encoding.into(),
                    user_id: user_id.into(),
                    app_id: app_id.into(),
                    transaction_id: transaction_id.into(),
                    security_token: security_token.into(),
                    application_headers: application_headers.into(),
                    body: body.into(),
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn destination(&self) -> &str {
                &*self.destination
            }
            pub fn redelivered(&self) -> bool {
                self.redelivered
            }
            pub fn immediate(&self) -> bool {
                self.immediate
            }
            pub fn ttl(&self) -> u64 {
                self.ttl
            }
            pub fn priority(&self) -> u8 {
                self.priority
            }
            pub fn timestamp(&self) -> u64 {
                self.timestamp
            }
            pub fn delivery_mode(&self) -> u8 {
                self.delivery_mode
            }
            pub fn expiration(&self) -> u64 {
                self.expiration
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
            pub fn message_id(&self) -> &str {
                &*self.message_id
            }
            pub fn correlation_id(&self) -> &str {
                &*self.correlation_id
            }
            pub fn reply_to(&self) -> &str {
                &*self.reply_to
            }
            pub fn content_type(&self) -> &str {
                &*self.content_type
            }
            pub fn content_encoding(&self) -> &str {
                &*self.content_encoding
            }
            pub fn user_id(&self) -> &str {
                &*self.user_id
            }
            pub fn app_id(&self) -> &str {
                &*self.app_id
            }
            pub fn transaction_id(&self) -> &str {
                &*self.transaction_id
            }
            pub fn security_token(&self) -> &[u8] {
                &*self.security_token
            }
            pub fn application_headers(&self) -> &::amqp0::value::Table {
                &*self.application_headers
            }
            pub fn body(&self) -> &[u8] {
                &*self.body
            }
        }
        impl<'a> ::amqp0::Message for Transfer<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [43,
                 self.destination.len(),
                 self.exchange.len(),
                 self.routing_key.len(),
                 self.message_id.len(),
                 self.correlation_id.len(),
                 self.reply_to.len(),
                 self.content_type.len(),
                 self.content_encoding.len(),
                 self.user_id.len(),
                 self.app_id.len(),
                 self.transaction_id.len(),
                 self.security_token.len(),
                 self.application_headers.amqp_size(),
                 self.body.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Consume<'a> {
            ticket: u16,
            queue: ::std::borrow::Cow<'a, str>,
            destination: ::std::borrow::Cow<'a, str>,
            no_local: bool,
            no_ack: bool,
            exclusive: bool,
            filter: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
        }
        impl<'a> Consume<'a> {
            pub fn new<D, F, Q>(ticket: u16,
                                queue: Q,
                                destination: D,
                                no_local: bool,
                                no_ack: bool,
                                exclusive: bool,
                                filter: F)
                                -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>,
                      D: Into<::std::borrow::Cow<'a, str>>,
                      F: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>
            {
                Consume {
                    ticket: ticket,
                    queue: queue.into(),
                    destination: destination.into(),
                    no_local: no_local,
                    no_ack: no_ack,
                    exclusive: exclusive,
                    filter: filter.into(),
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn destination(&self) -> &str {
                &*self.destination
            }
            pub fn no_local(&self) -> bool {
                self.no_local
            }
            pub fn no_ack(&self) -> bool {
                self.no_ack
            }
            pub fn exclusive(&self) -> bool {
                self.exclusive
            }
            pub fn filter(&self) -> &::amqp0::value::Table {
                &*self.filter
            }
        }
        impl<'a> ::amqp0::Message for Consume<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [5, self.queue.len(), self.destination.len(), self.filter.amqp_size()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Cancel<'a> {
            destination: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Cancel<'a> {
            pub fn new<D>(destination: D) -> Self
                where D: Into<::std::borrow::Cow<'a, str>>
            {
                Cancel { destination: destination.into() }
            }
            pub fn destination(&self) -> &str {
                &*self.destination
            }
        }
        impl<'a> ::amqp0::Message for Cancel<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [1, self.destination.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Get<'a> {
            ticket: u16,
            queue: ::std::borrow::Cow<'a, str>,
            destination: ::std::borrow::Cow<'a, str>,
            no_ack: bool,
        }
        impl<'a> Get<'a> {
            pub fn new<D, Q>(ticket: u16, queue: Q, destination: D, no_ack: bool) -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>,
                      D: Into<::std::borrow::Cow<'a, str>>
            {
                Get {
                    ticket: ticket,
                    queue: queue.into(),
                    destination: destination.into(),
                    no_ack: no_ack,
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn destination(&self) -> &str {
                &*self.destination
            }
            pub fn no_ack(&self) -> bool {
                self.no_ack
            }
        }
        impl<'a> ::amqp0::Message for Get<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [5, self.queue.len(), self.destination.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Recover {
            requeue: bool,
        }
        impl Recover {
            pub fn new(requeue: bool) -> Self {
                Recover { requeue: requeue }
            }
            pub fn requeue(&self) -> bool {
                self.requeue
            }
        }
        impl ::amqp0::Message for Recover {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                1
            }
        }

        // Class Modules
        pub struct Open<'a> {
            reference: ::std::borrow::Cow<'a, [u8]>,
        }
        impl<'a> Open<'a> {
            pub fn new<R>(reference: R) -> Self
                where R: Into<::std::borrow::Cow<'a, [u8]>>
            {
                Open { reference: reference.into() }
            }
            pub fn reference(&self) -> &[u8] {
                &*self.reference
            }
        }
        impl<'a> ::amqp0::Message for Open<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.reference.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Close<'a> {
            reference: ::std::borrow::Cow<'a, [u8]>,
        }
        impl<'a> Close<'a> {
            pub fn new<R>(reference: R) -> Self
                where R: Into<::std::borrow::Cow<'a, [u8]>>
            {
                Close { reference: reference.into() }
            }
            pub fn reference(&self) -> &[u8] {
                &*self.reference
            }
        }
        impl<'a> ::amqp0::Message for Close<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.reference.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Append<'a> {
            reference: ::std::borrow::Cow<'a, [u8]>,
            bytes: ::std::borrow::Cow<'a, [u8]>,
        }
        impl<'a> Append<'a> {
            pub fn new<B, R>(reference: R, bytes: B) -> Self
                where R: Into<::std::borrow::Cow<'a, [u8]>>,
                      B: Into<::std::borrow::Cow<'a, [u8]>>
            {
                Append {
                    reference: reference.into(),
                    bytes: bytes.into(),
                }
            }
            pub fn reference(&self) -> &[u8] {
                &*self.reference
            }
            pub fn bytes(&self) -> &[u8] {
                &*self.bytes
            }
        }
        impl<'a> ::amqp0::Message for Append<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [4, self.reference.len(), self.bytes.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Checkpoint<'a> {
            reference: ::std::borrow::Cow<'a, [u8]>,
            identifier: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Checkpoint<'a> {
            pub fn new<I, R>(reference: R, identifier: I) -> Self
                where R: Into<::std::borrow::Cow<'a, [u8]>>,
                      I: Into<::std::borrow::Cow<'a, str>>
            {
                Checkpoint {
                    reference: reference.into(),
                    identifier: identifier.into(),
                }
            }
            pub fn reference(&self) -> &[u8] {
                &*self.reference
            }
            pub fn identifier(&self) -> &str {
                &*self.identifier
            }
        }
        impl<'a> ::amqp0::Message for Checkpoint<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [3, self.reference.len(), self.identifier.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Resume<'a> {
            reference: ::std::borrow::Cow<'a, [u8]>,
            identifier: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Resume<'a> {
            pub fn new<I, R>(reference: R, identifier: I) -> Self
                where R: Into<::std::borrow::Cow<'a, [u8]>>,
                      I: Into<::std::borrow::Cow<'a, str>>
            {
                Resume {
                    reference: reference.into(),
                    identifier: identifier.into(),
                }
            }
            pub fn reference(&self) -> &[u8] {
                &*self.reference
            }
            pub fn identifier(&self) -> &str {
                &*self.identifier
            }
        }
        impl<'a> ::amqp0::Message for Resume<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [3, self.reference.len(), self.identifier.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Qos {
            prefetch_size: u32,
            prefetch_count: u16,
            global: bool,
        }
        impl Qos {
            pub fn new(prefetch_size: u32, prefetch_count: u16, global: bool) -> Self {
                Qos {
                    prefetch_size: prefetch_size,
                    prefetch_count: prefetch_count,
                    global: global,
                }
            }
            pub fn prefetch_size(&self) -> u32 {
                self.prefetch_size
            }
            pub fn prefetch_count(&self) -> u16 {
                self.prefetch_count
            }
            pub fn global(&self) -> bool {
                self.global
            }
        }
        impl ::amqp0::Message for Qos {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                7
            }
        }

        // Class Modules
        pub struct Ok;
        impl Ok {
            pub fn new() -> Self {
                Ok
            }
        }
        impl ::amqp0::Message for Ok {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Empty;
        impl Empty {
            pub fn new() -> Self {
                Empty
            }
        }
        impl ::amqp0::Message for Empty {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Reject<'a> {
            code: u16,
            text: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Reject<'a> {
            pub fn new<T>(code: u16, text: T) -> Self
                where T: Into<::std::borrow::Cow<'a, str>>
            {
                Reject {
                    code: code,
                    text: text.into(),
                }
            }
            pub fn code(&self) -> u16 {
                self.code
            }
            pub fn text(&self) -> &str {
                &*self.text
            }
        }
        impl<'a> ::amqp0::Message for Reject<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [3, self.text.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Offset {
            value: u64,
        }
        impl Offset {
            pub fn new(value: u64) -> Self {
                Offset { value: value }
            }
            pub fn value(&self) -> u64 {
                self.value
            }
        }
        impl ::amqp0::Message for Offset {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                8
            }
        }
    }
    pub mod queue {

        // Class Modules
        pub struct Declare<'a> {
            ticket: u16,
            queue: ::std::borrow::Cow<'a, str>,
            passive: bool,
            durable: bool,
            exclusive: bool,
            auto_delete: bool,
            nowait: bool,
            arguments: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
        }
        impl<'a> Declare<'a> {
            pub fn new<A, Q>(ticket: u16,
                             queue: Q,
                             passive: bool,
                             durable: bool,
                             exclusive: bool,
                             auto_delete: bool,
                             nowait: bool,
                             arguments: A)
                             -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>,
                      A: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>
            {
                Declare {
                    ticket: ticket,
                    queue: queue.into(),
                    passive: passive,
                    durable: durable,
                    exclusive: exclusive,
                    auto_delete: auto_delete,
                    nowait: nowait,
                    arguments: arguments.into(),
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn passive(&self) -> bool {
                self.passive
            }
            pub fn durable(&self) -> bool {
                self.durable
            }
            pub fn exclusive(&self) -> bool {
                self.exclusive
            }
            pub fn auto_delete(&self) -> bool {
                self.auto_delete
            }
            pub fn nowait(&self) -> bool {
                self.nowait
            }
            pub fn arguments(&self) -> &::amqp0::value::Table {
                &*self.arguments
            }
        }
        impl<'a> ::amqp0::Message for Declare<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [4, self.queue.len(), self.arguments.amqp_size()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct DeclareOk<'a> {
            queue: ::std::borrow::Cow<'a, str>,
            message_count: u32,
            consumer_count: u32,
        }
        impl<'a> DeclareOk<'a> {
            pub fn new<Q>(queue: Q, message_count: u32, consumer_count: u32) -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>
            {
                DeclareOk {
                    queue: queue.into(),
                    message_count: message_count,
                    consumer_count: consumer_count,
                }
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn message_count(&self) -> u32 {
                self.message_count
            }
            pub fn consumer_count(&self) -> u32 {
                self.consumer_count
            }
        }
        impl<'a> ::amqp0::Message for DeclareOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [9, self.queue.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Bind<'a> {
            ticket: u16,
            queue: ::std::borrow::Cow<'a, str>,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
            nowait: bool,
            arguments: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
        }
        impl<'a> Bind<'a> {
            pub fn new<A, E, Q, R>(ticket: u16,
                                   queue: Q,
                                   exchange: E,
                                   routing_key: R,
                                   nowait: bool,
                                   arguments: A)
                                   -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>,
                      E: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, str>>,
                      A: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>
            {
                Bind {
                    ticket: ticket,
                    queue: queue.into(),
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                    nowait: nowait,
                    arguments: arguments.into(),
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
            pub fn nowait(&self) -> bool {
                self.nowait
            }
            pub fn arguments(&self) -> &::amqp0::value::Table {
                &*self.arguments
            }
        }
        impl<'a> ::amqp0::Message for Bind<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [6,
                 self.queue.len(),
                 self.exchange.len(),
                 self.routing_key.len(),
                 self.arguments.amqp_size()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct BindOk;
        impl BindOk {
            pub fn new() -> Self {
                BindOk
            }
        }
        impl ::amqp0::Message for BindOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Unbind<'a> {
            ticket: u16,
            queue: ::std::borrow::Cow<'a, str>,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
            arguments: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
        }
        impl<'a> Unbind<'a> {
            pub fn new<A, E, Q, R>(ticket: u16,
                                   queue: Q,
                                   exchange: E,
                                   routing_key: R,
                                   arguments: A)
                                   -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>,
                      E: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, str>>,
                      A: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>
            {
                Unbind {
                    ticket: ticket,
                    queue: queue.into(),
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                    arguments: arguments.into(),
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
            pub fn arguments(&self) -> &::amqp0::value::Table {
                &*self.arguments
            }
        }
        impl<'a> ::amqp0::Message for Unbind<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [5,
                 self.queue.len(),
                 self.exchange.len(),
                 self.routing_key.len(),
                 self.arguments.amqp_size()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct UnbindOk;
        impl UnbindOk {
            pub fn new() -> Self {
                UnbindOk
            }
        }
        impl ::amqp0::Message for UnbindOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Purge<'a> {
            ticket: u16,
            queue: ::std::borrow::Cow<'a, str>,
            nowait: bool,
        }
        impl<'a> Purge<'a> {
            pub fn new<Q>(ticket: u16, queue: Q, nowait: bool) -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>
            {
                Purge {
                    ticket: ticket,
                    queue: queue.into(),
                    nowait: nowait,
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn nowait(&self) -> bool {
                self.nowait
            }
        }
        impl<'a> ::amqp0::Message for Purge<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [4, self.queue.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct PurgeOk {
            message_count: u32,
        }
        impl PurgeOk {
            pub fn new(message_count: u32) -> Self {
                PurgeOk { message_count: message_count }
            }
            pub fn message_count(&self) -> u32 {
                self.message_count
            }
        }
        impl ::amqp0::Message for PurgeOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                4
            }
        }

        // Class Modules
        pub struct Delete<'a> {
            ticket: u16,
            queue: ::std::borrow::Cow<'a, str>,
            if_unused: bool,
            if_empty: bool,
            nowait: bool,
        }
        impl<'a> Delete<'a> {
            pub fn new<Q>(ticket: u16,
                          queue: Q,
                          if_unused: bool,
                          if_empty: bool,
                          nowait: bool)
                          -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>
            {
                Delete {
                    ticket: ticket,
                    queue: queue.into(),
                    if_unused: if_unused,
                    if_empty: if_empty,
                    nowait: nowait,
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn if_unused(&self) -> bool {
                self.if_unused
            }
            pub fn if_empty(&self) -> bool {
                self.if_empty
            }
            pub fn nowait(&self) -> bool {
                self.nowait
            }
        }
        impl<'a> ::amqp0::Message for Delete<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [4, self.queue.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct DeleteOk {
            message_count: u32,
        }
        impl DeleteOk {
            pub fn new(message_count: u32) -> Self {
                DeleteOk { message_count: message_count }
            }
            pub fn message_count(&self) -> u32 {
                self.message_count
            }
        }
        impl ::amqp0::Message for DeleteOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                4
            }
        }
    }
    pub mod stream {

        // Class Modules
        pub struct Qos {
            prefetch_size: u32,
            prefetch_count: u16,
            consume_rate: u32,
            global: bool,
        }
        impl Qos {
            pub fn new(prefetch_size: u32,
                       prefetch_count: u16,
                       consume_rate: u32,
                       global: bool)
                       -> Self {
                Qos {
                    prefetch_size: prefetch_size,
                    prefetch_count: prefetch_count,
                    consume_rate: consume_rate,
                    global: global,
                }
            }
            pub fn prefetch_size(&self) -> u32 {
                self.prefetch_size
            }
            pub fn prefetch_count(&self) -> u16 {
                self.prefetch_count
            }
            pub fn consume_rate(&self) -> u32 {
                self.consume_rate
            }
            pub fn global(&self) -> bool {
                self.global
            }
        }
        impl ::amqp0::Message for Qos {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                11
            }
        }

        // Class Modules
        pub struct QosOk;
        impl QosOk {
            pub fn new() -> Self {
                QosOk
            }
        }
        impl ::amqp0::Message for QosOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Consume<'a> {
            ticket: u16,
            queue: ::std::borrow::Cow<'a, str>,
            consumer_tag: ::std::borrow::Cow<'a, str>,
            no_local: bool,
            exclusive: bool,
            nowait: bool,
            filter: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
        }
        impl<'a> Consume<'a> {
            pub fn new<C, F, Q>(ticket: u16,
                                queue: Q,
                                consumer_tag: C,
                                no_local: bool,
                                exclusive: bool,
                                nowait: bool,
                                filter: F)
                                -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>,
                      C: Into<::std::borrow::Cow<'a, str>>,
                      F: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>
            {
                Consume {
                    ticket: ticket,
                    queue: queue.into(),
                    consumer_tag: consumer_tag.into(),
                    no_local: no_local,
                    exclusive: exclusive,
                    nowait: nowait,
                    filter: filter.into(),
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
            pub fn no_local(&self) -> bool {
                self.no_local
            }
            pub fn exclusive(&self) -> bool {
                self.exclusive
            }
            pub fn nowait(&self) -> bool {
                self.nowait
            }
            pub fn filter(&self) -> &::amqp0::value::Table {
                &*self.filter
            }
        }
        impl<'a> ::amqp0::Message for Consume<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [5, self.queue.len(), self.consumer_tag.len(), self.filter.amqp_size()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct ConsumeOk<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> ConsumeOk<'a> {
            pub fn new<C>(consumer_tag: C) -> Self
                where C: Into<::std::borrow::Cow<'a, str>>
            {
                ConsumeOk { consumer_tag: consumer_tag.into() }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
        }
        impl<'a> ::amqp0::Message for ConsumeOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [1, self.consumer_tag.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Cancel<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
            nowait: bool,
        }
        impl<'a> Cancel<'a> {
            pub fn new<C>(consumer_tag: C, nowait: bool) -> Self
                where C: Into<::std::borrow::Cow<'a, str>>
            {
                Cancel {
                    consumer_tag: consumer_tag.into(),
                    nowait: nowait,
                }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
            pub fn nowait(&self) -> bool {
                self.nowait
            }
        }
        impl<'a> ::amqp0::Message for Cancel<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.consumer_tag.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct CancelOk<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> CancelOk<'a> {
            pub fn new<C>(consumer_tag: C) -> Self
                where C: Into<::std::borrow::Cow<'a, str>>
            {
                CancelOk { consumer_tag: consumer_tag.into() }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
        }
        impl<'a> ::amqp0::Message for CancelOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [1, self.consumer_tag.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Publish<'a> {
            ticket: u16,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
            mandatory: bool,
            immediate: bool,
        }
        impl<'a> Publish<'a> {
            pub fn new<E, R>(ticket: u16,
                             exchange: E,
                             routing_key: R,
                             mandatory: bool,
                             immediate: bool)
                             -> Self
                where E: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, str>>
            {
                Publish {
                    ticket: ticket,
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                    mandatory: mandatory,
                    immediate: immediate,
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
            pub fn mandatory(&self) -> bool {
                self.mandatory
            }
            pub fn immediate(&self) -> bool {
                self.immediate
            }
        }
        impl<'a> ::amqp0::Message for Publish<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [5, self.exchange.len(), self.routing_key.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Return<'a> {
            reply_code: u16,
            reply_text: ::std::borrow::Cow<'a, str>,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Return<'a> {
            pub fn new<E, R, R0>(reply_code: u16,
                                 reply_text: R,
                                 exchange: E,
                                 routing_key: R0)
                                 -> Self
                where R: Into<::std::borrow::Cow<'a, str>>,
                      E: Into<::std::borrow::Cow<'a, str>>,
                      R0: Into<::std::borrow::Cow<'a, str>>
            {
                Return {
                    reply_code: reply_code,
                    reply_text: reply_text.into(),
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                }
            }
            pub fn reply_code(&self) -> u16 {
                self.reply_code
            }
            pub fn reply_text(&self) -> &str {
                &*self.reply_text
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
        }
        impl<'a> ::amqp0::Message for Return<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [5, self.reply_text.len(), self.exchange.len(), self.routing_key.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Deliver<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
            delivery_tag: u64,
            exchange: ::std::borrow::Cow<'a, str>,
            queue: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Deliver<'a> {
            pub fn new<C, E, Q>(consumer_tag: C, delivery_tag: u64, exchange: E, queue: Q) -> Self
                where C: Into<::std::borrow::Cow<'a, str>>,
                      E: Into<::std::borrow::Cow<'a, str>>,
                      Q: Into<::std::borrow::Cow<'a, str>>
            {
                Deliver {
                    consumer_tag: consumer_tag.into(),
                    delivery_tag: delivery_tag,
                    exchange: exchange.into(),
                    queue: queue.into(),
                }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
            pub fn delivery_tag(&self) -> u64 {
                self.delivery_tag
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
        }
        impl<'a> ::amqp0::Message for Deliver<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [11, self.consumer_tag.len(), self.exchange.len(), self.queue.len()]
                    .iter()
                    .sum()
            }
        }
    }
    pub mod tunnel {

        // Class Modules
        pub struct Request<'a> {
            meta_data: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
        }
        impl<'a> Request<'a> {
            pub fn new<M>(meta_data: M) -> Self
                where M: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>
            {
                Request { meta_data: meta_data.into() }
            }
            pub fn meta_data(&self) -> &::amqp0::value::Table {
                &*self.meta_data
            }
        }
        impl<'a> ::amqp0::Message for Request<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [0, self.meta_data.amqp_size()]
                    .iter()
                    .sum()
            }
        }
    }
    pub mod tx {

        // Class Modules
        pub struct Select;
        impl Select {
            pub fn new() -> Self {
                Select
            }
        }
        impl ::amqp0::Message for Select {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct SelectOk;
        impl SelectOk {
            pub fn new() -> Self {
                SelectOk
            }
        }
        impl ::amqp0::Message for SelectOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Commit;
        impl Commit {
            pub fn new() -> Self {
                Commit
            }
        }
        impl ::amqp0::Message for Commit {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct CommitOk;
        impl CommitOk {
            pub fn new() -> Self {
                CommitOk
            }
        }
        impl ::amqp0::Message for CommitOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Rollback;
        impl Rollback {
            pub fn new() -> Self {
                Rollback
            }
        }
        impl ::amqp0::Message for Rollback {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct RollbackOk;
        impl RollbackOk {
            pub fn new() -> Self {
                RollbackOk
            }
        }
        impl ::amqp0::Message for RollbackOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }
    }
}

#[allow(non_camel_case_types)]
pub struct Amqp9_0;
impl Spec for Amqp9_0 {}

pub mod amqp8_0 {
    // Class Constants
    pub const CLASS_ACCESS: u16 = 30;
    pub const CLASS_BASIC: u16 = 60;
    pub const CLASS_CHANNEL: u16 = 20;
    pub const CLASS_CONNECTION: u16 = 10;
    pub const CLASS_DTX: u16 = 100;
    pub const CLASS_EXCHANGE: u16 = 40;
    pub const CLASS_FILE: u16 = 70;
    pub const CLASS_QUEUE: u16 = 50;
    pub const CLASS_STREAM: u16 = 80;
    pub const CLASS_TEST: u16 = 120;
    pub const CLASS_TUNNEL: u16 = 110;
    pub const CLASS_TX: u16 = 90;

    // Class Methods
    pub const METHOD_ACCESS_REQUEST: u16 = 10;
    pub const METHOD_ACCESS_REQUEST_OK: u16 = 11;

    pub const METHOD_BASIC_QOS: u16 = 10;
    pub const METHOD_BASIC_QOS_OK: u16 = 11;
    pub const METHOD_BASIC_CONSUME: u16 = 20;
    pub const METHOD_BASIC_CONSUME_OK: u16 = 21;
    pub const METHOD_BASIC_CANCEL: u16 = 30;
    pub const METHOD_BASIC_CANCEL_OK: u16 = 31;
    pub const METHOD_BASIC_PUBLISH: u16 = 40;
    pub const METHOD_BASIC_RETURN: u16 = 50;
    pub const METHOD_BASIC_DELIVER: u16 = 60;
    pub const METHOD_BASIC_GET: u16 = 70;
    pub const METHOD_BASIC_GET_OK: u16 = 71;
    pub const METHOD_BASIC_GET_EMPTY: u16 = 72;
    pub const METHOD_BASIC_ACK: u16 = 80;
    pub const METHOD_BASIC_REJECT: u16 = 90;
    pub const METHOD_BASIC_RECOVER: u16 = 100;

    pub const METHOD_CHANNEL_OPEN: u16 = 10;
    pub const METHOD_CHANNEL_OPEN_OK: u16 = 11;
    pub const METHOD_CHANNEL_FLOW: u16 = 20;
    pub const METHOD_CHANNEL_FLOW_OK: u16 = 21;
    pub const METHOD_CHANNEL_ALERT: u16 = 30;
    pub const METHOD_CHANNEL_CLOSE: u16 = 40;
    pub const METHOD_CHANNEL_CLOSE_OK: u16 = 41;

    pub const METHOD_CONNECTION_START: u16 = 10;
    pub const METHOD_CONNECTION_START_OK: u16 = 11;
    pub const METHOD_CONNECTION_SECURE: u16 = 20;
    pub const METHOD_CONNECTION_SECURE_OK: u16 = 21;
    pub const METHOD_CONNECTION_TUNE: u16 = 30;
    pub const METHOD_CONNECTION_TUNE_OK: u16 = 31;
    pub const METHOD_CONNECTION_OPEN: u16 = 40;
    pub const METHOD_CONNECTION_OPEN_OK: u16 = 41;
    pub const METHOD_CONNECTION_REDIRECT: u16 = 50;
    pub const METHOD_CONNECTION_CLOSE: u16 = 60;
    pub const METHOD_CONNECTION_CLOSE_OK: u16 = 61;

    pub const METHOD_DTX_SELECT: u16 = 10;
    pub const METHOD_DTX_SELECT_OK: u16 = 11;
    pub const METHOD_DTX_START: u16 = 20;
    pub const METHOD_DTX_START_OK: u16 = 21;

    pub const METHOD_EXCHANGE_DECLARE: u16 = 10;
    pub const METHOD_EXCHANGE_DECLARE_OK: u16 = 11;
    pub const METHOD_EXCHANGE_DELETE: u16 = 20;
    pub const METHOD_EXCHANGE_DELETE_OK: u16 = 21;

    pub const METHOD_FILE_QOS: u16 = 10;
    pub const METHOD_FILE_QOS_OK: u16 = 11;
    pub const METHOD_FILE_CONSUME: u16 = 20;
    pub const METHOD_FILE_CONSUME_OK: u16 = 21;
    pub const METHOD_FILE_CANCEL: u16 = 30;
    pub const METHOD_FILE_CANCEL_OK: u16 = 31;
    pub const METHOD_FILE_OPEN: u16 = 40;
    pub const METHOD_FILE_OPEN_OK: u16 = 41;
    pub const METHOD_FILE_STAGE: u16 = 50;
    pub const METHOD_FILE_PUBLISH: u16 = 60;
    pub const METHOD_FILE_RETURN: u16 = 70;
    pub const METHOD_FILE_DELIVER: u16 = 80;
    pub const METHOD_FILE_ACK: u16 = 90;
    pub const METHOD_FILE_REJECT: u16 = 100;

    pub const METHOD_QUEUE_DECLARE: u16 = 10;
    pub const METHOD_QUEUE_DECLARE_OK: u16 = 11;
    pub const METHOD_QUEUE_BIND: u16 = 20;
    pub const METHOD_QUEUE_BIND_OK: u16 = 21;
    pub const METHOD_QUEUE_PURGE: u16 = 30;
    pub const METHOD_QUEUE_PURGE_OK: u16 = 31;
    pub const METHOD_QUEUE_DELETE: u16 = 40;
    pub const METHOD_QUEUE_DELETE_OK: u16 = 41;

    pub const METHOD_STREAM_QOS: u16 = 10;
    pub const METHOD_STREAM_QOS_OK: u16 = 11;
    pub const METHOD_STREAM_CONSUME: u16 = 20;
    pub const METHOD_STREAM_CONSUME_OK: u16 = 21;
    pub const METHOD_STREAM_CANCEL: u16 = 30;
    pub const METHOD_STREAM_CANCEL_OK: u16 = 31;
    pub const METHOD_STREAM_PUBLISH: u16 = 40;
    pub const METHOD_STREAM_RETURN: u16 = 50;
    pub const METHOD_STREAM_DELIVER: u16 = 60;

    pub const METHOD_TEST_INTEGER: u16 = 10;
    pub const METHOD_TEST_INTEGER_OK: u16 = 11;
    pub const METHOD_TEST_STRING: u16 = 20;
    pub const METHOD_TEST_STRING_OK: u16 = 21;
    pub const METHOD_TEST_TABLE: u16 = 30;
    pub const METHOD_TEST_TABLE_OK: u16 = 31;
    pub const METHOD_TEST_CONTENT: u16 = 40;
    pub const METHOD_TEST_CONTENT_OK: u16 = 41;

    pub const METHOD_TUNNEL_REQUEST: u16 = 10;

    pub const METHOD_TX_SELECT: u16 = 10;
    pub const METHOD_TX_SELECT_OK: u16 = 11;
    pub const METHOD_TX_COMMIT: u16 = 20;
    pub const METHOD_TX_COMMIT_OK: u16 = 21;
    pub const METHOD_TX_ROLLBACK: u16 = 30;
    pub const METHOD_TX_ROLLBACK_OK: u16 = 31;
    pub mod access {

        // Class Modules
        pub struct Request<'a> {
            realm: ::std::borrow::Cow<'a, str>,
            exclusive: bool,
            passive: bool,
            active: bool,
            write: bool,
            read: bool,
        }
        impl<'a> Request<'a> {
            pub fn new<R>(realm: R,
                          exclusive: bool,
                          passive: bool,
                          active: bool,
                          write: bool,
                          read: bool)
                          -> Self
                where R: Into<::std::borrow::Cow<'a, str>>
            {
                Request {
                    realm: realm.into(),
                    exclusive: exclusive,
                    passive: passive,
                    active: active,
                    write: write,
                    read: read,
                }
            }
            pub fn realm(&self) -> &str {
                &*self.realm
            }
            pub fn exclusive(&self) -> bool {
                self.exclusive
            }
            pub fn passive(&self) -> bool {
                self.passive
            }
            pub fn active(&self) -> bool {
                self.active
            }
            pub fn write(&self) -> bool {
                self.write
            }
            pub fn read(&self) -> bool {
                self.read
            }
        }
        impl<'a> ::amqp0::Message for Request<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.realm.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct RequestOk {
            ticket: u16,
        }
        impl RequestOk {
            pub fn new(ticket: u16) -> Self {
                RequestOk { ticket: ticket }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
        }
        impl ::amqp0::Message for RequestOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                2
            }
        }
    }
    pub mod basic {

        // Class Modules
        pub struct Qos {
            prefetch_size: u32,
            prefetch_count: u16,
            global: bool,
        }
        impl Qos {
            pub fn new(prefetch_size: u32, prefetch_count: u16, global: bool) -> Self {
                Qos {
                    prefetch_size: prefetch_size,
                    prefetch_count: prefetch_count,
                    global: global,
                }
            }
            pub fn prefetch_size(&self) -> u32 {
                self.prefetch_size
            }
            pub fn prefetch_count(&self) -> u16 {
                self.prefetch_count
            }
            pub fn global(&self) -> bool {
                self.global
            }
        }
        impl ::amqp0::Message for Qos {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                7
            }
        }

        // Class Modules
        pub struct QosOk;
        impl QosOk {
            pub fn new() -> Self {
                QosOk
            }
        }
        impl ::amqp0::Message for QosOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Consume<'a> {
            ticket: u16,
            queue: ::std::borrow::Cow<'a, str>,
            consumer_tag: ::std::borrow::Cow<'a, str>,
            no_local: bool,
            no_ack: bool,
            exclusive: bool,
            nowait: bool,
        }
        impl<'a> Consume<'a> {
            pub fn new<C, Q>(ticket: u16,
                             queue: Q,
                             consumer_tag: C,
                             no_local: bool,
                             no_ack: bool,
                             exclusive: bool,
                             nowait: bool)
                             -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>,
                      C: Into<::std::borrow::Cow<'a, str>>
            {
                Consume {
                    ticket: ticket,
                    queue: queue.into(),
                    consumer_tag: consumer_tag.into(),
                    no_local: no_local,
                    no_ack: no_ack,
                    exclusive: exclusive,
                    nowait: nowait,
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
            pub fn no_local(&self) -> bool {
                self.no_local
            }
            pub fn no_ack(&self) -> bool {
                self.no_ack
            }
            pub fn exclusive(&self) -> bool {
                self.exclusive
            }
            pub fn nowait(&self) -> bool {
                self.nowait
            }
        }
        impl<'a> ::amqp0::Message for Consume<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [5, self.queue.len(), self.consumer_tag.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct ConsumeOk<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> ConsumeOk<'a> {
            pub fn new<C>(consumer_tag: C) -> Self
                where C: Into<::std::borrow::Cow<'a, str>>
            {
                ConsumeOk { consumer_tag: consumer_tag.into() }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
        }
        impl<'a> ::amqp0::Message for ConsumeOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [1, self.consumer_tag.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Cancel<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
            nowait: bool,
        }
        impl<'a> Cancel<'a> {
            pub fn new<C>(consumer_tag: C, nowait: bool) -> Self
                where C: Into<::std::borrow::Cow<'a, str>>
            {
                Cancel {
                    consumer_tag: consumer_tag.into(),
                    nowait: nowait,
                }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
            pub fn nowait(&self) -> bool {
                self.nowait
            }
        }
        impl<'a> ::amqp0::Message for Cancel<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.consumer_tag.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct CancelOk<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> CancelOk<'a> {
            pub fn new<C>(consumer_tag: C) -> Self
                where C: Into<::std::borrow::Cow<'a, str>>
            {
                CancelOk { consumer_tag: consumer_tag.into() }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
        }
        impl<'a> ::amqp0::Message for CancelOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [1, self.consumer_tag.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Publish<'a> {
            ticket: u16,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
            mandatory: bool,
            immediate: bool,
        }
        impl<'a> Publish<'a> {
            pub fn new<E, R>(ticket: u16,
                             exchange: E,
                             routing_key: R,
                             mandatory: bool,
                             immediate: bool)
                             -> Self
                where E: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, str>>
            {
                Publish {
                    ticket: ticket,
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                    mandatory: mandatory,
                    immediate: immediate,
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
            pub fn mandatory(&self) -> bool {
                self.mandatory
            }
            pub fn immediate(&self) -> bool {
                self.immediate
            }
        }
        impl<'a> ::amqp0::Message for Publish<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [5, self.exchange.len(), self.routing_key.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Return<'a> {
            reply_code: u16,
            reply_text: ::std::borrow::Cow<'a, str>,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Return<'a> {
            pub fn new<E, R, R0>(reply_code: u16,
                                 reply_text: R,
                                 exchange: E,
                                 routing_key: R0)
                                 -> Self
                where R: Into<::std::borrow::Cow<'a, str>>,
                      E: Into<::std::borrow::Cow<'a, str>>,
                      R0: Into<::std::borrow::Cow<'a, str>>
            {
                Return {
                    reply_code: reply_code,
                    reply_text: reply_text.into(),
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                }
            }
            pub fn reply_code(&self) -> u16 {
                self.reply_code
            }
            pub fn reply_text(&self) -> &str {
                &*self.reply_text
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
        }
        impl<'a> ::amqp0::Message for Return<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [5, self.reply_text.len(), self.exchange.len(), self.routing_key.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Deliver<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
            delivery_tag: u64,
            redelivered: bool,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Deliver<'a> {
            pub fn new<C, E, R>(consumer_tag: C,
                                delivery_tag: u64,
                                redelivered: bool,
                                exchange: E,
                                routing_key: R)
                                -> Self
                where C: Into<::std::borrow::Cow<'a, str>>,
                      E: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, str>>
            {
                Deliver {
                    consumer_tag: consumer_tag.into(),
                    delivery_tag: delivery_tag,
                    redelivered: redelivered,
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
            pub fn delivery_tag(&self) -> u64 {
                self.delivery_tag
            }
            pub fn redelivered(&self) -> bool {
                self.redelivered
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
        }
        impl<'a> ::amqp0::Message for Deliver<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [12, self.consumer_tag.len(), self.exchange.len(), self.routing_key.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Get<'a> {
            ticket: u16,
            queue: ::std::borrow::Cow<'a, str>,
            no_ack: bool,
        }
        impl<'a> Get<'a> {
            pub fn new<Q>(ticket: u16, queue: Q, no_ack: bool) -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>
            {
                Get {
                    ticket: ticket,
                    queue: queue.into(),
                    no_ack: no_ack,
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn no_ack(&self) -> bool {
                self.no_ack
            }
        }
        impl<'a> ::amqp0::Message for Get<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [4, self.queue.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct GetOk<'a> {
            delivery_tag: u64,
            redelivered: bool,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
            message_count: u32,
        }
        impl<'a> GetOk<'a> {
            pub fn new<E, R>(delivery_tag: u64,
                             redelivered: bool,
                             exchange: E,
                             routing_key: R,
                             message_count: u32)
                             -> Self
                where E: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, str>>
            {
                GetOk {
                    delivery_tag: delivery_tag,
                    redelivered: redelivered,
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                    message_count: message_count,
                }
            }
            pub fn delivery_tag(&self) -> u64 {
                self.delivery_tag
            }
            pub fn redelivered(&self) -> bool {
                self.redelivered
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
            pub fn message_count(&self) -> u32 {
                self.message_count
            }
        }
        impl<'a> ::amqp0::Message for GetOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [15, self.exchange.len(), self.routing_key.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct GetEmpty<'a> {
            cluster_id: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> GetEmpty<'a> {
            pub fn new<C>(cluster_id: C) -> Self
                where C: Into<::std::borrow::Cow<'a, str>>
            {
                GetEmpty { cluster_id: cluster_id.into() }
            }
            pub fn cluster_id(&self) -> &str {
                &*self.cluster_id
            }
        }
        impl<'a> ::amqp0::Message for GetEmpty<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [1, self.cluster_id.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Ack {
            delivery_tag: u64,
            multiple: bool,
        }
        impl Ack {
            pub fn new(delivery_tag: u64, multiple: bool) -> Self {
                Ack {
                    delivery_tag: delivery_tag,
                    multiple: multiple,
                }
            }
            pub fn delivery_tag(&self) -> u64 {
                self.delivery_tag
            }
            pub fn multiple(&self) -> bool {
                self.multiple
            }
        }
        impl ::amqp0::Message for Ack {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                9
            }
        }

        // Class Modules
        pub struct Reject {
            delivery_tag: u64,
            requeue: bool,
        }
        impl Reject {
            pub fn new(delivery_tag: u64, requeue: bool) -> Self {
                Reject {
                    delivery_tag: delivery_tag,
                    requeue: requeue,
                }
            }
            pub fn delivery_tag(&self) -> u64 {
                self.delivery_tag
            }
            pub fn requeue(&self) -> bool {
                self.requeue
            }
        }
        impl ::amqp0::Message for Reject {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                9
            }
        }

        // Class Modules
        pub struct Recover {
            requeue: bool,
        }
        impl Recover {
            pub fn new(requeue: bool) -> Self {
                Recover { requeue: requeue }
            }
            pub fn requeue(&self) -> bool {
                self.requeue
            }
        }
        impl ::amqp0::Message for Recover {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                1
            }
        }
    }
    pub mod channel {

        // Class Modules
        pub struct Open<'a> {
            out_of_band: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Open<'a> {
            pub fn new<O>(out_of_band: O) -> Self
                where O: Into<::std::borrow::Cow<'a, str>>
            {
                Open { out_of_band: out_of_band.into() }
            }
            pub fn out_of_band(&self) -> &str {
                &*self.out_of_band
            }
        }
        impl<'a> ::amqp0::Message for Open<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [1, self.out_of_band.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct OpenOk;
        impl OpenOk {
            pub fn new() -> Self {
                OpenOk
            }
        }
        impl ::amqp0::Message for OpenOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Flow {
            active: bool,
        }
        impl Flow {
            pub fn new(active: bool) -> Self {
                Flow { active: active }
            }
            pub fn active(&self) -> bool {
                self.active
            }
        }
        impl ::amqp0::Message for Flow {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                1
            }
        }

        // Class Modules
        pub struct FlowOk {
            active: bool,
        }
        impl FlowOk {
            pub fn new(active: bool) -> Self {
                FlowOk { active: active }
            }
            pub fn active(&self) -> bool {
                self.active
            }
        }
        impl ::amqp0::Message for FlowOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                1
            }
        }

        // Class Modules
        pub struct Alert<'a> {
            reply_code: u16,
            reply_text: ::std::borrow::Cow<'a, str>,
            details: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
        }
        impl<'a> Alert<'a> {
            pub fn new<D, R>(reply_code: u16, reply_text: R, details: D) -> Self
                where R: Into<::std::borrow::Cow<'a, str>>,
                      D: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>
            {
                Alert {
                    reply_code: reply_code,
                    reply_text: reply_text.into(),
                    details: details.into(),
                }
            }
            pub fn reply_code(&self) -> u16 {
                self.reply_code
            }
            pub fn reply_text(&self) -> &str {
                &*self.reply_text
            }
            pub fn details(&self) -> &::amqp0::value::Table {
                &*self.details
            }
        }
        impl<'a> ::amqp0::Message for Alert<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [3, self.reply_text.len(), self.details.amqp_size()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Close<'a> {
            reply_code: u16,
            reply_text: ::std::borrow::Cow<'a, str>,
            class_id: u16,
            method_id: u16,
        }
        impl<'a> Close<'a> {
            pub fn new<R>(reply_code: u16, reply_text: R, class_id: u16, method_id: u16) -> Self
                where R: Into<::std::borrow::Cow<'a, str>>
            {
                Close {
                    reply_code: reply_code,
                    reply_text: reply_text.into(),
                    class_id: class_id,
                    method_id: method_id,
                }
            }
            pub fn reply_code(&self) -> u16 {
                self.reply_code
            }
            pub fn reply_text(&self) -> &str {
                &*self.reply_text
            }
            pub fn class_id(&self) -> u16 {
                self.class_id
            }
            pub fn method_id(&self) -> u16 {
                self.method_id
            }
        }
        impl<'a> ::amqp0::Message for Close<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [7, self.reply_text.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct CloseOk;
        impl CloseOk {
            pub fn new() -> Self {
                CloseOk
            }
        }
        impl ::amqp0::Message for CloseOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }
    }
    pub mod connection {

        // Class Modules
        pub struct Start<'a> {
            version_major: u8,
            version_minor: u8,
            server_properties: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
            mechanisms: ::std::borrow::Cow<'a, [u8]>,
            locales: ::std::borrow::Cow<'a, [u8]>,
        }
        impl<'a> Start<'a> {
            pub fn new<L, M, S>(version_major: u8,
                                version_minor: u8,
                                server_properties: S,
                                mechanisms: M,
                                locales: L)
                                -> Self
                where S: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>,
                      M: Into<::std::borrow::Cow<'a, [u8]>>,
                      L: Into<::std::borrow::Cow<'a, [u8]>>
            {
                Start {
                    version_major: version_major,
                    version_minor: version_minor,
                    server_properties: server_properties.into(),
                    mechanisms: mechanisms.into(),
                    locales: locales.into(),
                }
            }
            pub fn version_major(&self) -> u8 {
                self.version_major
            }
            pub fn version_minor(&self) -> u8 {
                self.version_minor
            }
            pub fn server_properties(&self) -> &::amqp0::value::Table {
                &*self.server_properties
            }
            pub fn mechanisms(&self) -> &[u8] {
                &*self.mechanisms
            }
            pub fn locales(&self) -> &[u8] {
                &*self.locales
            }
        }
        impl<'a> ::amqp0::Message for Start<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [6, self.server_properties.amqp_size(), self.mechanisms.len(), self.locales.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct StartOk<'a> {
            client_properties: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
            mechanism: ::std::borrow::Cow<'a, str>,
            response: ::std::borrow::Cow<'a, [u8]>,
            locale: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> StartOk<'a> {
            pub fn new<C, L, M, R>(client_properties: C,
                                   mechanism: M,
                                   response: R,
                                   locale: L)
                                   -> Self
                where C: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>,
                      M: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, [u8]>>,
                      L: Into<::std::borrow::Cow<'a, str>>
            {
                StartOk {
                    client_properties: client_properties.into(),
                    mechanism: mechanism.into(),
                    response: response.into(),
                    locale: locale.into(),
                }
            }
            pub fn client_properties(&self) -> &::amqp0::value::Table {
                &*self.client_properties
            }
            pub fn mechanism(&self) -> &str {
                &*self.mechanism
            }
            pub fn response(&self) -> &[u8] {
                &*self.response
            }
            pub fn locale(&self) -> &str {
                &*self.locale
            }
        }
        impl<'a> ::amqp0::Message for StartOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [4,
                 self.client_properties.amqp_size(),
                 self.mechanism.len(),
                 self.response.len(),
                 self.locale.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Secure<'a> {
            challenge: ::std::borrow::Cow<'a, [u8]>,
        }
        impl<'a> Secure<'a> {
            pub fn new<C>(challenge: C) -> Self
                where C: Into<::std::borrow::Cow<'a, [u8]>>
            {
                Secure { challenge: challenge.into() }
            }
            pub fn challenge(&self) -> &[u8] {
                &*self.challenge
            }
        }
        impl<'a> ::amqp0::Message for Secure<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.challenge.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct SecureOk<'a> {
            response: ::std::borrow::Cow<'a, [u8]>,
        }
        impl<'a> SecureOk<'a> {
            pub fn new<R>(response: R) -> Self
                where R: Into<::std::borrow::Cow<'a, [u8]>>
            {
                SecureOk { response: response.into() }
            }
            pub fn response(&self) -> &[u8] {
                &*self.response
            }
        }
        impl<'a> ::amqp0::Message for SecureOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.response.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Tune {
            channel_max: u16,
            frame_max: u32,
            heartbeat: u16,
        }
        impl Tune {
            pub fn new(channel_max: u16, frame_max: u32, heartbeat: u16) -> Self {
                Tune {
                    channel_max: channel_max,
                    frame_max: frame_max,
                    heartbeat: heartbeat,
                }
            }
            pub fn channel_max(&self) -> u16 {
                self.channel_max
            }
            pub fn frame_max(&self) -> u32 {
                self.frame_max
            }
            pub fn heartbeat(&self) -> u16 {
                self.heartbeat
            }
        }
        impl ::amqp0::Message for Tune {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                8
            }
        }

        // Class Modules
        pub struct TuneOk {
            channel_max: u16,
            frame_max: u32,
            heartbeat: u16,
        }
        impl TuneOk {
            pub fn new(channel_max: u16, frame_max: u32, heartbeat: u16) -> Self {
                TuneOk {
                    channel_max: channel_max,
                    frame_max: frame_max,
                    heartbeat: heartbeat,
                }
            }
            pub fn channel_max(&self) -> u16 {
                self.channel_max
            }
            pub fn frame_max(&self) -> u32 {
                self.frame_max
            }
            pub fn heartbeat(&self) -> u16 {
                self.heartbeat
            }
        }
        impl ::amqp0::Message for TuneOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                8
            }
        }

        // Class Modules
        pub struct Open<'a> {
            virtual_host: ::std::borrow::Cow<'a, str>,
            capabilities: ::std::borrow::Cow<'a, str>,
            insist: bool,
        }
        impl<'a> Open<'a> {
            pub fn new<C, V>(virtual_host: V, capabilities: C, insist: bool) -> Self
                where V: Into<::std::borrow::Cow<'a, str>>,
                      C: Into<::std::borrow::Cow<'a, str>>
            {
                Open {
                    virtual_host: virtual_host.into(),
                    capabilities: capabilities.into(),
                    insist: insist,
                }
            }
            pub fn virtual_host(&self) -> &str {
                &*self.virtual_host
            }
            pub fn capabilities(&self) -> &str {
                &*self.capabilities
            }
            pub fn insist(&self) -> bool {
                self.insist
            }
        }
        impl<'a> ::amqp0::Message for Open<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [3, self.virtual_host.len(), self.capabilities.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct OpenOk<'a> {
            known_hosts: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> OpenOk<'a> {
            pub fn new<K>(known_hosts: K) -> Self
                where K: Into<::std::borrow::Cow<'a, str>>
            {
                OpenOk { known_hosts: known_hosts.into() }
            }
            pub fn known_hosts(&self) -> &str {
                &*self.known_hosts
            }
        }
        impl<'a> ::amqp0::Message for OpenOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [1, self.known_hosts.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Redirect<'a> {
            host: ::std::borrow::Cow<'a, str>,
            known_hosts: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Redirect<'a> {
            pub fn new<H, K>(host: H, known_hosts: K) -> Self
                where H: Into<::std::borrow::Cow<'a, str>>,
                      K: Into<::std::borrow::Cow<'a, str>>
            {
                Redirect {
                    host: host.into(),
                    known_hosts: known_hosts.into(),
                }
            }
            pub fn host(&self) -> &str {
                &*self.host
            }
            pub fn known_hosts(&self) -> &str {
                &*self.known_hosts
            }
        }
        impl<'a> ::amqp0::Message for Redirect<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.host.len(), self.known_hosts.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Close<'a> {
            reply_code: u16,
            reply_text: ::std::borrow::Cow<'a, str>,
            class_id: u16,
            method_id: u16,
        }
        impl<'a> Close<'a> {
            pub fn new<R>(reply_code: u16, reply_text: R, class_id: u16, method_id: u16) -> Self
                where R: Into<::std::borrow::Cow<'a, str>>
            {
                Close {
                    reply_code: reply_code,
                    reply_text: reply_text.into(),
                    class_id: class_id,
                    method_id: method_id,
                }
            }
            pub fn reply_code(&self) -> u16 {
                self.reply_code
            }
            pub fn reply_text(&self) -> &str {
                &*self.reply_text
            }
            pub fn class_id(&self) -> u16 {
                self.class_id
            }
            pub fn method_id(&self) -> u16 {
                self.method_id
            }
        }
        impl<'a> ::amqp0::Message for Close<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [7, self.reply_text.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct CloseOk;
        impl CloseOk {
            pub fn new() -> Self {
                CloseOk
            }
        }
        impl ::amqp0::Message for CloseOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }
    }
    pub mod dtx {

        // Class Modules
        pub struct Select;
        impl Select {
            pub fn new() -> Self {
                Select
            }
        }
        impl ::amqp0::Message for Select {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct SelectOk;
        impl SelectOk {
            pub fn new() -> Self {
                SelectOk
            }
        }
        impl ::amqp0::Message for SelectOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Start<'a> {
            dtx_identifier: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Start<'a> {
            pub fn new<D>(dtx_identifier: D) -> Self
                where D: Into<::std::borrow::Cow<'a, str>>
            {
                Start { dtx_identifier: dtx_identifier.into() }
            }
            pub fn dtx_identifier(&self) -> &str {
                &*self.dtx_identifier
            }
        }
        impl<'a> ::amqp0::Message for Start<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [1, self.dtx_identifier.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct StartOk;
        impl StartOk {
            pub fn new() -> Self {
                StartOk
            }
        }
        impl ::amqp0::Message for StartOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }
    }
    pub mod exchange {

        // Class Modules
        pub struct Declare<'a> {
            ticket: u16,
            exchange: ::std::borrow::Cow<'a, str>,
            ty: ::std::borrow::Cow<'a, str>,
            passive: bool,
            durable: bool,
            auto_delete: bool,
            internal: bool,
            nowait: bool,
            arguments: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
        }
        impl<'a> Declare<'a> {
            pub fn new<A, E, T>(ticket: u16,
                                exchange: E,
                                ty: T,
                                passive: bool,
                                durable: bool,
                                auto_delete: bool,
                                internal: bool,
                                nowait: bool,
                                arguments: A)
                                -> Self
                where E: Into<::std::borrow::Cow<'a, str>>,
                      T: Into<::std::borrow::Cow<'a, str>>,
                      A: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>
            {
                Declare {
                    ticket: ticket,
                    exchange: exchange.into(),
                    ty: ty.into(),
                    passive: passive,
                    durable: durable,
                    auto_delete: auto_delete,
                    internal: internal,
                    nowait: nowait,
                    arguments: arguments.into(),
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn ty(&self) -> &str {
                &*self.ty
            }
            pub fn passive(&self) -> bool {
                self.passive
            }
            pub fn durable(&self) -> bool {
                self.durable
            }
            pub fn auto_delete(&self) -> bool {
                self.auto_delete
            }
            pub fn internal(&self) -> bool {
                self.internal
            }
            pub fn nowait(&self) -> bool {
                self.nowait
            }
            pub fn arguments(&self) -> &::amqp0::value::Table {
                &*self.arguments
            }
        }
        impl<'a> ::amqp0::Message for Declare<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [5, self.exchange.len(), self.ty.len(), self.arguments.amqp_size()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct DeclareOk;
        impl DeclareOk {
            pub fn new() -> Self {
                DeclareOk
            }
        }
        impl ::amqp0::Message for DeclareOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Delete<'a> {
            ticket: u16,
            exchange: ::std::borrow::Cow<'a, str>,
            if_unused: bool,
            nowait: bool,
        }
        impl<'a> Delete<'a> {
            pub fn new<E>(ticket: u16, exchange: E, if_unused: bool, nowait: bool) -> Self
                where E: Into<::std::borrow::Cow<'a, str>>
            {
                Delete {
                    ticket: ticket,
                    exchange: exchange.into(),
                    if_unused: if_unused,
                    nowait: nowait,
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn if_unused(&self) -> bool {
                self.if_unused
            }
            pub fn nowait(&self) -> bool {
                self.nowait
            }
        }
        impl<'a> ::amqp0::Message for Delete<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [4, self.exchange.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct DeleteOk;
        impl DeleteOk {
            pub fn new() -> Self {
                DeleteOk
            }
        }
        impl ::amqp0::Message for DeleteOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }
    }
    pub mod file {

        // Class Modules
        pub struct Qos {
            prefetch_size: u32,
            prefetch_count: u16,
            global: bool,
        }
        impl Qos {
            pub fn new(prefetch_size: u32, prefetch_count: u16, global: bool) -> Self {
                Qos {
                    prefetch_size: prefetch_size,
                    prefetch_count: prefetch_count,
                    global: global,
                }
            }
            pub fn prefetch_size(&self) -> u32 {
                self.prefetch_size
            }
            pub fn prefetch_count(&self) -> u16 {
                self.prefetch_count
            }
            pub fn global(&self) -> bool {
                self.global
            }
        }
        impl ::amqp0::Message for Qos {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                7
            }
        }

        // Class Modules
        pub struct QosOk;
        impl QosOk {
            pub fn new() -> Self {
                QosOk
            }
        }
        impl ::amqp0::Message for QosOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Consume<'a> {
            ticket: u16,
            queue: ::std::borrow::Cow<'a, str>,
            consumer_tag: ::std::borrow::Cow<'a, str>,
            no_local: bool,
            no_ack: bool,
            exclusive: bool,
            nowait: bool,
        }
        impl<'a> Consume<'a> {
            pub fn new<C, Q>(ticket: u16,
                             queue: Q,
                             consumer_tag: C,
                             no_local: bool,
                             no_ack: bool,
                             exclusive: bool,
                             nowait: bool)
                             -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>,
                      C: Into<::std::borrow::Cow<'a, str>>
            {
                Consume {
                    ticket: ticket,
                    queue: queue.into(),
                    consumer_tag: consumer_tag.into(),
                    no_local: no_local,
                    no_ack: no_ack,
                    exclusive: exclusive,
                    nowait: nowait,
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
            pub fn no_local(&self) -> bool {
                self.no_local
            }
            pub fn no_ack(&self) -> bool {
                self.no_ack
            }
            pub fn exclusive(&self) -> bool {
                self.exclusive
            }
            pub fn nowait(&self) -> bool {
                self.nowait
            }
        }
        impl<'a> ::amqp0::Message for Consume<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [5, self.queue.len(), self.consumer_tag.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct ConsumeOk<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> ConsumeOk<'a> {
            pub fn new<C>(consumer_tag: C) -> Self
                where C: Into<::std::borrow::Cow<'a, str>>
            {
                ConsumeOk { consumer_tag: consumer_tag.into() }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
        }
        impl<'a> ::amqp0::Message for ConsumeOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [1, self.consumer_tag.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Cancel<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
            nowait: bool,
        }
        impl<'a> Cancel<'a> {
            pub fn new<C>(consumer_tag: C, nowait: bool) -> Self
                where C: Into<::std::borrow::Cow<'a, str>>
            {
                Cancel {
                    consumer_tag: consumer_tag.into(),
                    nowait: nowait,
                }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
            pub fn nowait(&self) -> bool {
                self.nowait
            }
        }
        impl<'a> ::amqp0::Message for Cancel<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.consumer_tag.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct CancelOk<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> CancelOk<'a> {
            pub fn new<C>(consumer_tag: C) -> Self
                where C: Into<::std::borrow::Cow<'a, str>>
            {
                CancelOk { consumer_tag: consumer_tag.into() }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
        }
        impl<'a> ::amqp0::Message for CancelOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [1, self.consumer_tag.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Open<'a> {
            identifier: ::std::borrow::Cow<'a, str>,
            content_size: u64,
        }
        impl<'a> Open<'a> {
            pub fn new<I>(identifier: I, content_size: u64) -> Self
                where I: Into<::std::borrow::Cow<'a, str>>
            {
                Open {
                    identifier: identifier.into(),
                    content_size: content_size,
                }
            }
            pub fn identifier(&self) -> &str {
                &*self.identifier
            }
            pub fn content_size(&self) -> u64 {
                self.content_size
            }
        }
        impl<'a> ::amqp0::Message for Open<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [9, self.identifier.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct OpenOk {
            staged_size: u64,
        }
        impl OpenOk {
            pub fn new(staged_size: u64) -> Self {
                OpenOk { staged_size: staged_size }
            }
            pub fn staged_size(&self) -> u64 {
                self.staged_size
            }
        }
        impl ::amqp0::Message for OpenOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                8
            }
        }

        // Class Modules
        pub struct Stage;
        impl Stage {
            pub fn new() -> Self {
                Stage
            }
        }
        impl ::amqp0::Message for Stage {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Publish<'a> {
            ticket: u16,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
            mandatory: bool,
            immediate: bool,
            identifier: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Publish<'a> {
            pub fn new<E, I, R>(ticket: u16,
                                exchange: E,
                                routing_key: R,
                                mandatory: bool,
                                immediate: bool,
                                identifier: I)
                                -> Self
                where E: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, str>>,
                      I: Into<::std::borrow::Cow<'a, str>>
            {
                Publish {
                    ticket: ticket,
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                    mandatory: mandatory,
                    immediate: immediate,
                    identifier: identifier.into(),
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
            pub fn mandatory(&self) -> bool {
                self.mandatory
            }
            pub fn immediate(&self) -> bool {
                self.immediate
            }
            pub fn identifier(&self) -> &str {
                &*self.identifier
            }
        }
        impl<'a> ::amqp0::Message for Publish<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [6, self.exchange.len(), self.routing_key.len(), self.identifier.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Return<'a> {
            reply_code: u16,
            reply_text: ::std::borrow::Cow<'a, str>,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Return<'a> {
            pub fn new<E, R, R0>(reply_code: u16,
                                 reply_text: R,
                                 exchange: E,
                                 routing_key: R0)
                                 -> Self
                where R: Into<::std::borrow::Cow<'a, str>>,
                      E: Into<::std::borrow::Cow<'a, str>>,
                      R0: Into<::std::borrow::Cow<'a, str>>
            {
                Return {
                    reply_code: reply_code,
                    reply_text: reply_text.into(),
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                }
            }
            pub fn reply_code(&self) -> u16 {
                self.reply_code
            }
            pub fn reply_text(&self) -> &str {
                &*self.reply_text
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
        }
        impl<'a> ::amqp0::Message for Return<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [5, self.reply_text.len(), self.exchange.len(), self.routing_key.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Deliver<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
            delivery_tag: u64,
            redelivered: bool,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
            identifier: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Deliver<'a> {
            pub fn new<C, E, I, R>(consumer_tag: C,
                                   delivery_tag: u64,
                                   redelivered: bool,
                                   exchange: E,
                                   routing_key: R,
                                   identifier: I)
                                   -> Self
                where C: Into<::std::borrow::Cow<'a, str>>,
                      E: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, str>>,
                      I: Into<::std::borrow::Cow<'a, str>>
            {
                Deliver {
                    consumer_tag: consumer_tag.into(),
                    delivery_tag: delivery_tag,
                    redelivered: redelivered,
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                    identifier: identifier.into(),
                }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
            pub fn delivery_tag(&self) -> u64 {
                self.delivery_tag
            }
            pub fn redelivered(&self) -> bool {
                self.redelivered
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
            pub fn identifier(&self) -> &str {
                &*self.identifier
            }
        }
        impl<'a> ::amqp0::Message for Deliver<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [13,
                 self.consumer_tag.len(),
                 self.exchange.len(),
                 self.routing_key.len(),
                 self.identifier.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Ack {
            delivery_tag: u64,
            multiple: bool,
        }
        impl Ack {
            pub fn new(delivery_tag: u64, multiple: bool) -> Self {
                Ack {
                    delivery_tag: delivery_tag,
                    multiple: multiple,
                }
            }
            pub fn delivery_tag(&self) -> u64 {
                self.delivery_tag
            }
            pub fn multiple(&self) -> bool {
                self.multiple
            }
        }
        impl ::amqp0::Message for Ack {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                9
            }
        }

        // Class Modules
        pub struct Reject {
            delivery_tag: u64,
            requeue: bool,
        }
        impl Reject {
            pub fn new(delivery_tag: u64, requeue: bool) -> Self {
                Reject {
                    delivery_tag: delivery_tag,
                    requeue: requeue,
                }
            }
            pub fn delivery_tag(&self) -> u64 {
                self.delivery_tag
            }
            pub fn requeue(&self) -> bool {
                self.requeue
            }
        }
        impl ::amqp0::Message for Reject {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                9
            }
        }
    }
    pub mod queue {

        // Class Modules
        pub struct Declare<'a> {
            ticket: u16,
            queue: ::std::borrow::Cow<'a, str>,
            passive: bool,
            durable: bool,
            exclusive: bool,
            auto_delete: bool,
            nowait: bool,
            arguments: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
        }
        impl<'a> Declare<'a> {
            pub fn new<A, Q>(ticket: u16,
                             queue: Q,
                             passive: bool,
                             durable: bool,
                             exclusive: bool,
                             auto_delete: bool,
                             nowait: bool,
                             arguments: A)
                             -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>,
                      A: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>
            {
                Declare {
                    ticket: ticket,
                    queue: queue.into(),
                    passive: passive,
                    durable: durable,
                    exclusive: exclusive,
                    auto_delete: auto_delete,
                    nowait: nowait,
                    arguments: arguments.into(),
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn passive(&self) -> bool {
                self.passive
            }
            pub fn durable(&self) -> bool {
                self.durable
            }
            pub fn exclusive(&self) -> bool {
                self.exclusive
            }
            pub fn auto_delete(&self) -> bool {
                self.auto_delete
            }
            pub fn nowait(&self) -> bool {
                self.nowait
            }
            pub fn arguments(&self) -> &::amqp0::value::Table {
                &*self.arguments
            }
        }
        impl<'a> ::amqp0::Message for Declare<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [4, self.queue.len(), self.arguments.amqp_size()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct DeclareOk<'a> {
            queue: ::std::borrow::Cow<'a, str>,
            message_count: u32,
            consumer_count: u32,
        }
        impl<'a> DeclareOk<'a> {
            pub fn new<Q>(queue: Q, message_count: u32, consumer_count: u32) -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>
            {
                DeclareOk {
                    queue: queue.into(),
                    message_count: message_count,
                    consumer_count: consumer_count,
                }
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn message_count(&self) -> u32 {
                self.message_count
            }
            pub fn consumer_count(&self) -> u32 {
                self.consumer_count
            }
        }
        impl<'a> ::amqp0::Message for DeclareOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [9, self.queue.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Bind<'a> {
            ticket: u16,
            queue: ::std::borrow::Cow<'a, str>,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
            nowait: bool,
            arguments: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
        }
        impl<'a> Bind<'a> {
            pub fn new<A, E, Q, R>(ticket: u16,
                                   queue: Q,
                                   exchange: E,
                                   routing_key: R,
                                   nowait: bool,
                                   arguments: A)
                                   -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>,
                      E: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, str>>,
                      A: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>
            {
                Bind {
                    ticket: ticket,
                    queue: queue.into(),
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                    nowait: nowait,
                    arguments: arguments.into(),
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
            pub fn nowait(&self) -> bool {
                self.nowait
            }
            pub fn arguments(&self) -> &::amqp0::value::Table {
                &*self.arguments
            }
        }
        impl<'a> ::amqp0::Message for Bind<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [6,
                 self.queue.len(),
                 self.exchange.len(),
                 self.routing_key.len(),
                 self.arguments.amqp_size()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct BindOk;
        impl BindOk {
            pub fn new() -> Self {
                BindOk
            }
        }
        impl ::amqp0::Message for BindOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Purge<'a> {
            ticket: u16,
            queue: ::std::borrow::Cow<'a, str>,
            nowait: bool,
        }
        impl<'a> Purge<'a> {
            pub fn new<Q>(ticket: u16, queue: Q, nowait: bool) -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>
            {
                Purge {
                    ticket: ticket,
                    queue: queue.into(),
                    nowait: nowait,
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn nowait(&self) -> bool {
                self.nowait
            }
        }
        impl<'a> ::amqp0::Message for Purge<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [4, self.queue.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct PurgeOk {
            message_count: u32,
        }
        impl PurgeOk {
            pub fn new(message_count: u32) -> Self {
                PurgeOk { message_count: message_count }
            }
            pub fn message_count(&self) -> u32 {
                self.message_count
            }
        }
        impl ::amqp0::Message for PurgeOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                4
            }
        }

        // Class Modules
        pub struct Delete<'a> {
            ticket: u16,
            queue: ::std::borrow::Cow<'a, str>,
            if_unused: bool,
            if_empty: bool,
            nowait: bool,
        }
        impl<'a> Delete<'a> {
            pub fn new<Q>(ticket: u16,
                          queue: Q,
                          if_unused: bool,
                          if_empty: bool,
                          nowait: bool)
                          -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>
            {
                Delete {
                    ticket: ticket,
                    queue: queue.into(),
                    if_unused: if_unused,
                    if_empty: if_empty,
                    nowait: nowait,
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn if_unused(&self) -> bool {
                self.if_unused
            }
            pub fn if_empty(&self) -> bool {
                self.if_empty
            }
            pub fn nowait(&self) -> bool {
                self.nowait
            }
        }
        impl<'a> ::amqp0::Message for Delete<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [4, self.queue.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct DeleteOk {
            message_count: u32,
        }
        impl DeleteOk {
            pub fn new(message_count: u32) -> Self {
                DeleteOk { message_count: message_count }
            }
            pub fn message_count(&self) -> u32 {
                self.message_count
            }
        }
        impl ::amqp0::Message for DeleteOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                4
            }
        }
    }
    pub mod stream {

        // Class Modules
        pub struct Qos {
            prefetch_size: u32,
            prefetch_count: u16,
            consume_rate: u32,
            global: bool,
        }
        impl Qos {
            pub fn new(prefetch_size: u32,
                       prefetch_count: u16,
                       consume_rate: u32,
                       global: bool)
                       -> Self {
                Qos {
                    prefetch_size: prefetch_size,
                    prefetch_count: prefetch_count,
                    consume_rate: consume_rate,
                    global: global,
                }
            }
            pub fn prefetch_size(&self) -> u32 {
                self.prefetch_size
            }
            pub fn prefetch_count(&self) -> u16 {
                self.prefetch_count
            }
            pub fn consume_rate(&self) -> u32 {
                self.consume_rate
            }
            pub fn global(&self) -> bool {
                self.global
            }
        }
        impl ::amqp0::Message for Qos {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                11
            }
        }

        // Class Modules
        pub struct QosOk;
        impl QosOk {
            pub fn new() -> Self {
                QosOk
            }
        }
        impl ::amqp0::Message for QosOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Consume<'a> {
            ticket: u16,
            queue: ::std::borrow::Cow<'a, str>,
            consumer_tag: ::std::borrow::Cow<'a, str>,
            no_local: bool,
            exclusive: bool,
            nowait: bool,
        }
        impl<'a> Consume<'a> {
            pub fn new<C, Q>(ticket: u16,
                             queue: Q,
                             consumer_tag: C,
                             no_local: bool,
                             exclusive: bool,
                             nowait: bool)
                             -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>,
                      C: Into<::std::borrow::Cow<'a, str>>
            {
                Consume {
                    ticket: ticket,
                    queue: queue.into(),
                    consumer_tag: consumer_tag.into(),
                    no_local: no_local,
                    exclusive: exclusive,
                    nowait: nowait,
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
            pub fn no_local(&self) -> bool {
                self.no_local
            }
            pub fn exclusive(&self) -> bool {
                self.exclusive
            }
            pub fn nowait(&self) -> bool {
                self.nowait
            }
        }
        impl<'a> ::amqp0::Message for Consume<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [5, self.queue.len(), self.consumer_tag.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct ConsumeOk<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> ConsumeOk<'a> {
            pub fn new<C>(consumer_tag: C) -> Self
                where C: Into<::std::borrow::Cow<'a, str>>
            {
                ConsumeOk { consumer_tag: consumer_tag.into() }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
        }
        impl<'a> ::amqp0::Message for ConsumeOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [1, self.consumer_tag.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Cancel<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
            nowait: bool,
        }
        impl<'a> Cancel<'a> {
            pub fn new<C>(consumer_tag: C, nowait: bool) -> Self
                where C: Into<::std::borrow::Cow<'a, str>>
            {
                Cancel {
                    consumer_tag: consumer_tag.into(),
                    nowait: nowait,
                }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
            pub fn nowait(&self) -> bool {
                self.nowait
            }
        }
        impl<'a> ::amqp0::Message for Cancel<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.consumer_tag.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct CancelOk<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> CancelOk<'a> {
            pub fn new<C>(consumer_tag: C) -> Self
                where C: Into<::std::borrow::Cow<'a, str>>
            {
                CancelOk { consumer_tag: consumer_tag.into() }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
        }
        impl<'a> ::amqp0::Message for CancelOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [1, self.consumer_tag.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Publish<'a> {
            ticket: u16,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
            mandatory: bool,
            immediate: bool,
        }
        impl<'a> Publish<'a> {
            pub fn new<E, R>(ticket: u16,
                             exchange: E,
                             routing_key: R,
                             mandatory: bool,
                             immediate: bool)
                             -> Self
                where E: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, str>>
            {
                Publish {
                    ticket: ticket,
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                    mandatory: mandatory,
                    immediate: immediate,
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
            pub fn mandatory(&self) -> bool {
                self.mandatory
            }
            pub fn immediate(&self) -> bool {
                self.immediate
            }
        }
        impl<'a> ::amqp0::Message for Publish<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [5, self.exchange.len(), self.routing_key.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Return<'a> {
            reply_code: u16,
            reply_text: ::std::borrow::Cow<'a, str>,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Return<'a> {
            pub fn new<E, R, R0>(reply_code: u16,
                                 reply_text: R,
                                 exchange: E,
                                 routing_key: R0)
                                 -> Self
                where R: Into<::std::borrow::Cow<'a, str>>,
                      E: Into<::std::borrow::Cow<'a, str>>,
                      R0: Into<::std::borrow::Cow<'a, str>>
            {
                Return {
                    reply_code: reply_code,
                    reply_text: reply_text.into(),
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                }
            }
            pub fn reply_code(&self) -> u16 {
                self.reply_code
            }
            pub fn reply_text(&self) -> &str {
                &*self.reply_text
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
        }
        impl<'a> ::amqp0::Message for Return<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [5, self.reply_text.len(), self.exchange.len(), self.routing_key.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Deliver<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
            delivery_tag: u64,
            exchange: ::std::borrow::Cow<'a, str>,
            queue: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Deliver<'a> {
            pub fn new<C, E, Q>(consumer_tag: C, delivery_tag: u64, exchange: E, queue: Q) -> Self
                where C: Into<::std::borrow::Cow<'a, str>>,
                      E: Into<::std::borrow::Cow<'a, str>>,
                      Q: Into<::std::borrow::Cow<'a, str>>
            {
                Deliver {
                    consumer_tag: consumer_tag.into(),
                    delivery_tag: delivery_tag,
                    exchange: exchange.into(),
                    queue: queue.into(),
                }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
            pub fn delivery_tag(&self) -> u64 {
                self.delivery_tag
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
        }
        impl<'a> ::amqp0::Message for Deliver<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [11, self.consumer_tag.len(), self.exchange.len(), self.queue.len()]
                    .iter()
                    .sum()
            }
        }
    }
    pub mod test {

        // Class Modules
        pub struct Integer {
            integer_1: u8,
            integer_2: u16,
            integer_3: u32,
            integer_4: u64,
            operation: u8,
        }
        impl Integer {
            pub fn new(integer_1: u8,
                       integer_2: u16,
                       integer_3: u32,
                       integer_4: u64,
                       operation: u8)
                       -> Self {
                Integer {
                    integer_1: integer_1,
                    integer_2: integer_2,
                    integer_3: integer_3,
                    integer_4: integer_4,
                    operation: operation,
                }
            }
            pub fn integer_1(&self) -> u8 {
                self.integer_1
            }
            pub fn integer_2(&self) -> u16 {
                self.integer_2
            }
            pub fn integer_3(&self) -> u32 {
                self.integer_3
            }
            pub fn integer_4(&self) -> u64 {
                self.integer_4
            }
            pub fn operation(&self) -> u8 {
                self.operation
            }
        }
        impl ::amqp0::Message for Integer {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                16
            }
        }

        // Class Modules
        pub struct IntegerOk {
            result: u64,
        }
        impl IntegerOk {
            pub fn new(result: u64) -> Self {
                IntegerOk { result: result }
            }
            pub fn result(&self) -> u64 {
                self.result
            }
        }
        impl ::amqp0::Message for IntegerOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                8
            }
        }

        // Class Modules
        pub struct String<'a> {
            string_1: ::std::borrow::Cow<'a, str>,
            string_2: ::std::borrow::Cow<'a, [u8]>,
            operation: u8,
        }
        impl<'a> String<'a> {
            pub fn new<S, S0>(string_1: S, string_2: S0, operation: u8) -> Self
                where S: Into<::std::borrow::Cow<'a, str>>,
                      S0: Into<::std::borrow::Cow<'a, [u8]>>
            {
                String {
                    string_1: string_1.into(),
                    string_2: string_2.into(),
                    operation: operation,
                }
            }
            pub fn string_1(&self) -> &str {
                &*self.string_1
            }
            pub fn string_2(&self) -> &[u8] {
                &*self.string_2
            }
            pub fn operation(&self) -> u8 {
                self.operation
            }
        }
        impl<'a> ::amqp0::Message for String<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [4, self.string_1.len(), self.string_2.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct StringOk<'a> {
            result: ::std::borrow::Cow<'a, [u8]>,
        }
        impl<'a> StringOk<'a> {
            pub fn new<R>(result: R) -> Self
                where R: Into<::std::borrow::Cow<'a, [u8]>>
            {
                StringOk { result: result.into() }
            }
            pub fn result(&self) -> &[u8] {
                &*self.result
            }
        }
        impl<'a> ::amqp0::Message for StringOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.result.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Table<'a> {
            table: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
            integer_op: u8,
            string_op: u8,
        }
        impl<'a> Table<'a> {
            pub fn new<T>(table: T, integer_op: u8, string_op: u8) -> Self
                where T: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>
            {
                Table {
                    table: table.into(),
                    integer_op: integer_op,
                    string_op: string_op,
                }
            }
            pub fn table(&self) -> &::amqp0::value::Table {
                &*self.table
            }
            pub fn integer_op(&self) -> u8 {
                self.integer_op
            }
            pub fn string_op(&self) -> u8 {
                self.string_op
            }
        }
        impl<'a> ::amqp0::Message for Table<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.table.amqp_size()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct TableOk<'a> {
            integer_result: u64,
            string_result: ::std::borrow::Cow<'a, [u8]>,
        }
        impl<'a> TableOk<'a> {
            pub fn new<S>(integer_result: u64, string_result: S) -> Self
                where S: Into<::std::borrow::Cow<'a, [u8]>>
            {
                TableOk {
                    integer_result: integer_result,
                    string_result: string_result.into(),
                }
            }
            pub fn integer_result(&self) -> u64 {
                self.integer_result
            }
            pub fn string_result(&self) -> &[u8] {
                &*self.string_result
            }
        }
        impl<'a> ::amqp0::Message for TableOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [10, self.string_result.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Content;
        impl Content {
            pub fn new() -> Self {
                Content
            }
        }
        impl ::amqp0::Message for Content {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct ContentOk {
            content_checksum: u32,
        }
        impl ContentOk {
            pub fn new(content_checksum: u32) -> Self {
                ContentOk { content_checksum: content_checksum }
            }
            pub fn content_checksum(&self) -> u32 {
                self.content_checksum
            }
        }
        impl ::amqp0::Message for ContentOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                4
            }
        }
    }
    pub mod tunnel {

        // Class Modules
        pub struct Request<'a> {
            meta_data: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
        }
        impl<'a> Request<'a> {
            pub fn new<M>(meta_data: M) -> Self
                where M: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>
            {
                Request { meta_data: meta_data.into() }
            }
            pub fn meta_data(&self) -> &::amqp0::value::Table {
                &*self.meta_data
            }
        }
        impl<'a> ::amqp0::Message for Request<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [0, self.meta_data.amqp_size()]
                    .iter()
                    .sum()
            }
        }
    }
    pub mod tx {

        // Class Modules
        pub struct Select;
        impl Select {
            pub fn new() -> Self {
                Select
            }
        }
        impl ::amqp0::Message for Select {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct SelectOk;
        impl SelectOk {
            pub fn new() -> Self {
                SelectOk
            }
        }
        impl ::amqp0::Message for SelectOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Commit;
        impl Commit {
            pub fn new() -> Self {
                Commit
            }
        }
        impl ::amqp0::Message for Commit {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct CommitOk;
        impl CommitOk {
            pub fn new() -> Self {
                CommitOk
            }
        }
        impl ::amqp0::Message for CommitOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Rollback;
        impl Rollback {
            pub fn new() -> Self {
                Rollback
            }
        }
        impl ::amqp0::Message for Rollback {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct RollbackOk;
        impl RollbackOk {
            pub fn new() -> Self {
                RollbackOk
            }
        }
        impl ::amqp0::Message for RollbackOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }
    }
}

#[allow(non_camel_case_types)]
pub struct Amqp8_0;
impl Spec for Amqp8_0 {}

pub mod rabbitmq9_1 {
    // Class Constants
    pub const CLASS_BASIC: u16 = 60;
    pub const CLASS_CHANNEL: u16 = 20;
    pub const CLASS_CONFIRM: u16 = 85;
    pub const CLASS_CONNECTION: u16 = 10;
    pub const CLASS_EXCHANGE: u16 = 40;
    pub const CLASS_QUEUE: u16 = 50;
    pub const CLASS_TX: u16 = 90;

    // Class Methods
    pub const METHOD_BASIC_QOS: u16 = 10;
    pub const METHOD_BASIC_QOS_OK: u16 = 11;
    pub const METHOD_BASIC_CONSUME: u16 = 20;
    pub const METHOD_BASIC_CONSUME_OK: u16 = 21;
    pub const METHOD_BASIC_CANCEL: u16 = 30;
    pub const METHOD_BASIC_CANCEL_OK: u16 = 31;
    pub const METHOD_BASIC_PUBLISH: u16 = 40;
    pub const METHOD_BASIC_RETURN: u16 = 50;
    pub const METHOD_BASIC_DELIVER: u16 = 60;
    pub const METHOD_BASIC_GET: u16 = 70;
    pub const METHOD_BASIC_GET_OK: u16 = 71;
    pub const METHOD_BASIC_GET_EMPTY: u16 = 72;
    pub const METHOD_BASIC_ACK: u16 = 80;
    pub const METHOD_BASIC_REJECT: u16 = 90;
    pub const METHOD_BASIC_RECOVER_ASYNC: u16 = 100;
    pub const METHOD_BASIC_RECOVER: u16 = 110;
    pub const METHOD_BASIC_RECOVER_OK: u16 = 111;
    pub const METHOD_BASIC_NACK: u16 = 120;

    pub const METHOD_CHANNEL_OPEN: u16 = 10;
    pub const METHOD_CHANNEL_OPEN_OK: u16 = 11;
    pub const METHOD_CHANNEL_FLOW: u16 = 20;
    pub const METHOD_CHANNEL_FLOW_OK: u16 = 21;
    pub const METHOD_CHANNEL_CLOSE: u16 = 40;
    pub const METHOD_CHANNEL_CLOSE_OK: u16 = 41;

    pub const METHOD_CONFIRM_SELECT: u16 = 10;
    pub const METHOD_CONFIRM_SELECT_OK: u16 = 11;

    pub const METHOD_CONNECTION_START: u16 = 10;
    pub const METHOD_CONNECTION_START_OK: u16 = 11;
    pub const METHOD_CONNECTION_SECURE: u16 = 20;
    pub const METHOD_CONNECTION_SECURE_OK: u16 = 21;
    pub const METHOD_CONNECTION_TUNE: u16 = 30;
    pub const METHOD_CONNECTION_TUNE_OK: u16 = 31;
    pub const METHOD_CONNECTION_OPEN: u16 = 40;
    pub const METHOD_CONNECTION_OPEN_OK: u16 = 41;
    pub const METHOD_CONNECTION_CLOSE: u16 = 50;
    pub const METHOD_CONNECTION_CLOSE_OK: u16 = 51;
    pub const METHOD_CONNECTION_BLOCKED: u16 = 60;
    pub const METHOD_CONNECTION_UNBLOCKED: u16 = 61;

    pub const METHOD_EXCHANGE_DECLARE: u16 = 10;
    pub const METHOD_EXCHANGE_DECLARE_OK: u16 = 11;
    pub const METHOD_EXCHANGE_DELETE: u16 = 20;
    pub const METHOD_EXCHANGE_DELETE_OK: u16 = 21;
    pub const METHOD_EXCHANGE_BIND: u16 = 30;
    pub const METHOD_EXCHANGE_BIND_OK: u16 = 31;
    pub const METHOD_EXCHANGE_UNBIND: u16 = 40;
    pub const METHOD_EXCHANGE_UNBIND_OK: u16 = 51;

    pub const METHOD_QUEUE_DECLARE: u16 = 10;
    pub const METHOD_QUEUE_DECLARE_OK: u16 = 11;
    pub const METHOD_QUEUE_BIND: u16 = 20;
    pub const METHOD_QUEUE_BIND_OK: u16 = 21;
    pub const METHOD_QUEUE_UNBIND: u16 = 50;
    pub const METHOD_QUEUE_UNBIND_OK: u16 = 51;
    pub const METHOD_QUEUE_PURGE: u16 = 30;
    pub const METHOD_QUEUE_PURGE_OK: u16 = 31;
    pub const METHOD_QUEUE_DELETE: u16 = 40;
    pub const METHOD_QUEUE_DELETE_OK: u16 = 41;

    pub const METHOD_TX_SELECT: u16 = 10;
    pub const METHOD_TX_SELECT_OK: u16 = 11;
    pub const METHOD_TX_COMMIT: u16 = 20;
    pub const METHOD_TX_COMMIT_OK: u16 = 21;
    pub const METHOD_TX_ROLLBACK: u16 = 30;
    pub const METHOD_TX_ROLLBACK_OK: u16 = 31;
    pub mod basic {

        // Class Modules
        pub struct Qos {
            prefetch_size: u32,
            prefetch_count: u16,
            global: bool,
        }
        impl Qos {
            pub fn new(prefetch_size: u32, prefetch_count: u16, global: bool) -> Self {
                Qos {
                    prefetch_size: prefetch_size,
                    prefetch_count: prefetch_count,
                    global: global,
                }
            }
            pub fn prefetch_size(&self) -> u32 {
                self.prefetch_size
            }
            pub fn prefetch_count(&self) -> u16 {
                self.prefetch_count
            }
            pub fn global(&self) -> bool {
                self.global
            }
        }
        impl ::amqp0::Message for Qos {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                7
            }
        }

        // Class Modules
        pub struct QosOk;
        impl QosOk {
            pub fn new() -> Self {
                QosOk
            }
        }
        impl ::amqp0::Message for QosOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Consume<'a> {
            queue: ::std::borrow::Cow<'a, str>,
            consumer_tag: ::std::borrow::Cow<'a, str>,
            no_local: bool,
            no_ack: bool,
            exclusive: bool,
            no_wait: bool,
            arguments: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
        }
        impl<'a> Consume<'a> {
            pub fn new<A, C, Q>(queue: Q,
                                consumer_tag: C,
                                no_local: bool,
                                no_ack: bool,
                                exclusive: bool,
                                no_wait: bool,
                                arguments: A)
                                -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>,
                      C: Into<::std::borrow::Cow<'a, str>>,
                      A: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>
            {
                Consume {
                    queue: queue.into(),
                    consumer_tag: consumer_tag.into(),
                    no_local: no_local,
                    no_ack: no_ack,
                    exclusive: exclusive,
                    no_wait: no_wait,
                    arguments: arguments.into(),
                }
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
            pub fn no_local(&self) -> bool {
                self.no_local
            }
            pub fn no_ack(&self) -> bool {
                self.no_ack
            }
            pub fn exclusive(&self) -> bool {
                self.exclusive
            }
            pub fn no_wait(&self) -> bool {
                self.no_wait
            }
            pub fn arguments(&self) -> &::amqp0::value::Table {
                &*self.arguments
            }
        }
        impl<'a> ::amqp0::Message for Consume<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [3, self.queue.len(), self.consumer_tag.len(), self.arguments.amqp_size()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct ConsumeOk<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> ConsumeOk<'a> {
            pub fn new<C>(consumer_tag: C) -> Self
                where C: Into<::std::borrow::Cow<'a, str>>
            {
                ConsumeOk { consumer_tag: consumer_tag.into() }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
        }
        impl<'a> ::amqp0::Message for ConsumeOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [1, self.consumer_tag.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Cancel<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
            no_wait: bool,
        }
        impl<'a> Cancel<'a> {
            pub fn new<C>(consumer_tag: C, no_wait: bool) -> Self
                where C: Into<::std::borrow::Cow<'a, str>>
            {
                Cancel {
                    consumer_tag: consumer_tag.into(),
                    no_wait: no_wait,
                }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
            pub fn no_wait(&self) -> bool {
                self.no_wait
            }
        }
        impl<'a> ::amqp0::Message for Cancel<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.consumer_tag.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct CancelOk<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> CancelOk<'a> {
            pub fn new<C>(consumer_tag: C) -> Self
                where C: Into<::std::borrow::Cow<'a, str>>
            {
                CancelOk { consumer_tag: consumer_tag.into() }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
        }
        impl<'a> ::amqp0::Message for CancelOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [1, self.consumer_tag.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Publish<'a> {
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
            mandatory: bool,
            immediate: bool,
        }
        impl<'a> Publish<'a> {
            pub fn new<E, R>(exchange: E, routing_key: R, mandatory: bool, immediate: bool) -> Self
                where E: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, str>>
            {
                Publish {
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                    mandatory: mandatory,
                    immediate: immediate,
                }
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
            pub fn mandatory(&self) -> bool {
                self.mandatory
            }
            pub fn immediate(&self) -> bool {
                self.immediate
            }
        }
        impl<'a> ::amqp0::Message for Publish<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [3, self.exchange.len(), self.routing_key.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Return<'a> {
            reply_code: u16,
            reply_text: ::std::borrow::Cow<'a, str>,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Return<'a> {
            pub fn new<E, R, R0>(reply_code: u16,
                                 reply_text: R,
                                 exchange: E,
                                 routing_key: R0)
                                 -> Self
                where R: Into<::std::borrow::Cow<'a, str>>,
                      E: Into<::std::borrow::Cow<'a, str>>,
                      R0: Into<::std::borrow::Cow<'a, str>>
            {
                Return {
                    reply_code: reply_code,
                    reply_text: reply_text.into(),
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                }
            }
            pub fn reply_code(&self) -> u16 {
                self.reply_code
            }
            pub fn reply_text(&self) -> &str {
                &*self.reply_text
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
        }
        impl<'a> ::amqp0::Message for Return<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [5, self.reply_text.len(), self.exchange.len(), self.routing_key.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Deliver<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
            delivery_tag: u64,
            redelivered: bool,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Deliver<'a> {
            pub fn new<C, E, R>(consumer_tag: C,
                                delivery_tag: u64,
                                redelivered: bool,
                                exchange: E,
                                routing_key: R)
                                -> Self
                where C: Into<::std::borrow::Cow<'a, str>>,
                      E: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, str>>
            {
                Deliver {
                    consumer_tag: consumer_tag.into(),
                    delivery_tag: delivery_tag,
                    redelivered: redelivered,
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
            pub fn delivery_tag(&self) -> u64 {
                self.delivery_tag
            }
            pub fn redelivered(&self) -> bool {
                self.redelivered
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
        }
        impl<'a> ::amqp0::Message for Deliver<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [12, self.consumer_tag.len(), self.exchange.len(), self.routing_key.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Get<'a> {
            queue: ::std::borrow::Cow<'a, str>,
            no_ack: bool,
        }
        impl<'a> Get<'a> {
            pub fn new<Q>(queue: Q, no_ack: bool) -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>
            {
                Get {
                    queue: queue.into(),
                    no_ack: no_ack,
                }
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn no_ack(&self) -> bool {
                self.no_ack
            }
        }
        impl<'a> ::amqp0::Message for Get<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.queue.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct GetOk<'a> {
            delivery_tag: u64,
            redelivered: bool,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
            message_count: u32,
        }
        impl<'a> GetOk<'a> {
            pub fn new<E, R>(delivery_tag: u64,
                             redelivered: bool,
                             exchange: E,
                             routing_key: R,
                             message_count: u32)
                             -> Self
                where E: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, str>>
            {
                GetOk {
                    delivery_tag: delivery_tag,
                    redelivered: redelivered,
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                    message_count: message_count,
                }
            }
            pub fn delivery_tag(&self) -> u64 {
                self.delivery_tag
            }
            pub fn redelivered(&self) -> bool {
                self.redelivered
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
            pub fn message_count(&self) -> u32 {
                self.message_count
            }
        }
        impl<'a> ::amqp0::Message for GetOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [15, self.exchange.len(), self.routing_key.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct GetEmpty;
        impl GetEmpty {
            pub fn new() -> Self {
                GetEmpty
            }
        }
        impl ::amqp0::Message for GetEmpty {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Ack {
            delivery_tag: u64,
            multiple: bool,
        }
        impl Ack {
            pub fn new(delivery_tag: u64, multiple: bool) -> Self {
                Ack {
                    delivery_tag: delivery_tag,
                    multiple: multiple,
                }
            }
            pub fn delivery_tag(&self) -> u64 {
                self.delivery_tag
            }
            pub fn multiple(&self) -> bool {
                self.multiple
            }
        }
        impl ::amqp0::Message for Ack {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                9
            }
        }

        // Class Modules
        pub struct Reject {
            delivery_tag: u64,
            requeue: bool,
        }
        impl Reject {
            pub fn new(delivery_tag: u64, requeue: bool) -> Self {
                Reject {
                    delivery_tag: delivery_tag,
                    requeue: requeue,
                }
            }
            pub fn delivery_tag(&self) -> u64 {
                self.delivery_tag
            }
            pub fn requeue(&self) -> bool {
                self.requeue
            }
        }
        impl ::amqp0::Message for Reject {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                9
            }
        }

        // Class Modules
        pub struct RecoverAsync {
            requeue: bool,
        }
        impl RecoverAsync {
            pub fn new(requeue: bool) -> Self {
                RecoverAsync { requeue: requeue }
            }
            pub fn requeue(&self) -> bool {
                self.requeue
            }
        }
        impl ::amqp0::Message for RecoverAsync {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                1
            }
        }

        // Class Modules
        pub struct Recover {
            requeue: bool,
        }
        impl Recover {
            pub fn new(requeue: bool) -> Self {
                Recover { requeue: requeue }
            }
            pub fn requeue(&self) -> bool {
                self.requeue
            }
        }
        impl ::amqp0::Message for Recover {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                1
            }
        }

        // Class Modules
        pub struct RecoverOk;
        impl RecoverOk {
            pub fn new() -> Self {
                RecoverOk
            }
        }
        impl ::amqp0::Message for RecoverOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Nack {
            delivery_tag: u64,
            multiple: bool,
            requeue: bool,
        }
        impl Nack {
            pub fn new(delivery_tag: u64, multiple: bool, requeue: bool) -> Self {
                Nack {
                    delivery_tag: delivery_tag,
                    multiple: multiple,
                    requeue: requeue,
                }
            }
            pub fn delivery_tag(&self) -> u64 {
                self.delivery_tag
            }
            pub fn multiple(&self) -> bool {
                self.multiple
            }
            pub fn requeue(&self) -> bool {
                self.requeue
            }
        }
        impl ::amqp0::Message for Nack {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                9
            }
        }
    }
    pub mod channel {

        // Class Modules
        pub struct Open;
        impl Open {
            pub fn new() -> Self {
                Open
            }
        }
        impl ::amqp0::Message for Open {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct OpenOk;
        impl OpenOk {
            pub fn new() -> Self {
                OpenOk
            }
        }
        impl ::amqp0::Message for OpenOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Flow {
            active: bool,
        }
        impl Flow {
            pub fn new(active: bool) -> Self {
                Flow { active: active }
            }
            pub fn active(&self) -> bool {
                self.active
            }
        }
        impl ::amqp0::Message for Flow {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                1
            }
        }

        // Class Modules
        pub struct FlowOk {
            active: bool,
        }
        impl FlowOk {
            pub fn new(active: bool) -> Self {
                FlowOk { active: active }
            }
            pub fn active(&self) -> bool {
                self.active
            }
        }
        impl ::amqp0::Message for FlowOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                1
            }
        }

        // Class Modules
        pub struct Close<'a> {
            reply_code: u16,
            reply_text: ::std::borrow::Cow<'a, str>,
            class_id: u16,
            method_id: u16,
        }
        impl<'a> Close<'a> {
            pub fn new<R>(reply_code: u16, reply_text: R, class_id: u16, method_id: u16) -> Self
                where R: Into<::std::borrow::Cow<'a, str>>
            {
                Close {
                    reply_code: reply_code,
                    reply_text: reply_text.into(),
                    class_id: class_id,
                    method_id: method_id,
                }
            }
            pub fn reply_code(&self) -> u16 {
                self.reply_code
            }
            pub fn reply_text(&self) -> &str {
                &*self.reply_text
            }
            pub fn class_id(&self) -> u16 {
                self.class_id
            }
            pub fn method_id(&self) -> u16 {
                self.method_id
            }
        }
        impl<'a> ::amqp0::Message for Close<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [7, self.reply_text.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct CloseOk;
        impl CloseOk {
            pub fn new() -> Self {
                CloseOk
            }
        }
        impl ::amqp0::Message for CloseOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }
    }
    pub mod confirm {

        // Class Modules
        pub struct Select {
            nowait: bool,
        }
        impl Select {
            pub fn new(nowait: bool) -> Self {
                Select { nowait: nowait }
            }
            pub fn nowait(&self) -> bool {
                self.nowait
            }
        }
        impl ::amqp0::Message for Select {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                1
            }
        }

        // Class Modules
        pub struct SelectOk;
        impl SelectOk {
            pub fn new() -> Self {
                SelectOk
            }
        }
        impl ::amqp0::Message for SelectOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }
    }
    pub mod connection {

        // Class Modules
        pub struct Start<'a> {
            version_major: u8,
            version_minor: u8,
            server_properties: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
            mechanisms: ::std::borrow::Cow<'a, [u8]>,
            locales: ::std::borrow::Cow<'a, [u8]>,
        }
        impl<'a> Start<'a> {
            pub fn new<L, M, S>(version_major: u8,
                                version_minor: u8,
                                server_properties: S,
                                mechanisms: M,
                                locales: L)
                                -> Self
                where S: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>,
                      M: Into<::std::borrow::Cow<'a, [u8]>>,
                      L: Into<::std::borrow::Cow<'a, [u8]>>
            {
                Start {
                    version_major: version_major,
                    version_minor: version_minor,
                    server_properties: server_properties.into(),
                    mechanisms: mechanisms.into(),
                    locales: locales.into(),
                }
            }
            pub fn version_major(&self) -> u8 {
                self.version_major
            }
            pub fn version_minor(&self) -> u8 {
                self.version_minor
            }
            pub fn server_properties(&self) -> &::amqp0::value::Table {
                &*self.server_properties
            }
            pub fn mechanisms(&self) -> &[u8] {
                &*self.mechanisms
            }
            pub fn locales(&self) -> &[u8] {
                &*self.locales
            }
        }
        impl<'a> ::amqp0::Message for Start<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [6, self.server_properties.amqp_size(), self.mechanisms.len(), self.locales.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct StartOk<'a> {
            client_properties: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
            mechanism: ::std::borrow::Cow<'a, str>,
            response: ::std::borrow::Cow<'a, [u8]>,
            locale: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> StartOk<'a> {
            pub fn new<C, L, M, R>(client_properties: C,
                                   mechanism: M,
                                   response: R,
                                   locale: L)
                                   -> Self
                where C: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>,
                      M: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, [u8]>>,
                      L: Into<::std::borrow::Cow<'a, str>>
            {
                StartOk {
                    client_properties: client_properties.into(),
                    mechanism: mechanism.into(),
                    response: response.into(),
                    locale: locale.into(),
                }
            }
            pub fn client_properties(&self) -> &::amqp0::value::Table {
                &*self.client_properties
            }
            pub fn mechanism(&self) -> &str {
                &*self.mechanism
            }
            pub fn response(&self) -> &[u8] {
                &*self.response
            }
            pub fn locale(&self) -> &str {
                &*self.locale
            }
        }
        impl<'a> ::amqp0::Message for StartOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [4,
                 self.client_properties.amqp_size(),
                 self.mechanism.len(),
                 self.response.len(),
                 self.locale.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Secure<'a> {
            challenge: ::std::borrow::Cow<'a, [u8]>,
        }
        impl<'a> Secure<'a> {
            pub fn new<C>(challenge: C) -> Self
                where C: Into<::std::borrow::Cow<'a, [u8]>>
            {
                Secure { challenge: challenge.into() }
            }
            pub fn challenge(&self) -> &[u8] {
                &*self.challenge
            }
        }
        impl<'a> ::amqp0::Message for Secure<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.challenge.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct SecureOk<'a> {
            response: ::std::borrow::Cow<'a, [u8]>,
        }
        impl<'a> SecureOk<'a> {
            pub fn new<R>(response: R) -> Self
                where R: Into<::std::borrow::Cow<'a, [u8]>>
            {
                SecureOk { response: response.into() }
            }
            pub fn response(&self) -> &[u8] {
                &*self.response
            }
        }
        impl<'a> ::amqp0::Message for SecureOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.response.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Tune {
            channel_max: u16,
            frame_max: u32,
            heartbeat: u16,
        }
        impl Tune {
            pub fn new(channel_max: u16, frame_max: u32, heartbeat: u16) -> Self {
                Tune {
                    channel_max: channel_max,
                    frame_max: frame_max,
                    heartbeat: heartbeat,
                }
            }
            pub fn channel_max(&self) -> u16 {
                self.channel_max
            }
            pub fn frame_max(&self) -> u32 {
                self.frame_max
            }
            pub fn heartbeat(&self) -> u16 {
                self.heartbeat
            }
        }
        impl ::amqp0::Message for Tune {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                8
            }
        }

        // Class Modules
        pub struct TuneOk {
            channel_max: u16,
            frame_max: u32,
            heartbeat: u16,
        }
        impl TuneOk {
            pub fn new(channel_max: u16, frame_max: u32, heartbeat: u16) -> Self {
                TuneOk {
                    channel_max: channel_max,
                    frame_max: frame_max,
                    heartbeat: heartbeat,
                }
            }
            pub fn channel_max(&self) -> u16 {
                self.channel_max
            }
            pub fn frame_max(&self) -> u32 {
                self.frame_max
            }
            pub fn heartbeat(&self) -> u16 {
                self.heartbeat
            }
        }
        impl ::amqp0::Message for TuneOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                8
            }
        }

        // Class Modules
        pub struct Open<'a> {
            virtual_host: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Open<'a> {
            pub fn new<V>(virtual_host: V) -> Self
                where V: Into<::std::borrow::Cow<'a, str>>
            {
                Open { virtual_host: virtual_host.into() }
            }
            pub fn virtual_host(&self) -> &str {
                &*self.virtual_host
            }
        }
        impl<'a> ::amqp0::Message for Open<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [1, self.virtual_host.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct OpenOk;
        impl OpenOk {
            pub fn new() -> Self {
                OpenOk
            }
        }
        impl ::amqp0::Message for OpenOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Close<'a> {
            reply_code: u16,
            reply_text: ::std::borrow::Cow<'a, str>,
            class_id: u16,
            method_id: u16,
        }
        impl<'a> Close<'a> {
            pub fn new<R>(reply_code: u16, reply_text: R, class_id: u16, method_id: u16) -> Self
                where R: Into<::std::borrow::Cow<'a, str>>
            {
                Close {
                    reply_code: reply_code,
                    reply_text: reply_text.into(),
                    class_id: class_id,
                    method_id: method_id,
                }
            }
            pub fn reply_code(&self) -> u16 {
                self.reply_code
            }
            pub fn reply_text(&self) -> &str {
                &*self.reply_text
            }
            pub fn class_id(&self) -> u16 {
                self.class_id
            }
            pub fn method_id(&self) -> u16 {
                self.method_id
            }
        }
        impl<'a> ::amqp0::Message for Close<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [7, self.reply_text.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct CloseOk;
        impl CloseOk {
            pub fn new() -> Self {
                CloseOk
            }
        }
        impl ::amqp0::Message for CloseOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Blocked<'a> {
            reason: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Blocked<'a> {
            pub fn new<R>(reason: R) -> Self
                where R: Into<::std::borrow::Cow<'a, str>>
            {
                Blocked { reason: reason.into() }
            }
            pub fn reason(&self) -> &str {
                &*self.reason
            }
        }
        impl<'a> ::amqp0::Message for Blocked<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [1, self.reason.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Unblocked;
        impl Unblocked {
            pub fn new() -> Self {
                Unblocked
            }
        }
        impl ::amqp0::Message for Unblocked {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }
    }
    pub mod exchange {

        // Class Modules
        pub struct Declare<'a> {
            exchange: ::std::borrow::Cow<'a, str>,
            ty: ::std::borrow::Cow<'a, str>,
            passive: bool,
            durable: bool,
            auto_delete: bool,
            internal: bool,
            no_wait: bool,
            arguments: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
        }
        impl<'a> Declare<'a> {
            pub fn new<A, E, T>(exchange: E,
                                ty: T,
                                passive: bool,
                                durable: bool,
                                auto_delete: bool,
                                internal: bool,
                                no_wait: bool,
                                arguments: A)
                                -> Self
                where E: Into<::std::borrow::Cow<'a, str>>,
                      T: Into<::std::borrow::Cow<'a, str>>,
                      A: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>
            {
                Declare {
                    exchange: exchange.into(),
                    ty: ty.into(),
                    passive: passive,
                    durable: durable,
                    auto_delete: auto_delete,
                    internal: internal,
                    no_wait: no_wait,
                    arguments: arguments.into(),
                }
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn ty(&self) -> &str {
                &*self.ty
            }
            pub fn passive(&self) -> bool {
                self.passive
            }
            pub fn durable(&self) -> bool {
                self.durable
            }
            pub fn auto_delete(&self) -> bool {
                self.auto_delete
            }
            pub fn internal(&self) -> bool {
                self.internal
            }
            pub fn no_wait(&self) -> bool {
                self.no_wait
            }
            pub fn arguments(&self) -> &::amqp0::value::Table {
                &*self.arguments
            }
        }
        impl<'a> ::amqp0::Message for Declare<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [3, self.exchange.len(), self.ty.len(), self.arguments.amqp_size()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct DeclareOk;
        impl DeclareOk {
            pub fn new() -> Self {
                DeclareOk
            }
        }
        impl ::amqp0::Message for DeclareOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Delete<'a> {
            exchange: ::std::borrow::Cow<'a, str>,
            if_unused: bool,
            no_wait: bool,
        }
        impl<'a> Delete<'a> {
            pub fn new<E>(exchange: E, if_unused: bool, no_wait: bool) -> Self
                where E: Into<::std::borrow::Cow<'a, str>>
            {
                Delete {
                    exchange: exchange.into(),
                    if_unused: if_unused,
                    no_wait: no_wait,
                }
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn if_unused(&self) -> bool {
                self.if_unused
            }
            pub fn no_wait(&self) -> bool {
                self.no_wait
            }
        }
        impl<'a> ::amqp0::Message for Delete<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.exchange.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct DeleteOk;
        impl DeleteOk {
            pub fn new() -> Self {
                DeleteOk
            }
        }
        impl ::amqp0::Message for DeleteOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Bind<'a> {
            destination: ::std::borrow::Cow<'a, str>,
            source: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
            no_wait: bool,
            arguments: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
        }
        impl<'a> Bind<'a> {
            pub fn new<A, D, R, S>(destination: D,
                                   source: S,
                                   routing_key: R,
                                   no_wait: bool,
                                   arguments: A)
                                   -> Self
                where D: Into<::std::borrow::Cow<'a, str>>,
                      S: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, str>>,
                      A: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>
            {
                Bind {
                    destination: destination.into(),
                    source: source.into(),
                    routing_key: routing_key.into(),
                    no_wait: no_wait,
                    arguments: arguments.into(),
                }
            }
            pub fn destination(&self) -> &str {
                &*self.destination
            }
            pub fn source(&self) -> &str {
                &*self.source
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
            pub fn no_wait(&self) -> bool {
                self.no_wait
            }
            pub fn arguments(&self) -> &::amqp0::value::Table {
                &*self.arguments
            }
        }
        impl<'a> ::amqp0::Message for Bind<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [4,
                 self.destination.len(),
                 self.source.len(),
                 self.routing_key.len(),
                 self.arguments.amqp_size()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct BindOk;
        impl BindOk {
            pub fn new() -> Self {
                BindOk
            }
        }
        impl ::amqp0::Message for BindOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Unbind<'a> {
            destination: ::std::borrow::Cow<'a, str>,
            source: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
            no_wait: bool,
            arguments: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
        }
        impl<'a> Unbind<'a> {
            pub fn new<A, D, R, S>(destination: D,
                                   source: S,
                                   routing_key: R,
                                   no_wait: bool,
                                   arguments: A)
                                   -> Self
                where D: Into<::std::borrow::Cow<'a, str>>,
                      S: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, str>>,
                      A: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>
            {
                Unbind {
                    destination: destination.into(),
                    source: source.into(),
                    routing_key: routing_key.into(),
                    no_wait: no_wait,
                    arguments: arguments.into(),
                }
            }
            pub fn destination(&self) -> &str {
                &*self.destination
            }
            pub fn source(&self) -> &str {
                &*self.source
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
            pub fn no_wait(&self) -> bool {
                self.no_wait
            }
            pub fn arguments(&self) -> &::amqp0::value::Table {
                &*self.arguments
            }
        }
        impl<'a> ::amqp0::Message for Unbind<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [4,
                 self.destination.len(),
                 self.source.len(),
                 self.routing_key.len(),
                 self.arguments.amqp_size()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct UnbindOk;
        impl UnbindOk {
            pub fn new() -> Self {
                UnbindOk
            }
        }
        impl ::amqp0::Message for UnbindOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }
    }
    pub mod queue {

        // Class Modules
        pub struct Declare<'a> {
            queue: ::std::borrow::Cow<'a, str>,
            passive: bool,
            durable: bool,
            exclusive: bool,
            auto_delete: bool,
            no_wait: bool,
            arguments: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
        }
        impl<'a> Declare<'a> {
            pub fn new<A, Q>(queue: Q,
                             passive: bool,
                             durable: bool,
                             exclusive: bool,
                             auto_delete: bool,
                             no_wait: bool,
                             arguments: A)
                             -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>,
                      A: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>
            {
                Declare {
                    queue: queue.into(),
                    passive: passive,
                    durable: durable,
                    exclusive: exclusive,
                    auto_delete: auto_delete,
                    no_wait: no_wait,
                    arguments: arguments.into(),
                }
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn passive(&self) -> bool {
                self.passive
            }
            pub fn durable(&self) -> bool {
                self.durable
            }
            pub fn exclusive(&self) -> bool {
                self.exclusive
            }
            pub fn auto_delete(&self) -> bool {
                self.auto_delete
            }
            pub fn no_wait(&self) -> bool {
                self.no_wait
            }
            pub fn arguments(&self) -> &::amqp0::value::Table {
                &*self.arguments
            }
        }
        impl<'a> ::amqp0::Message for Declare<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.queue.len(), self.arguments.amqp_size()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct DeclareOk<'a> {
            queue: ::std::borrow::Cow<'a, str>,
            message_count: u32,
            consumer_count: u32,
        }
        impl<'a> DeclareOk<'a> {
            pub fn new<Q>(queue: Q, message_count: u32, consumer_count: u32) -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>
            {
                DeclareOk {
                    queue: queue.into(),
                    message_count: message_count,
                    consumer_count: consumer_count,
                }
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn message_count(&self) -> u32 {
                self.message_count
            }
            pub fn consumer_count(&self) -> u32 {
                self.consumer_count
            }
        }
        impl<'a> ::amqp0::Message for DeclareOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [9, self.queue.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Bind<'a> {
            queue: ::std::borrow::Cow<'a, str>,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
            no_wait: bool,
            arguments: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
        }
        impl<'a> Bind<'a> {
            pub fn new<A, E, Q, R>(queue: Q,
                                   exchange: E,
                                   routing_key: R,
                                   no_wait: bool,
                                   arguments: A)
                                   -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>,
                      E: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, str>>,
                      A: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>
            {
                Bind {
                    queue: queue.into(),
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                    no_wait: no_wait,
                    arguments: arguments.into(),
                }
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
            pub fn no_wait(&self) -> bool {
                self.no_wait
            }
            pub fn arguments(&self) -> &::amqp0::value::Table {
                &*self.arguments
            }
        }
        impl<'a> ::amqp0::Message for Bind<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [4,
                 self.queue.len(),
                 self.exchange.len(),
                 self.routing_key.len(),
                 self.arguments.amqp_size()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct BindOk;
        impl BindOk {
            pub fn new() -> Self {
                BindOk
            }
        }
        impl ::amqp0::Message for BindOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Unbind<'a> {
            queue: ::std::borrow::Cow<'a, str>,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
            arguments: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
        }
        impl<'a> Unbind<'a> {
            pub fn new<A, E, Q, R>(queue: Q, exchange: E, routing_key: R, arguments: A) -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>,
                      E: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, str>>,
                      A: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>
            {
                Unbind {
                    queue: queue.into(),
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                    arguments: arguments.into(),
                }
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
            pub fn arguments(&self) -> &::amqp0::value::Table {
                &*self.arguments
            }
        }
        impl<'a> ::amqp0::Message for Unbind<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [3,
                 self.queue.len(),
                 self.exchange.len(),
                 self.routing_key.len(),
                 self.arguments.amqp_size()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct UnbindOk;
        impl UnbindOk {
            pub fn new() -> Self {
                UnbindOk
            }
        }
        impl ::amqp0::Message for UnbindOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Purge<'a> {
            queue: ::std::borrow::Cow<'a, str>,
            no_wait: bool,
        }
        impl<'a> Purge<'a> {
            pub fn new<Q>(queue: Q, no_wait: bool) -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>
            {
                Purge {
                    queue: queue.into(),
                    no_wait: no_wait,
                }
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn no_wait(&self) -> bool {
                self.no_wait
            }
        }
        impl<'a> ::amqp0::Message for Purge<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.queue.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct PurgeOk {
            message_count: u32,
        }
        impl PurgeOk {
            pub fn new(message_count: u32) -> Self {
                PurgeOk { message_count: message_count }
            }
            pub fn message_count(&self) -> u32 {
                self.message_count
            }
        }
        impl ::amqp0::Message for PurgeOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                4
            }
        }

        // Class Modules
        pub struct Delete<'a> {
            queue: ::std::borrow::Cow<'a, str>,
            if_unused: bool,
            if_empty: bool,
            no_wait: bool,
        }
        impl<'a> Delete<'a> {
            pub fn new<Q>(queue: Q, if_unused: bool, if_empty: bool, no_wait: bool) -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>
            {
                Delete {
                    queue: queue.into(),
                    if_unused: if_unused,
                    if_empty: if_empty,
                    no_wait: no_wait,
                }
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn if_unused(&self) -> bool {
                self.if_unused
            }
            pub fn if_empty(&self) -> bool {
                self.if_empty
            }
            pub fn no_wait(&self) -> bool {
                self.no_wait
            }
        }
        impl<'a> ::amqp0::Message for Delete<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.queue.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct DeleteOk {
            message_count: u32,
        }
        impl DeleteOk {
            pub fn new(message_count: u32) -> Self {
                DeleteOk { message_count: message_count }
            }
            pub fn message_count(&self) -> u32 {
                self.message_count
            }
        }
        impl ::amqp0::Message for DeleteOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                4
            }
        }
    }
    pub mod tx {

        // Class Modules
        pub struct Select;
        impl Select {
            pub fn new() -> Self {
                Select
            }
        }
        impl ::amqp0::Message for Select {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct SelectOk;
        impl SelectOk {
            pub fn new() -> Self {
                SelectOk
            }
        }
        impl ::amqp0::Message for SelectOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Commit;
        impl Commit {
            pub fn new() -> Self {
                Commit
            }
        }
        impl ::amqp0::Message for Commit {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct CommitOk;
        impl CommitOk {
            pub fn new() -> Self {
                CommitOk
            }
        }
        impl ::amqp0::Message for CommitOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Rollback;
        impl Rollback {
            pub fn new() -> Self {
                Rollback
            }
        }
        impl ::amqp0::Message for Rollback {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct RollbackOk;
        impl RollbackOk {
            pub fn new() -> Self {
                RollbackOk
            }
        }
        impl ::amqp0::Message for RollbackOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }
    }
}

#[allow(non_camel_case_types)]
pub struct Rabbitmq9_1;
impl Spec for Rabbitmq9_1 {}

pub mod qpid9_0 {
    // Class Constants
    pub const CLASS_ACCESS: u16 = 30;
    pub const CLASS_BASIC: u16 = 60;
    pub const CLASS_CHANNEL: u16 = 20;
    pub const CLASS_CONNECTION: u16 = 10;
    pub const CLASS_DTX: u16 = 100;
    pub const CLASS_EXCHANGE: u16 = 40;
    pub const CLASS_FILE: u16 = 70;
    pub const CLASS_MESSAGE: u16 = 120;
    pub const CLASS_QUEUE: u16 = 50;
    pub const CLASS_STREAM: u16 = 80;
    pub const CLASS_TUNNEL: u16 = 110;
    pub const CLASS_TX: u16 = 90;

    // Class Methods
    pub const METHOD_ACCESS_REQUEST: u16 = 10;
    pub const METHOD_ACCESS_REQUEST_OK: u16 = 11;

    pub const METHOD_BASIC_QOS: u16 = 10;
    pub const METHOD_BASIC_QOS_OK: u16 = 11;
    pub const METHOD_BASIC_CONSUME: u16 = 20;
    pub const METHOD_BASIC_CONSUME_OK: u16 = 21;
    pub const METHOD_BASIC_CANCEL: u16 = 30;
    pub const METHOD_BASIC_CANCEL_OK: u16 = 31;
    pub const METHOD_BASIC_PUBLISH: u16 = 40;
    pub const METHOD_BASIC_RETURN: u16 = 50;
    pub const METHOD_BASIC_DELIVER: u16 = 60;
    pub const METHOD_BASIC_GET: u16 = 70;
    pub const METHOD_BASIC_GET_OK: u16 = 71;
    pub const METHOD_BASIC_GET_EMPTY: u16 = 72;
    pub const METHOD_BASIC_ACK: u16 = 80;
    pub const METHOD_BASIC_REJECT: u16 = 90;
    pub const METHOD_BASIC_RECOVER: u16 = 100;
    pub const METHOD_BASIC_RECOVER_SYNC: u16 = 102;
    pub const METHOD_BASIC_RECOVER_SYNC_OK: u16 = 101;

    pub const METHOD_CHANNEL_OPEN: u16 = 10;
    pub const METHOD_CHANNEL_OPEN_OK: u16 = 11;
    pub const METHOD_CHANNEL_FLOW: u16 = 20;
    pub const METHOD_CHANNEL_FLOW_OK: u16 = 21;
    pub const METHOD_CHANNEL_CLOSE: u16 = 40;
    pub const METHOD_CHANNEL_CLOSE_OK: u16 = 41;
    pub const METHOD_CHANNEL_RESUME: u16 = 50;
    pub const METHOD_CHANNEL_PING: u16 = 60;
    pub const METHOD_CHANNEL_PONG: u16 = 70;
    pub const METHOD_CHANNEL_OK: u16 = 80;

    pub const METHOD_CONNECTION_START: u16 = 10;
    pub const METHOD_CONNECTION_START_OK: u16 = 11;
    pub const METHOD_CONNECTION_SECURE: u16 = 20;
    pub const METHOD_CONNECTION_SECURE_OK: u16 = 21;
    pub const METHOD_CONNECTION_TUNE: u16 = 30;
    pub const METHOD_CONNECTION_TUNE_OK: u16 = 31;
    pub const METHOD_CONNECTION_OPEN: u16 = 40;
    pub const METHOD_CONNECTION_OPEN_OK: u16 = 41;
    pub const METHOD_CONNECTION_REDIRECT: u16 = 42;
    pub const METHOD_CONNECTION_CLOSE: u16 = 50;
    pub const METHOD_CONNECTION_CLOSE_OK: u16 = 51;

    pub const METHOD_DTX_SELECT: u16 = 10;
    pub const METHOD_DTX_SELECT_OK: u16 = 11;
    pub const METHOD_DTX_START: u16 = 20;
    pub const METHOD_DTX_START_OK: u16 = 21;

    pub const METHOD_EXCHANGE_DECLARE: u16 = 10;
    pub const METHOD_EXCHANGE_DECLARE_OK: u16 = 11;
    pub const METHOD_EXCHANGE_DELETE: u16 = 20;
    pub const METHOD_EXCHANGE_DELETE_OK: u16 = 21;
    pub const METHOD_EXCHANGE_BOUND: u16 = 22;
    pub const METHOD_EXCHANGE_BOUND_OK: u16 = 23;

    pub const METHOD_FILE_QOS: u16 = 10;
    pub const METHOD_FILE_QOS_OK: u16 = 11;
    pub const METHOD_FILE_CONSUME: u16 = 20;
    pub const METHOD_FILE_CONSUME_OK: u16 = 21;
    pub const METHOD_FILE_CANCEL: u16 = 30;
    pub const METHOD_FILE_CANCEL_OK: u16 = 31;
    pub const METHOD_FILE_OPEN: u16 = 40;
    pub const METHOD_FILE_OPEN_OK: u16 = 41;
    pub const METHOD_FILE_STAGE: u16 = 50;
    pub const METHOD_FILE_PUBLISH: u16 = 60;
    pub const METHOD_FILE_RETURN: u16 = 70;
    pub const METHOD_FILE_DELIVER: u16 = 80;
    pub const METHOD_FILE_ACK: u16 = 90;
    pub const METHOD_FILE_REJECT: u16 = 100;

    pub const METHOD_MESSAGE_TRANSFER: u16 = 10;
    pub const METHOD_MESSAGE_CONSUME: u16 = 20;
    pub const METHOD_MESSAGE_CANCEL: u16 = 30;
    pub const METHOD_MESSAGE_GET: u16 = 40;
    pub const METHOD_MESSAGE_RECOVER: u16 = 50;
    pub const METHOD_MESSAGE_OPEN: u16 = 60;
    pub const METHOD_MESSAGE_CLOSE: u16 = 70;
    pub const METHOD_MESSAGE_APPEND: u16 = 80;
    pub const METHOD_MESSAGE_CHECKPOINT: u16 = 90;
    pub const METHOD_MESSAGE_RESUME: u16 = 100;
    pub const METHOD_MESSAGE_QOS: u16 = 110;
    pub const METHOD_MESSAGE_OK: u16 = 500;
    pub const METHOD_MESSAGE_EMPTY: u16 = 510;
    pub const METHOD_MESSAGE_REJECT: u16 = 520;
    pub const METHOD_MESSAGE_OFFSET: u16 = 530;

    pub const METHOD_QUEUE_DECLARE: u16 = 10;
    pub const METHOD_QUEUE_DECLARE_OK: u16 = 11;
    pub const METHOD_QUEUE_BIND: u16 = 20;
    pub const METHOD_QUEUE_BIND_OK: u16 = 21;
    pub const METHOD_QUEUE_UNBIND: u16 = 50;
    pub const METHOD_QUEUE_UNBIND_OK: u16 = 51;
    pub const METHOD_QUEUE_PURGE: u16 = 30;
    pub const METHOD_QUEUE_PURGE_OK: u16 = 31;
    pub const METHOD_QUEUE_DELETE: u16 = 40;
    pub const METHOD_QUEUE_DELETE_OK: u16 = 41;

    pub const METHOD_STREAM_QOS: u16 = 10;
    pub const METHOD_STREAM_QOS_OK: u16 = 11;
    pub const METHOD_STREAM_CONSUME: u16 = 20;
    pub const METHOD_STREAM_CONSUME_OK: u16 = 21;
    pub const METHOD_STREAM_CANCEL: u16 = 30;
    pub const METHOD_STREAM_CANCEL_OK: u16 = 31;
    pub const METHOD_STREAM_PUBLISH: u16 = 40;
    pub const METHOD_STREAM_RETURN: u16 = 50;
    pub const METHOD_STREAM_DELIVER: u16 = 60;

    pub const METHOD_TUNNEL_REQUEST: u16 = 10;

    pub const METHOD_TX_SELECT: u16 = 10;
    pub const METHOD_TX_SELECT_OK: u16 = 11;
    pub const METHOD_TX_COMMIT: u16 = 20;
    pub const METHOD_TX_COMMIT_OK: u16 = 21;
    pub const METHOD_TX_ROLLBACK: u16 = 30;
    pub const METHOD_TX_ROLLBACK_OK: u16 = 31;
    pub mod access {

        // Class Modules
        pub struct Request<'a> {
            realm: ::std::borrow::Cow<'a, str>,
            exclusive: bool,
            passive: bool,
            active: bool,
            write: bool,
            read: bool,
        }
        impl<'a> Request<'a> {
            pub fn new<R>(realm: R,
                          exclusive: bool,
                          passive: bool,
                          active: bool,
                          write: bool,
                          read: bool)
                          -> Self
                where R: Into<::std::borrow::Cow<'a, str>>
            {
                Request {
                    realm: realm.into(),
                    exclusive: exclusive,
                    passive: passive,
                    active: active,
                    write: write,
                    read: read,
                }
            }
            pub fn realm(&self) -> &str {
                &*self.realm
            }
            pub fn exclusive(&self) -> bool {
                self.exclusive
            }
            pub fn passive(&self) -> bool {
                self.passive
            }
            pub fn active(&self) -> bool {
                self.active
            }
            pub fn write(&self) -> bool {
                self.write
            }
            pub fn read(&self) -> bool {
                self.read
            }
        }
        impl<'a> ::amqp0::Message for Request<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.realm.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct RequestOk {
            ticket: u16,
        }
        impl RequestOk {
            pub fn new(ticket: u16) -> Self {
                RequestOk { ticket: ticket }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
        }
        impl ::amqp0::Message for RequestOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                2
            }
        }
    }
    pub mod basic {

        // Class Modules
        pub struct Qos {
            prefetch_size: u32,
            prefetch_count: u16,
            global: bool,
        }
        impl Qos {
            pub fn new(prefetch_size: u32, prefetch_count: u16, global: bool) -> Self {
                Qos {
                    prefetch_size: prefetch_size,
                    prefetch_count: prefetch_count,
                    global: global,
                }
            }
            pub fn prefetch_size(&self) -> u32 {
                self.prefetch_size
            }
            pub fn prefetch_count(&self) -> u16 {
                self.prefetch_count
            }
            pub fn global(&self) -> bool {
                self.global
            }
        }
        impl ::amqp0::Message for Qos {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                7
            }
        }

        // Class Modules
        pub struct QosOk;
        impl QosOk {
            pub fn new() -> Self {
                QosOk
            }
        }
        impl ::amqp0::Message for QosOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Consume<'a> {
            ticket: u16,
            queue: ::std::borrow::Cow<'a, str>,
            consumer_tag: ::std::borrow::Cow<'a, str>,
            no_local: bool,
            no_ack: bool,
            exclusive: bool,
            nowait: bool,
            arguments: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
        }
        impl<'a> Consume<'a> {
            pub fn new<A, C, Q>(ticket: u16,
                                queue: Q,
                                consumer_tag: C,
                                no_local: bool,
                                no_ack: bool,
                                exclusive: bool,
                                nowait: bool,
                                arguments: A)
                                -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>,
                      C: Into<::std::borrow::Cow<'a, str>>,
                      A: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>
            {
                Consume {
                    ticket: ticket,
                    queue: queue.into(),
                    consumer_tag: consumer_tag.into(),
                    no_local: no_local,
                    no_ack: no_ack,
                    exclusive: exclusive,
                    nowait: nowait,
                    arguments: arguments.into(),
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
            pub fn no_local(&self) -> bool {
                self.no_local
            }
            pub fn no_ack(&self) -> bool {
                self.no_ack
            }
            pub fn exclusive(&self) -> bool {
                self.exclusive
            }
            pub fn nowait(&self) -> bool {
                self.nowait
            }
            pub fn arguments(&self) -> &::amqp0::value::Table {
                &*self.arguments
            }
        }
        impl<'a> ::amqp0::Message for Consume<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [5, self.queue.len(), self.consumer_tag.len(), self.arguments.amqp_size()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct ConsumeOk<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> ConsumeOk<'a> {
            pub fn new<C>(consumer_tag: C) -> Self
                where C: Into<::std::borrow::Cow<'a, str>>
            {
                ConsumeOk { consumer_tag: consumer_tag.into() }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
        }
        impl<'a> ::amqp0::Message for ConsumeOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [1, self.consumer_tag.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Cancel<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
            nowait: bool,
        }
        impl<'a> Cancel<'a> {
            pub fn new<C>(consumer_tag: C, nowait: bool) -> Self
                where C: Into<::std::borrow::Cow<'a, str>>
            {
                Cancel {
                    consumer_tag: consumer_tag.into(),
                    nowait: nowait,
                }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
            pub fn nowait(&self) -> bool {
                self.nowait
            }
        }
        impl<'a> ::amqp0::Message for Cancel<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.consumer_tag.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct CancelOk<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> CancelOk<'a> {
            pub fn new<C>(consumer_tag: C) -> Self
                where C: Into<::std::borrow::Cow<'a, str>>
            {
                CancelOk { consumer_tag: consumer_tag.into() }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
        }
        impl<'a> ::amqp0::Message for CancelOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [1, self.consumer_tag.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Publish<'a> {
            ticket: u16,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
            mandatory: bool,
            immediate: bool,
        }
        impl<'a> Publish<'a> {
            pub fn new<E, R>(ticket: u16,
                             exchange: E,
                             routing_key: R,
                             mandatory: bool,
                             immediate: bool)
                             -> Self
                where E: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, str>>
            {
                Publish {
                    ticket: ticket,
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                    mandatory: mandatory,
                    immediate: immediate,
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
            pub fn mandatory(&self) -> bool {
                self.mandatory
            }
            pub fn immediate(&self) -> bool {
                self.immediate
            }
        }
        impl<'a> ::amqp0::Message for Publish<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [5, self.exchange.len(), self.routing_key.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Return<'a> {
            reply_code: u16,
            reply_text: ::std::borrow::Cow<'a, str>,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Return<'a> {
            pub fn new<E, R, R0>(reply_code: u16,
                                 reply_text: R,
                                 exchange: E,
                                 routing_key: R0)
                                 -> Self
                where R: Into<::std::borrow::Cow<'a, str>>,
                      E: Into<::std::borrow::Cow<'a, str>>,
                      R0: Into<::std::borrow::Cow<'a, str>>
            {
                Return {
                    reply_code: reply_code,
                    reply_text: reply_text.into(),
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                }
            }
            pub fn reply_code(&self) -> u16 {
                self.reply_code
            }
            pub fn reply_text(&self) -> &str {
                &*self.reply_text
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
        }
        impl<'a> ::amqp0::Message for Return<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [5, self.reply_text.len(), self.exchange.len(), self.routing_key.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Deliver<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
            delivery_tag: u64,
            redelivered: bool,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Deliver<'a> {
            pub fn new<C, E, R>(consumer_tag: C,
                                delivery_tag: u64,
                                redelivered: bool,
                                exchange: E,
                                routing_key: R)
                                -> Self
                where C: Into<::std::borrow::Cow<'a, str>>,
                      E: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, str>>
            {
                Deliver {
                    consumer_tag: consumer_tag.into(),
                    delivery_tag: delivery_tag,
                    redelivered: redelivered,
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
            pub fn delivery_tag(&self) -> u64 {
                self.delivery_tag
            }
            pub fn redelivered(&self) -> bool {
                self.redelivered
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
        }
        impl<'a> ::amqp0::Message for Deliver<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [12, self.consumer_tag.len(), self.exchange.len(), self.routing_key.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Get<'a> {
            ticket: u16,
            queue: ::std::borrow::Cow<'a, str>,
            no_ack: bool,
        }
        impl<'a> Get<'a> {
            pub fn new<Q>(ticket: u16, queue: Q, no_ack: bool) -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>
            {
                Get {
                    ticket: ticket,
                    queue: queue.into(),
                    no_ack: no_ack,
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn no_ack(&self) -> bool {
                self.no_ack
            }
        }
        impl<'a> ::amqp0::Message for Get<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [4, self.queue.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct GetOk<'a> {
            delivery_tag: u64,
            redelivered: bool,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
            message_count: u32,
        }
        impl<'a> GetOk<'a> {
            pub fn new<E, R>(delivery_tag: u64,
                             redelivered: bool,
                             exchange: E,
                             routing_key: R,
                             message_count: u32)
                             -> Self
                where E: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, str>>
            {
                GetOk {
                    delivery_tag: delivery_tag,
                    redelivered: redelivered,
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                    message_count: message_count,
                }
            }
            pub fn delivery_tag(&self) -> u64 {
                self.delivery_tag
            }
            pub fn redelivered(&self) -> bool {
                self.redelivered
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
            pub fn message_count(&self) -> u32 {
                self.message_count
            }
        }
        impl<'a> ::amqp0::Message for GetOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [15, self.exchange.len(), self.routing_key.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct GetEmpty<'a> {
            cluster_id: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> GetEmpty<'a> {
            pub fn new<C>(cluster_id: C) -> Self
                where C: Into<::std::borrow::Cow<'a, str>>
            {
                GetEmpty { cluster_id: cluster_id.into() }
            }
            pub fn cluster_id(&self) -> &str {
                &*self.cluster_id
            }
        }
        impl<'a> ::amqp0::Message for GetEmpty<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [1, self.cluster_id.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Ack {
            delivery_tag: u64,
            multiple: bool,
        }
        impl Ack {
            pub fn new(delivery_tag: u64, multiple: bool) -> Self {
                Ack {
                    delivery_tag: delivery_tag,
                    multiple: multiple,
                }
            }
            pub fn delivery_tag(&self) -> u64 {
                self.delivery_tag
            }
            pub fn multiple(&self) -> bool {
                self.multiple
            }
        }
        impl ::amqp0::Message for Ack {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                9
            }
        }

        // Class Modules
        pub struct Reject {
            delivery_tag: u64,
            requeue: bool,
        }
        impl Reject {
            pub fn new(delivery_tag: u64, requeue: bool) -> Self {
                Reject {
                    delivery_tag: delivery_tag,
                    requeue: requeue,
                }
            }
            pub fn delivery_tag(&self) -> u64 {
                self.delivery_tag
            }
            pub fn requeue(&self) -> bool {
                self.requeue
            }
        }
        impl ::amqp0::Message for Reject {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                9
            }
        }

        // Class Modules
        pub struct Recover {
            requeue: bool,
        }
        impl Recover {
            pub fn new(requeue: bool) -> Self {
                Recover { requeue: requeue }
            }
            pub fn requeue(&self) -> bool {
                self.requeue
            }
        }
        impl ::amqp0::Message for Recover {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                1
            }
        }

        // Class Modules
        pub struct RecoverSync {
            requeue: bool,
        }
        impl RecoverSync {
            pub fn new(requeue: bool) -> Self {
                RecoverSync { requeue: requeue }
            }
            pub fn requeue(&self) -> bool {
                self.requeue
            }
        }
        impl ::amqp0::Message for RecoverSync {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                1
            }
        }

        // Class Modules
        pub struct RecoverSyncOk;
        impl RecoverSyncOk {
            pub fn new() -> Self {
                RecoverSyncOk
            }
        }
        impl ::amqp0::Message for RecoverSyncOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }
    }
    pub mod channel {

        // Class Modules
        pub struct Open<'a> {
            out_of_band: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Open<'a> {
            pub fn new<O>(out_of_band: O) -> Self
                where O: Into<::std::borrow::Cow<'a, str>>
            {
                Open { out_of_band: out_of_band.into() }
            }
            pub fn out_of_band(&self) -> &str {
                &*self.out_of_band
            }
        }
        impl<'a> ::amqp0::Message for Open<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [1, self.out_of_band.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct OpenOk<'a> {
            channel_id: ::std::borrow::Cow<'a, [u8]>,
        }
        impl<'a> OpenOk<'a> {
            pub fn new<C>(channel_id: C) -> Self
                where C: Into<::std::borrow::Cow<'a, [u8]>>
            {
                OpenOk { channel_id: channel_id.into() }
            }
            pub fn channel_id(&self) -> &[u8] {
                &*self.channel_id
            }
        }
        impl<'a> ::amqp0::Message for OpenOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.channel_id.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Flow {
            active: bool,
        }
        impl Flow {
            pub fn new(active: bool) -> Self {
                Flow { active: active }
            }
            pub fn active(&self) -> bool {
                self.active
            }
        }
        impl ::amqp0::Message for Flow {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                1
            }
        }

        // Class Modules
        pub struct FlowOk {
            active: bool,
        }
        impl FlowOk {
            pub fn new(active: bool) -> Self {
                FlowOk { active: active }
            }
            pub fn active(&self) -> bool {
                self.active
            }
        }
        impl ::amqp0::Message for FlowOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                1
            }
        }

        // Class Modules
        pub struct Close<'a> {
            reply_code: u16,
            reply_text: ::std::borrow::Cow<'a, str>,
            class_id: u16,
            method_id: u16,
        }
        impl<'a> Close<'a> {
            pub fn new<R>(reply_code: u16, reply_text: R, class_id: u16, method_id: u16) -> Self
                where R: Into<::std::borrow::Cow<'a, str>>
            {
                Close {
                    reply_code: reply_code,
                    reply_text: reply_text.into(),
                    class_id: class_id,
                    method_id: method_id,
                }
            }
            pub fn reply_code(&self) -> u16 {
                self.reply_code
            }
            pub fn reply_text(&self) -> &str {
                &*self.reply_text
            }
            pub fn class_id(&self) -> u16 {
                self.class_id
            }
            pub fn method_id(&self) -> u16 {
                self.method_id
            }
        }
        impl<'a> ::amqp0::Message for Close<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [7, self.reply_text.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct CloseOk;
        impl CloseOk {
            pub fn new() -> Self {
                CloseOk
            }
        }
        impl ::amqp0::Message for CloseOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Resume<'a> {
            channel_id: ::std::borrow::Cow<'a, [u8]>,
        }
        impl<'a> Resume<'a> {
            pub fn new<C>(channel_id: C) -> Self
                where C: Into<::std::borrow::Cow<'a, [u8]>>
            {
                Resume { channel_id: channel_id.into() }
            }
            pub fn channel_id(&self) -> &[u8] {
                &*self.channel_id
            }
        }
        impl<'a> ::amqp0::Message for Resume<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.channel_id.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Ping;
        impl Ping {
            pub fn new() -> Self {
                Ping
            }
        }
        impl ::amqp0::Message for Ping {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Pong;
        impl Pong {
            pub fn new() -> Self {
                Pong
            }
        }
        impl ::amqp0::Message for Pong {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Ok;
        impl Ok {
            pub fn new() -> Self {
                Ok
            }
        }
        impl ::amqp0::Message for Ok {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }
    }
    pub mod connection {

        // Class Modules
        pub struct Start<'a> {
            version_major: u8,
            version_minor: u8,
            server_properties: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
            mechanisms: ::std::borrow::Cow<'a, [u8]>,
            locales: ::std::borrow::Cow<'a, [u8]>,
        }
        impl<'a> Start<'a> {
            pub fn new<L, M, S>(version_major: u8,
                                version_minor: u8,
                                server_properties: S,
                                mechanisms: M,
                                locales: L)
                                -> Self
                where S: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>,
                      M: Into<::std::borrow::Cow<'a, [u8]>>,
                      L: Into<::std::borrow::Cow<'a, [u8]>>
            {
                Start {
                    version_major: version_major,
                    version_minor: version_minor,
                    server_properties: server_properties.into(),
                    mechanisms: mechanisms.into(),
                    locales: locales.into(),
                }
            }
            pub fn version_major(&self) -> u8 {
                self.version_major
            }
            pub fn version_minor(&self) -> u8 {
                self.version_minor
            }
            pub fn server_properties(&self) -> &::amqp0::value::Table {
                &*self.server_properties
            }
            pub fn mechanisms(&self) -> &[u8] {
                &*self.mechanisms
            }
            pub fn locales(&self) -> &[u8] {
                &*self.locales
            }
        }
        impl<'a> ::amqp0::Message for Start<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [6, self.server_properties.amqp_size(), self.mechanisms.len(), self.locales.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct StartOk<'a> {
            client_properties: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
            mechanism: ::std::borrow::Cow<'a, str>,
            response: ::std::borrow::Cow<'a, [u8]>,
            locale: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> StartOk<'a> {
            pub fn new<C, L, M, R>(client_properties: C,
                                   mechanism: M,
                                   response: R,
                                   locale: L)
                                   -> Self
                where C: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>,
                      M: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, [u8]>>,
                      L: Into<::std::borrow::Cow<'a, str>>
            {
                StartOk {
                    client_properties: client_properties.into(),
                    mechanism: mechanism.into(),
                    response: response.into(),
                    locale: locale.into(),
                }
            }
            pub fn client_properties(&self) -> &::amqp0::value::Table {
                &*self.client_properties
            }
            pub fn mechanism(&self) -> &str {
                &*self.mechanism
            }
            pub fn response(&self) -> &[u8] {
                &*self.response
            }
            pub fn locale(&self) -> &str {
                &*self.locale
            }
        }
        impl<'a> ::amqp0::Message for StartOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [4,
                 self.client_properties.amqp_size(),
                 self.mechanism.len(),
                 self.response.len(),
                 self.locale.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Secure<'a> {
            challenge: ::std::borrow::Cow<'a, [u8]>,
        }
        impl<'a> Secure<'a> {
            pub fn new<C>(challenge: C) -> Self
                where C: Into<::std::borrow::Cow<'a, [u8]>>
            {
                Secure { challenge: challenge.into() }
            }
            pub fn challenge(&self) -> &[u8] {
                &*self.challenge
            }
        }
        impl<'a> ::amqp0::Message for Secure<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.challenge.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct SecureOk<'a> {
            response: ::std::borrow::Cow<'a, [u8]>,
        }
        impl<'a> SecureOk<'a> {
            pub fn new<R>(response: R) -> Self
                where R: Into<::std::borrow::Cow<'a, [u8]>>
            {
                SecureOk { response: response.into() }
            }
            pub fn response(&self) -> &[u8] {
                &*self.response
            }
        }
        impl<'a> ::amqp0::Message for SecureOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.response.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Tune {
            channel_max: u16,
            frame_max: u32,
            heartbeat: u16,
        }
        impl Tune {
            pub fn new(channel_max: u16, frame_max: u32, heartbeat: u16) -> Self {
                Tune {
                    channel_max: channel_max,
                    frame_max: frame_max,
                    heartbeat: heartbeat,
                }
            }
            pub fn channel_max(&self) -> u16 {
                self.channel_max
            }
            pub fn frame_max(&self) -> u32 {
                self.frame_max
            }
            pub fn heartbeat(&self) -> u16 {
                self.heartbeat
            }
        }
        impl ::amqp0::Message for Tune {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                8
            }
        }

        // Class Modules
        pub struct TuneOk {
            channel_max: u16,
            frame_max: u32,
            heartbeat: u16,
        }
        impl TuneOk {
            pub fn new(channel_max: u16, frame_max: u32, heartbeat: u16) -> Self {
                TuneOk {
                    channel_max: channel_max,
                    frame_max: frame_max,
                    heartbeat: heartbeat,
                }
            }
            pub fn channel_max(&self) -> u16 {
                self.channel_max
            }
            pub fn frame_max(&self) -> u32 {
                self.frame_max
            }
            pub fn heartbeat(&self) -> u16 {
                self.heartbeat
            }
        }
        impl ::amqp0::Message for TuneOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                8
            }
        }

        // Class Modules
        pub struct Open<'a> {
            virtual_host: ::std::borrow::Cow<'a, str>,
            capabilities: ::std::borrow::Cow<'a, str>,
            insist: bool,
        }
        impl<'a> Open<'a> {
            pub fn new<C, V>(virtual_host: V, capabilities: C, insist: bool) -> Self
                where V: Into<::std::borrow::Cow<'a, str>>,
                      C: Into<::std::borrow::Cow<'a, str>>
            {
                Open {
                    virtual_host: virtual_host.into(),
                    capabilities: capabilities.into(),
                    insist: insist,
                }
            }
            pub fn virtual_host(&self) -> &str {
                &*self.virtual_host
            }
            pub fn capabilities(&self) -> &str {
                &*self.capabilities
            }
            pub fn insist(&self) -> bool {
                self.insist
            }
        }
        impl<'a> ::amqp0::Message for Open<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [3, self.virtual_host.len(), self.capabilities.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct OpenOk<'a> {
            known_hosts: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> OpenOk<'a> {
            pub fn new<K>(known_hosts: K) -> Self
                where K: Into<::std::borrow::Cow<'a, str>>
            {
                OpenOk { known_hosts: known_hosts.into() }
            }
            pub fn known_hosts(&self) -> &str {
                &*self.known_hosts
            }
        }
        impl<'a> ::amqp0::Message for OpenOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [1, self.known_hosts.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Redirect<'a> {
            host: ::std::borrow::Cow<'a, str>,
            known_hosts: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Redirect<'a> {
            pub fn new<H, K>(host: H, known_hosts: K) -> Self
                where H: Into<::std::borrow::Cow<'a, str>>,
                      K: Into<::std::borrow::Cow<'a, str>>
            {
                Redirect {
                    host: host.into(),
                    known_hosts: known_hosts.into(),
                }
            }
            pub fn host(&self) -> &str {
                &*self.host
            }
            pub fn known_hosts(&self) -> &str {
                &*self.known_hosts
            }
        }
        impl<'a> ::amqp0::Message for Redirect<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.host.len(), self.known_hosts.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Close<'a> {
            reply_code: u16,
            reply_text: ::std::borrow::Cow<'a, str>,
            class_id: u16,
            method_id: u16,
        }
        impl<'a> Close<'a> {
            pub fn new<R>(reply_code: u16, reply_text: R, class_id: u16, method_id: u16) -> Self
                where R: Into<::std::borrow::Cow<'a, str>>
            {
                Close {
                    reply_code: reply_code,
                    reply_text: reply_text.into(),
                    class_id: class_id,
                    method_id: method_id,
                }
            }
            pub fn reply_code(&self) -> u16 {
                self.reply_code
            }
            pub fn reply_text(&self) -> &str {
                &*self.reply_text
            }
            pub fn class_id(&self) -> u16 {
                self.class_id
            }
            pub fn method_id(&self) -> u16 {
                self.method_id
            }
        }
        impl<'a> ::amqp0::Message for Close<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [7, self.reply_text.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct CloseOk;
        impl CloseOk {
            pub fn new() -> Self {
                CloseOk
            }
        }
        impl ::amqp0::Message for CloseOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }
    }
    pub mod dtx {

        // Class Modules
        pub struct Select;
        impl Select {
            pub fn new() -> Self {
                Select
            }
        }
        impl ::amqp0::Message for Select {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct SelectOk;
        impl SelectOk {
            pub fn new() -> Self {
                SelectOk
            }
        }
        impl ::amqp0::Message for SelectOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Start<'a> {
            dtx_identifier: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Start<'a> {
            pub fn new<D>(dtx_identifier: D) -> Self
                where D: Into<::std::borrow::Cow<'a, str>>
            {
                Start { dtx_identifier: dtx_identifier.into() }
            }
            pub fn dtx_identifier(&self) -> &str {
                &*self.dtx_identifier
            }
        }
        impl<'a> ::amqp0::Message for Start<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [1, self.dtx_identifier.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct StartOk;
        impl StartOk {
            pub fn new() -> Self {
                StartOk
            }
        }
        impl ::amqp0::Message for StartOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }
    }
    pub mod exchange {

        // Class Modules
        pub struct Declare<'a> {
            ticket: u16,
            exchange: ::std::borrow::Cow<'a, str>,
            ty: ::std::borrow::Cow<'a, str>,
            passive: bool,
            durable: bool,
            auto_delete: bool,
            internal: bool,
            nowait: bool,
            arguments: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
        }
        impl<'a> Declare<'a> {
            pub fn new<A, E, T>(ticket: u16,
                                exchange: E,
                                ty: T,
                                passive: bool,
                                durable: bool,
                                auto_delete: bool,
                                internal: bool,
                                nowait: bool,
                                arguments: A)
                                -> Self
                where E: Into<::std::borrow::Cow<'a, str>>,
                      T: Into<::std::borrow::Cow<'a, str>>,
                      A: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>
            {
                Declare {
                    ticket: ticket,
                    exchange: exchange.into(),
                    ty: ty.into(),
                    passive: passive,
                    durable: durable,
                    auto_delete: auto_delete,
                    internal: internal,
                    nowait: nowait,
                    arguments: arguments.into(),
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn ty(&self) -> &str {
                &*self.ty
            }
            pub fn passive(&self) -> bool {
                self.passive
            }
            pub fn durable(&self) -> bool {
                self.durable
            }
            pub fn auto_delete(&self) -> bool {
                self.auto_delete
            }
            pub fn internal(&self) -> bool {
                self.internal
            }
            pub fn nowait(&self) -> bool {
                self.nowait
            }
            pub fn arguments(&self) -> &::amqp0::value::Table {
                &*self.arguments
            }
        }
        impl<'a> ::amqp0::Message for Declare<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [5, self.exchange.len(), self.ty.len(), self.arguments.amqp_size()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct DeclareOk;
        impl DeclareOk {
            pub fn new() -> Self {
                DeclareOk
            }
        }
        impl ::amqp0::Message for DeclareOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Delete<'a> {
            ticket: u16,
            exchange: ::std::borrow::Cow<'a, str>,
            if_unused: bool,
            nowait: bool,
        }
        impl<'a> Delete<'a> {
            pub fn new<E>(ticket: u16, exchange: E, if_unused: bool, nowait: bool) -> Self
                where E: Into<::std::borrow::Cow<'a, str>>
            {
                Delete {
                    ticket: ticket,
                    exchange: exchange.into(),
                    if_unused: if_unused,
                    nowait: nowait,
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn if_unused(&self) -> bool {
                self.if_unused
            }
            pub fn nowait(&self) -> bool {
                self.nowait
            }
        }
        impl<'a> ::amqp0::Message for Delete<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [4, self.exchange.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct DeleteOk;
        impl DeleteOk {
            pub fn new() -> Self {
                DeleteOk
            }
        }
        impl ::amqp0::Message for DeleteOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Bound<'a> {
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
            queue: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Bound<'a> {
            pub fn new<E, Q, R>(exchange: E, routing_key: R, queue: Q) -> Self
                where E: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, str>>,
                      Q: Into<::std::borrow::Cow<'a, str>>
            {
                Bound {
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                    queue: queue.into(),
                }
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
        }
        impl<'a> ::amqp0::Message for Bound<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [3, self.exchange.len(), self.routing_key.len(), self.queue.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct BoundOk<'a> {
            reply_code: u16,
            reply_text: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> BoundOk<'a> {
            pub fn new<R>(reply_code: u16, reply_text: R) -> Self
                where R: Into<::std::borrow::Cow<'a, str>>
            {
                BoundOk {
                    reply_code: reply_code,
                    reply_text: reply_text.into(),
                }
            }
            pub fn reply_code(&self) -> u16 {
                self.reply_code
            }
            pub fn reply_text(&self) -> &str {
                &*self.reply_text
            }
        }
        impl<'a> ::amqp0::Message for BoundOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [3, self.reply_text.len()]
                    .iter()
                    .sum()
            }
        }
    }
    pub mod file {

        // Class Modules
        pub struct Qos {
            prefetch_size: u32,
            prefetch_count: u16,
            global: bool,
        }
        impl Qos {
            pub fn new(prefetch_size: u32, prefetch_count: u16, global: bool) -> Self {
                Qos {
                    prefetch_size: prefetch_size,
                    prefetch_count: prefetch_count,
                    global: global,
                }
            }
            pub fn prefetch_size(&self) -> u32 {
                self.prefetch_size
            }
            pub fn prefetch_count(&self) -> u16 {
                self.prefetch_count
            }
            pub fn global(&self) -> bool {
                self.global
            }
        }
        impl ::amqp0::Message for Qos {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                7
            }
        }

        // Class Modules
        pub struct QosOk;
        impl QosOk {
            pub fn new() -> Self {
                QosOk
            }
        }
        impl ::amqp0::Message for QosOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Consume<'a> {
            ticket: u16,
            queue: ::std::borrow::Cow<'a, str>,
            consumer_tag: ::std::borrow::Cow<'a, str>,
            no_local: bool,
            no_ack: bool,
            exclusive: bool,
            nowait: bool,
            filter: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
        }
        impl<'a> Consume<'a> {
            pub fn new<C, F, Q>(ticket: u16,
                                queue: Q,
                                consumer_tag: C,
                                no_local: bool,
                                no_ack: bool,
                                exclusive: bool,
                                nowait: bool,
                                filter: F)
                                -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>,
                      C: Into<::std::borrow::Cow<'a, str>>,
                      F: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>
            {
                Consume {
                    ticket: ticket,
                    queue: queue.into(),
                    consumer_tag: consumer_tag.into(),
                    no_local: no_local,
                    no_ack: no_ack,
                    exclusive: exclusive,
                    nowait: nowait,
                    filter: filter.into(),
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
            pub fn no_local(&self) -> bool {
                self.no_local
            }
            pub fn no_ack(&self) -> bool {
                self.no_ack
            }
            pub fn exclusive(&self) -> bool {
                self.exclusive
            }
            pub fn nowait(&self) -> bool {
                self.nowait
            }
            pub fn filter(&self) -> &::amqp0::value::Table {
                &*self.filter
            }
        }
        impl<'a> ::amqp0::Message for Consume<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [5, self.queue.len(), self.consumer_tag.len(), self.filter.amqp_size()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct ConsumeOk<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> ConsumeOk<'a> {
            pub fn new<C>(consumer_tag: C) -> Self
                where C: Into<::std::borrow::Cow<'a, str>>
            {
                ConsumeOk { consumer_tag: consumer_tag.into() }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
        }
        impl<'a> ::amqp0::Message for ConsumeOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [1, self.consumer_tag.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Cancel<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
            nowait: bool,
        }
        impl<'a> Cancel<'a> {
            pub fn new<C>(consumer_tag: C, nowait: bool) -> Self
                where C: Into<::std::borrow::Cow<'a, str>>
            {
                Cancel {
                    consumer_tag: consumer_tag.into(),
                    nowait: nowait,
                }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
            pub fn nowait(&self) -> bool {
                self.nowait
            }
        }
        impl<'a> ::amqp0::Message for Cancel<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.consumer_tag.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct CancelOk<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> CancelOk<'a> {
            pub fn new<C>(consumer_tag: C) -> Self
                where C: Into<::std::borrow::Cow<'a, str>>
            {
                CancelOk { consumer_tag: consumer_tag.into() }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
        }
        impl<'a> ::amqp0::Message for CancelOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [1, self.consumer_tag.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Open<'a> {
            identifier: ::std::borrow::Cow<'a, str>,
            content_size: u64,
        }
        impl<'a> Open<'a> {
            pub fn new<I>(identifier: I, content_size: u64) -> Self
                where I: Into<::std::borrow::Cow<'a, str>>
            {
                Open {
                    identifier: identifier.into(),
                    content_size: content_size,
                }
            }
            pub fn identifier(&self) -> &str {
                &*self.identifier
            }
            pub fn content_size(&self) -> u64 {
                self.content_size
            }
        }
        impl<'a> ::amqp0::Message for Open<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [9, self.identifier.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct OpenOk {
            staged_size: u64,
        }
        impl OpenOk {
            pub fn new(staged_size: u64) -> Self {
                OpenOk { staged_size: staged_size }
            }
            pub fn staged_size(&self) -> u64 {
                self.staged_size
            }
        }
        impl ::amqp0::Message for OpenOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                8
            }
        }

        // Class Modules
        pub struct Stage;
        impl Stage {
            pub fn new() -> Self {
                Stage
            }
        }
        impl ::amqp0::Message for Stage {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Publish<'a> {
            ticket: u16,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
            mandatory: bool,
            immediate: bool,
            identifier: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Publish<'a> {
            pub fn new<E, I, R>(ticket: u16,
                                exchange: E,
                                routing_key: R,
                                mandatory: bool,
                                immediate: bool,
                                identifier: I)
                                -> Self
                where E: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, str>>,
                      I: Into<::std::borrow::Cow<'a, str>>
            {
                Publish {
                    ticket: ticket,
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                    mandatory: mandatory,
                    immediate: immediate,
                    identifier: identifier.into(),
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
            pub fn mandatory(&self) -> bool {
                self.mandatory
            }
            pub fn immediate(&self) -> bool {
                self.immediate
            }
            pub fn identifier(&self) -> &str {
                &*self.identifier
            }
        }
        impl<'a> ::amqp0::Message for Publish<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [6, self.exchange.len(), self.routing_key.len(), self.identifier.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Return<'a> {
            reply_code: u16,
            reply_text: ::std::borrow::Cow<'a, str>,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Return<'a> {
            pub fn new<E, R, R0>(reply_code: u16,
                                 reply_text: R,
                                 exchange: E,
                                 routing_key: R0)
                                 -> Self
                where R: Into<::std::borrow::Cow<'a, str>>,
                      E: Into<::std::borrow::Cow<'a, str>>,
                      R0: Into<::std::borrow::Cow<'a, str>>
            {
                Return {
                    reply_code: reply_code,
                    reply_text: reply_text.into(),
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                }
            }
            pub fn reply_code(&self) -> u16 {
                self.reply_code
            }
            pub fn reply_text(&self) -> &str {
                &*self.reply_text
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
        }
        impl<'a> ::amqp0::Message for Return<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [5, self.reply_text.len(), self.exchange.len(), self.routing_key.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Deliver<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
            delivery_tag: u64,
            redelivered: bool,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
            identifier: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Deliver<'a> {
            pub fn new<C, E, I, R>(consumer_tag: C,
                                   delivery_tag: u64,
                                   redelivered: bool,
                                   exchange: E,
                                   routing_key: R,
                                   identifier: I)
                                   -> Self
                where C: Into<::std::borrow::Cow<'a, str>>,
                      E: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, str>>,
                      I: Into<::std::borrow::Cow<'a, str>>
            {
                Deliver {
                    consumer_tag: consumer_tag.into(),
                    delivery_tag: delivery_tag,
                    redelivered: redelivered,
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                    identifier: identifier.into(),
                }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
            pub fn delivery_tag(&self) -> u64 {
                self.delivery_tag
            }
            pub fn redelivered(&self) -> bool {
                self.redelivered
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
            pub fn identifier(&self) -> &str {
                &*self.identifier
            }
        }
        impl<'a> ::amqp0::Message for Deliver<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [13,
                 self.consumer_tag.len(),
                 self.exchange.len(),
                 self.routing_key.len(),
                 self.identifier.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Ack {
            delivery_tag: u64,
            multiple: bool,
        }
        impl Ack {
            pub fn new(delivery_tag: u64, multiple: bool) -> Self {
                Ack {
                    delivery_tag: delivery_tag,
                    multiple: multiple,
                }
            }
            pub fn delivery_tag(&self) -> u64 {
                self.delivery_tag
            }
            pub fn multiple(&self) -> bool {
                self.multiple
            }
        }
        impl ::amqp0::Message for Ack {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                9
            }
        }

        // Class Modules
        pub struct Reject {
            delivery_tag: u64,
            requeue: bool,
        }
        impl Reject {
            pub fn new(delivery_tag: u64, requeue: bool) -> Self {
                Reject {
                    delivery_tag: delivery_tag,
                    requeue: requeue,
                }
            }
            pub fn delivery_tag(&self) -> u64 {
                self.delivery_tag
            }
            pub fn requeue(&self) -> bool {
                self.requeue
            }
        }
        impl ::amqp0::Message for Reject {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                9
            }
        }
    }
    pub mod message {

        // Class Modules
        pub struct Transfer<'a> {
            ticket: u16,
            destination: ::std::borrow::Cow<'a, str>,
            redelivered: bool,
            immediate: bool,
            ttl: u64,
            priority: u8,
            timestamp: u64,
            delivery_mode: u8,
            expiration: u64,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
            message_id: ::std::borrow::Cow<'a, str>,
            correlation_id: ::std::borrow::Cow<'a, str>,
            reply_to: ::std::borrow::Cow<'a, str>,
            content_type: ::std::borrow::Cow<'a, str>,
            content_encoding: ::std::borrow::Cow<'a, str>,
            user_id: ::std::borrow::Cow<'a, str>,
            app_id: ::std::borrow::Cow<'a, str>,
            transaction_id: ::std::borrow::Cow<'a, str>,
            security_token: ::std::borrow::Cow<'a, [u8]>,
            application_headers: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
            body: ::std::borrow::Cow<'a, [u8]>,
        }
        impl<'a> Transfer<'a> {
            pub fn new<A, A0, B, C1, C0, C, D, E, M, R0, R, S, T, U>(ticket: u16,
                                                                     destination: D,
                                                                     redelivered: bool,
                                                                     immediate: bool,
                                                                     ttl: u64,
                                                                     priority: u8,
                                                                     timestamp: u64,
                                                                     delivery_mode: u8,
                                                                     expiration: u64,
                                                                     exchange: E,
                                                                     routing_key: R,
                                                                     message_id: M,
                                                                     correlation_id: C,
                                                                     reply_to: R0,
                                                                     content_type: C0,
                                                                     content_encoding: C1,
                                                                     user_id: U,
                                                                     app_id: A,
                                                                     transaction_id: T,
                                                                     security_token: S,
                                                                     application_headers: A0,
                                                                     body: B)
                                                                     -> Self
                where D: Into<::std::borrow::Cow<'a, str>>,
                      E: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, str>>,
                      M: Into<::std::borrow::Cow<'a, str>>,
                      C: Into<::std::borrow::Cow<'a, str>>,
                      R0: Into<::std::borrow::Cow<'a, str>>,
                      C0: Into<::std::borrow::Cow<'a, str>>,
                      C1: Into<::std::borrow::Cow<'a, str>>,
                      U: Into<::std::borrow::Cow<'a, str>>,
                      A: Into<::std::borrow::Cow<'a, str>>,
                      T: Into<::std::borrow::Cow<'a, str>>,
                      S: Into<::std::borrow::Cow<'a, [u8]>>,
                      A0: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>,
                      B: Into<::std::borrow::Cow<'a, [u8]>>
            {
                Transfer {
                    ticket: ticket,
                    destination: destination.into(),
                    redelivered: redelivered,
                    immediate: immediate,
                    ttl: ttl,
                    priority: priority,
                    timestamp: timestamp,
                    delivery_mode: delivery_mode,
                    expiration: expiration,
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                    message_id: message_id.into(),
                    correlation_id: correlation_id.into(),
                    reply_to: reply_to.into(),
                    content_type: content_type.into(),
                    content_encoding: content_encoding.into(),
                    user_id: user_id.into(),
                    app_id: app_id.into(),
                    transaction_id: transaction_id.into(),
                    security_token: security_token.into(),
                    application_headers: application_headers.into(),
                    body: body.into(),
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn destination(&self) -> &str {
                &*self.destination
            }
            pub fn redelivered(&self) -> bool {
                self.redelivered
            }
            pub fn immediate(&self) -> bool {
                self.immediate
            }
            pub fn ttl(&self) -> u64 {
                self.ttl
            }
            pub fn priority(&self) -> u8 {
                self.priority
            }
            pub fn timestamp(&self) -> u64 {
                self.timestamp
            }
            pub fn delivery_mode(&self) -> u8 {
                self.delivery_mode
            }
            pub fn expiration(&self) -> u64 {
                self.expiration
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
            pub fn message_id(&self) -> &str {
                &*self.message_id
            }
            pub fn correlation_id(&self) -> &str {
                &*self.correlation_id
            }
            pub fn reply_to(&self) -> &str {
                &*self.reply_to
            }
            pub fn content_type(&self) -> &str {
                &*self.content_type
            }
            pub fn content_encoding(&self) -> &str {
                &*self.content_encoding
            }
            pub fn user_id(&self) -> &str {
                &*self.user_id
            }
            pub fn app_id(&self) -> &str {
                &*self.app_id
            }
            pub fn transaction_id(&self) -> &str {
                &*self.transaction_id
            }
            pub fn security_token(&self) -> &[u8] {
                &*self.security_token
            }
            pub fn application_headers(&self) -> &::amqp0::value::Table {
                &*self.application_headers
            }
            pub fn body(&self) -> &[u8] {
                &*self.body
            }
        }
        impl<'a> ::amqp0::Message for Transfer<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [43,
                 self.destination.len(),
                 self.exchange.len(),
                 self.routing_key.len(),
                 self.message_id.len(),
                 self.correlation_id.len(),
                 self.reply_to.len(),
                 self.content_type.len(),
                 self.content_encoding.len(),
                 self.user_id.len(),
                 self.app_id.len(),
                 self.transaction_id.len(),
                 self.security_token.len(),
                 self.application_headers.amqp_size(),
                 self.body.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Consume<'a> {
            ticket: u16,
            queue: ::std::borrow::Cow<'a, str>,
            destination: ::std::borrow::Cow<'a, str>,
            no_local: bool,
            no_ack: bool,
            exclusive: bool,
            filter: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
        }
        impl<'a> Consume<'a> {
            pub fn new<D, F, Q>(ticket: u16,
                                queue: Q,
                                destination: D,
                                no_local: bool,
                                no_ack: bool,
                                exclusive: bool,
                                filter: F)
                                -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>,
                      D: Into<::std::borrow::Cow<'a, str>>,
                      F: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>
            {
                Consume {
                    ticket: ticket,
                    queue: queue.into(),
                    destination: destination.into(),
                    no_local: no_local,
                    no_ack: no_ack,
                    exclusive: exclusive,
                    filter: filter.into(),
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn destination(&self) -> &str {
                &*self.destination
            }
            pub fn no_local(&self) -> bool {
                self.no_local
            }
            pub fn no_ack(&self) -> bool {
                self.no_ack
            }
            pub fn exclusive(&self) -> bool {
                self.exclusive
            }
            pub fn filter(&self) -> &::amqp0::value::Table {
                &*self.filter
            }
        }
        impl<'a> ::amqp0::Message for Consume<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [5, self.queue.len(), self.destination.len(), self.filter.amqp_size()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Cancel<'a> {
            destination: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Cancel<'a> {
            pub fn new<D>(destination: D) -> Self
                where D: Into<::std::borrow::Cow<'a, str>>
            {
                Cancel { destination: destination.into() }
            }
            pub fn destination(&self) -> &str {
                &*self.destination
            }
        }
        impl<'a> ::amqp0::Message for Cancel<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [1, self.destination.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Get<'a> {
            ticket: u16,
            queue: ::std::borrow::Cow<'a, str>,
            destination: ::std::borrow::Cow<'a, str>,
            no_ack: bool,
        }
        impl<'a> Get<'a> {
            pub fn new<D, Q>(ticket: u16, queue: Q, destination: D, no_ack: bool) -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>,
                      D: Into<::std::borrow::Cow<'a, str>>
            {
                Get {
                    ticket: ticket,
                    queue: queue.into(),
                    destination: destination.into(),
                    no_ack: no_ack,
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn destination(&self) -> &str {
                &*self.destination
            }
            pub fn no_ack(&self) -> bool {
                self.no_ack
            }
        }
        impl<'a> ::amqp0::Message for Get<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [5, self.queue.len(), self.destination.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Recover {
            requeue: bool,
        }
        impl Recover {
            pub fn new(requeue: bool) -> Self {
                Recover { requeue: requeue }
            }
            pub fn requeue(&self) -> bool {
                self.requeue
            }
        }
        impl ::amqp0::Message for Recover {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                1
            }
        }

        // Class Modules
        pub struct Open<'a> {
            reference: ::std::borrow::Cow<'a, [u8]>,
        }
        impl<'a> Open<'a> {
            pub fn new<R>(reference: R) -> Self
                where R: Into<::std::borrow::Cow<'a, [u8]>>
            {
                Open { reference: reference.into() }
            }
            pub fn reference(&self) -> &[u8] {
                &*self.reference
            }
        }
        impl<'a> ::amqp0::Message for Open<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.reference.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Close<'a> {
            reference: ::std::borrow::Cow<'a, [u8]>,
        }
        impl<'a> Close<'a> {
            pub fn new<R>(reference: R) -> Self
                where R: Into<::std::borrow::Cow<'a, [u8]>>
            {
                Close { reference: reference.into() }
            }
            pub fn reference(&self) -> &[u8] {
                &*self.reference
            }
        }
        impl<'a> ::amqp0::Message for Close<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.reference.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Append<'a> {
            reference: ::std::borrow::Cow<'a, [u8]>,
            bytes: ::std::borrow::Cow<'a, [u8]>,
        }
        impl<'a> Append<'a> {
            pub fn new<B, R>(reference: R, bytes: B) -> Self
                where R: Into<::std::borrow::Cow<'a, [u8]>>,
                      B: Into<::std::borrow::Cow<'a, [u8]>>
            {
                Append {
                    reference: reference.into(),
                    bytes: bytes.into(),
                }
            }
            pub fn reference(&self) -> &[u8] {
                &*self.reference
            }
            pub fn bytes(&self) -> &[u8] {
                &*self.bytes
            }
        }
        impl<'a> ::amqp0::Message for Append<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [4, self.reference.len(), self.bytes.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Checkpoint<'a> {
            reference: ::std::borrow::Cow<'a, [u8]>,
            identifier: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Checkpoint<'a> {
            pub fn new<I, R>(reference: R, identifier: I) -> Self
                where R: Into<::std::borrow::Cow<'a, [u8]>>,
                      I: Into<::std::borrow::Cow<'a, str>>
            {
                Checkpoint {
                    reference: reference.into(),
                    identifier: identifier.into(),
                }
            }
            pub fn reference(&self) -> &[u8] {
                &*self.reference
            }
            pub fn identifier(&self) -> &str {
                &*self.identifier
            }
        }
        impl<'a> ::amqp0::Message for Checkpoint<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [3, self.reference.len(), self.identifier.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Resume<'a> {
            reference: ::std::borrow::Cow<'a, [u8]>,
            identifier: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Resume<'a> {
            pub fn new<I, R>(reference: R, identifier: I) -> Self
                where R: Into<::std::borrow::Cow<'a, [u8]>>,
                      I: Into<::std::borrow::Cow<'a, str>>
            {
                Resume {
                    reference: reference.into(),
                    identifier: identifier.into(),
                }
            }
            pub fn reference(&self) -> &[u8] {
                &*self.reference
            }
            pub fn identifier(&self) -> &str {
                &*self.identifier
            }
        }
        impl<'a> ::amqp0::Message for Resume<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [3, self.reference.len(), self.identifier.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Qos {
            prefetch_size: u32,
            prefetch_count: u16,
            global: bool,
        }
        impl Qos {
            pub fn new(prefetch_size: u32, prefetch_count: u16, global: bool) -> Self {
                Qos {
                    prefetch_size: prefetch_size,
                    prefetch_count: prefetch_count,
                    global: global,
                }
            }
            pub fn prefetch_size(&self) -> u32 {
                self.prefetch_size
            }
            pub fn prefetch_count(&self) -> u16 {
                self.prefetch_count
            }
            pub fn global(&self) -> bool {
                self.global
            }
        }
        impl ::amqp0::Message for Qos {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                7
            }
        }

        // Class Modules
        pub struct Ok;
        impl Ok {
            pub fn new() -> Self {
                Ok
            }
        }
        impl ::amqp0::Message for Ok {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Empty;
        impl Empty {
            pub fn new() -> Self {
                Empty
            }
        }
        impl ::amqp0::Message for Empty {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Reject<'a> {
            code: u16,
            text: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Reject<'a> {
            pub fn new<T>(code: u16, text: T) -> Self
                where T: Into<::std::borrow::Cow<'a, str>>
            {
                Reject {
                    code: code,
                    text: text.into(),
                }
            }
            pub fn code(&self) -> u16 {
                self.code
            }
            pub fn text(&self) -> &str {
                &*self.text
            }
        }
        impl<'a> ::amqp0::Message for Reject<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [3, self.text.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Offset {
            value: u64,
        }
        impl Offset {
            pub fn new(value: u64) -> Self {
                Offset { value: value }
            }
            pub fn value(&self) -> u64 {
                self.value
            }
        }
        impl ::amqp0::Message for Offset {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                8
            }
        }
    }
    pub mod queue {

        // Class Modules
        pub struct Declare<'a> {
            ticket: u16,
            queue: ::std::borrow::Cow<'a, str>,
            passive: bool,
            durable: bool,
            exclusive: bool,
            auto_delete: bool,
            nowait: bool,
            arguments: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
        }
        impl<'a> Declare<'a> {
            pub fn new<A, Q>(ticket: u16,
                             queue: Q,
                             passive: bool,
                             durable: bool,
                             exclusive: bool,
                             auto_delete: bool,
                             nowait: bool,
                             arguments: A)
                             -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>,
                      A: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>
            {
                Declare {
                    ticket: ticket,
                    queue: queue.into(),
                    passive: passive,
                    durable: durable,
                    exclusive: exclusive,
                    auto_delete: auto_delete,
                    nowait: nowait,
                    arguments: arguments.into(),
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn passive(&self) -> bool {
                self.passive
            }
            pub fn durable(&self) -> bool {
                self.durable
            }
            pub fn exclusive(&self) -> bool {
                self.exclusive
            }
            pub fn auto_delete(&self) -> bool {
                self.auto_delete
            }
            pub fn nowait(&self) -> bool {
                self.nowait
            }
            pub fn arguments(&self) -> &::amqp0::value::Table {
                &*self.arguments
            }
        }
        impl<'a> ::amqp0::Message for Declare<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [4, self.queue.len(), self.arguments.amqp_size()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct DeclareOk<'a> {
            queue: ::std::borrow::Cow<'a, str>,
            message_count: u32,
            consumer_count: u32,
        }
        impl<'a> DeclareOk<'a> {
            pub fn new<Q>(queue: Q, message_count: u32, consumer_count: u32) -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>
            {
                DeclareOk {
                    queue: queue.into(),
                    message_count: message_count,
                    consumer_count: consumer_count,
                }
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn message_count(&self) -> u32 {
                self.message_count
            }
            pub fn consumer_count(&self) -> u32 {
                self.consumer_count
            }
        }
        impl<'a> ::amqp0::Message for DeclareOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [9, self.queue.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Bind<'a> {
            ticket: u16,
            queue: ::std::borrow::Cow<'a, str>,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
            nowait: bool,
            arguments: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
        }
        impl<'a> Bind<'a> {
            pub fn new<A, E, Q, R>(ticket: u16,
                                   queue: Q,
                                   exchange: E,
                                   routing_key: R,
                                   nowait: bool,
                                   arguments: A)
                                   -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>,
                      E: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, str>>,
                      A: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>
            {
                Bind {
                    ticket: ticket,
                    queue: queue.into(),
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                    nowait: nowait,
                    arguments: arguments.into(),
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
            pub fn nowait(&self) -> bool {
                self.nowait
            }
            pub fn arguments(&self) -> &::amqp0::value::Table {
                &*self.arguments
            }
        }
        impl<'a> ::amqp0::Message for Bind<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [6,
                 self.queue.len(),
                 self.exchange.len(),
                 self.routing_key.len(),
                 self.arguments.amqp_size()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct BindOk;
        impl BindOk {
            pub fn new() -> Self {
                BindOk
            }
        }
        impl ::amqp0::Message for BindOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Unbind<'a> {
            ticket: u16,
            queue: ::std::borrow::Cow<'a, str>,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
            arguments: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
        }
        impl<'a> Unbind<'a> {
            pub fn new<A, E, Q, R>(ticket: u16,
                                   queue: Q,
                                   exchange: E,
                                   routing_key: R,
                                   arguments: A)
                                   -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>,
                      E: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, str>>,
                      A: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>
            {
                Unbind {
                    ticket: ticket,
                    queue: queue.into(),
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                    arguments: arguments.into(),
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
            pub fn arguments(&self) -> &::amqp0::value::Table {
                &*self.arguments
            }
        }
        impl<'a> ::amqp0::Message for Unbind<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [5,
                 self.queue.len(),
                 self.exchange.len(),
                 self.routing_key.len(),
                 self.arguments.amqp_size()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct UnbindOk;
        impl UnbindOk {
            pub fn new() -> Self {
                UnbindOk
            }
        }
        impl ::amqp0::Message for UnbindOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Purge<'a> {
            ticket: u16,
            queue: ::std::borrow::Cow<'a, str>,
            nowait: bool,
        }
        impl<'a> Purge<'a> {
            pub fn new<Q>(ticket: u16, queue: Q, nowait: bool) -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>
            {
                Purge {
                    ticket: ticket,
                    queue: queue.into(),
                    nowait: nowait,
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn nowait(&self) -> bool {
                self.nowait
            }
        }
        impl<'a> ::amqp0::Message for Purge<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [4, self.queue.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct PurgeOk {
            message_count: u32,
        }
        impl PurgeOk {
            pub fn new(message_count: u32) -> Self {
                PurgeOk { message_count: message_count }
            }
            pub fn message_count(&self) -> u32 {
                self.message_count
            }
        }
        impl ::amqp0::Message for PurgeOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                4
            }
        }

        // Class Modules
        pub struct Delete<'a> {
            ticket: u16,
            queue: ::std::borrow::Cow<'a, str>,
            if_unused: bool,
            if_empty: bool,
            nowait: bool,
        }
        impl<'a> Delete<'a> {
            pub fn new<Q>(ticket: u16,
                          queue: Q,
                          if_unused: bool,
                          if_empty: bool,
                          nowait: bool)
                          -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>
            {
                Delete {
                    ticket: ticket,
                    queue: queue.into(),
                    if_unused: if_unused,
                    if_empty: if_empty,
                    nowait: nowait,
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn if_unused(&self) -> bool {
                self.if_unused
            }
            pub fn if_empty(&self) -> bool {
                self.if_empty
            }
            pub fn nowait(&self) -> bool {
                self.nowait
            }
        }
        impl<'a> ::amqp0::Message for Delete<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [4, self.queue.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct DeleteOk {
            message_count: u32,
        }
        impl DeleteOk {
            pub fn new(message_count: u32) -> Self {
                DeleteOk { message_count: message_count }
            }
            pub fn message_count(&self) -> u32 {
                self.message_count
            }
        }
        impl ::amqp0::Message for DeleteOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                4
            }
        }
    }
    pub mod stream {

        // Class Modules
        pub struct Qos {
            prefetch_size: u32,
            prefetch_count: u16,
            consume_rate: u32,
            global: bool,
        }
        impl Qos {
            pub fn new(prefetch_size: u32,
                       prefetch_count: u16,
                       consume_rate: u32,
                       global: bool)
                       -> Self {
                Qos {
                    prefetch_size: prefetch_size,
                    prefetch_count: prefetch_count,
                    consume_rate: consume_rate,
                    global: global,
                }
            }
            pub fn prefetch_size(&self) -> u32 {
                self.prefetch_size
            }
            pub fn prefetch_count(&self) -> u16 {
                self.prefetch_count
            }
            pub fn consume_rate(&self) -> u32 {
                self.consume_rate
            }
            pub fn global(&self) -> bool {
                self.global
            }
        }
        impl ::amqp0::Message for Qos {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                11
            }
        }

        // Class Modules
        pub struct QosOk;
        impl QosOk {
            pub fn new() -> Self {
                QosOk
            }
        }
        impl ::amqp0::Message for QosOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Consume<'a> {
            ticket: u16,
            queue: ::std::borrow::Cow<'a, str>,
            consumer_tag: ::std::borrow::Cow<'a, str>,
            no_local: bool,
            exclusive: bool,
            nowait: bool,
            filter: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
        }
        impl<'a> Consume<'a> {
            pub fn new<C, F, Q>(ticket: u16,
                                queue: Q,
                                consumer_tag: C,
                                no_local: bool,
                                exclusive: bool,
                                nowait: bool,
                                filter: F)
                                -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>,
                      C: Into<::std::borrow::Cow<'a, str>>,
                      F: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>
            {
                Consume {
                    ticket: ticket,
                    queue: queue.into(),
                    consumer_tag: consumer_tag.into(),
                    no_local: no_local,
                    exclusive: exclusive,
                    nowait: nowait,
                    filter: filter.into(),
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
            pub fn no_local(&self) -> bool {
                self.no_local
            }
            pub fn exclusive(&self) -> bool {
                self.exclusive
            }
            pub fn nowait(&self) -> bool {
                self.nowait
            }
            pub fn filter(&self) -> &::amqp0::value::Table {
                &*self.filter
            }
        }
        impl<'a> ::amqp0::Message for Consume<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [5, self.queue.len(), self.consumer_tag.len(), self.filter.amqp_size()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct ConsumeOk<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> ConsumeOk<'a> {
            pub fn new<C>(consumer_tag: C) -> Self
                where C: Into<::std::borrow::Cow<'a, str>>
            {
                ConsumeOk { consumer_tag: consumer_tag.into() }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
        }
        impl<'a> ::amqp0::Message for ConsumeOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [1, self.consumer_tag.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Cancel<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
            nowait: bool,
        }
        impl<'a> Cancel<'a> {
            pub fn new<C>(consumer_tag: C, nowait: bool) -> Self
                where C: Into<::std::borrow::Cow<'a, str>>
            {
                Cancel {
                    consumer_tag: consumer_tag.into(),
                    nowait: nowait,
                }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
            pub fn nowait(&self) -> bool {
                self.nowait
            }
        }
        impl<'a> ::amqp0::Message for Cancel<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.consumer_tag.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct CancelOk<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> CancelOk<'a> {
            pub fn new<C>(consumer_tag: C) -> Self
                where C: Into<::std::borrow::Cow<'a, str>>
            {
                CancelOk { consumer_tag: consumer_tag.into() }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
        }
        impl<'a> ::amqp0::Message for CancelOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [1, self.consumer_tag.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Publish<'a> {
            ticket: u16,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
            mandatory: bool,
            immediate: bool,
        }
        impl<'a> Publish<'a> {
            pub fn new<E, R>(ticket: u16,
                             exchange: E,
                             routing_key: R,
                             mandatory: bool,
                             immediate: bool)
                             -> Self
                where E: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, str>>
            {
                Publish {
                    ticket: ticket,
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                    mandatory: mandatory,
                    immediate: immediate,
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
            pub fn mandatory(&self) -> bool {
                self.mandatory
            }
            pub fn immediate(&self) -> bool {
                self.immediate
            }
        }
        impl<'a> ::amqp0::Message for Publish<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [5, self.exchange.len(), self.routing_key.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Return<'a> {
            reply_code: u16,
            reply_text: ::std::borrow::Cow<'a, str>,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Return<'a> {
            pub fn new<E, R, R0>(reply_code: u16,
                                 reply_text: R,
                                 exchange: E,
                                 routing_key: R0)
                                 -> Self
                where R: Into<::std::borrow::Cow<'a, str>>,
                      E: Into<::std::borrow::Cow<'a, str>>,
                      R0: Into<::std::borrow::Cow<'a, str>>
            {
                Return {
                    reply_code: reply_code,
                    reply_text: reply_text.into(),
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                }
            }
            pub fn reply_code(&self) -> u16 {
                self.reply_code
            }
            pub fn reply_text(&self) -> &str {
                &*self.reply_text
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
        }
        impl<'a> ::amqp0::Message for Return<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [5, self.reply_text.len(), self.exchange.len(), self.routing_key.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Deliver<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
            delivery_tag: u64,
            exchange: ::std::borrow::Cow<'a, str>,
            queue: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Deliver<'a> {
            pub fn new<C, E, Q>(consumer_tag: C, delivery_tag: u64, exchange: E, queue: Q) -> Self
                where C: Into<::std::borrow::Cow<'a, str>>,
                      E: Into<::std::borrow::Cow<'a, str>>,
                      Q: Into<::std::borrow::Cow<'a, str>>
            {
                Deliver {
                    consumer_tag: consumer_tag.into(),
                    delivery_tag: delivery_tag,
                    exchange: exchange.into(),
                    queue: queue.into(),
                }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
            pub fn delivery_tag(&self) -> u64 {
                self.delivery_tag
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
        }
        impl<'a> ::amqp0::Message for Deliver<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [11, self.consumer_tag.len(), self.exchange.len(), self.queue.len()]
                    .iter()
                    .sum()
            }
        }
    }
    pub mod tunnel {

        // Class Modules
        pub struct Request<'a> {
            meta_data: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
        }
        impl<'a> Request<'a> {
            pub fn new<M>(meta_data: M) -> Self
                where M: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>
            {
                Request { meta_data: meta_data.into() }
            }
            pub fn meta_data(&self) -> &::amqp0::value::Table {
                &*self.meta_data
            }
        }
        impl<'a> ::amqp0::Message for Request<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [0, self.meta_data.amqp_size()]
                    .iter()
                    .sum()
            }
        }
    }
    pub mod tx {

        // Class Modules
        pub struct Select;
        impl Select {
            pub fn new() -> Self {
                Select
            }
        }
        impl ::amqp0::Message for Select {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct SelectOk;
        impl SelectOk {
            pub fn new() -> Self {
                SelectOk
            }
        }
        impl ::amqp0::Message for SelectOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Commit;
        impl Commit {
            pub fn new() -> Self {
                Commit
            }
        }
        impl ::amqp0::Message for Commit {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct CommitOk;
        impl CommitOk {
            pub fn new() -> Self {
                CommitOk
            }
        }
        impl ::amqp0::Message for CommitOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Rollback;
        impl Rollback {
            pub fn new() -> Self {
                Rollback
            }
        }
        impl ::amqp0::Message for Rollback {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct RollbackOk;
        impl RollbackOk {
            pub fn new() -> Self {
                RollbackOk
            }
        }
        impl ::amqp0::Message for RollbackOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }
    }
}

#[allow(non_camel_case_types)]
pub struct Qpid9_0;
impl Spec for Qpid9_0 {}

pub mod qpid8_0 {
    // Class Constants
    pub const CLASS_ACCESS: u16 = 30;
    pub const CLASS_BASIC: u16 = 60;
    pub const CLASS_CHANNEL: u16 = 20;
    pub const CLASS_CONNECTION: u16 = 10;
    pub const CLASS_DTX: u16 = 100;
    pub const CLASS_EXCHANGE: u16 = 40;
    pub const CLASS_FILE: u16 = 70;
    pub const CLASS_QUEUE: u16 = 50;
    pub const CLASS_STREAM: u16 = 80;
    pub const CLASS_TEST: u16 = 120;
    pub const CLASS_TUNNEL: u16 = 110;
    pub const CLASS_TX: u16 = 90;

    // Class Methods
    pub const METHOD_ACCESS_REQUEST: u16 = 10;
    pub const METHOD_ACCESS_REQUEST_OK: u16 = 11;

    pub const METHOD_BASIC_QOS: u16 = 10;
    pub const METHOD_BASIC_QOS_OK: u16 = 11;
    pub const METHOD_BASIC_CONSUME: u16 = 20;
    pub const METHOD_BASIC_CONSUME_OK: u16 = 21;
    pub const METHOD_BASIC_CANCEL: u16 = 30;
    pub const METHOD_BASIC_CANCEL_OK: u16 = 31;
    pub const METHOD_BASIC_PUBLISH: u16 = 40;
    pub const METHOD_BASIC_RETURN: u16 = 50;
    pub const METHOD_BASIC_DELIVER: u16 = 60;
    pub const METHOD_BASIC_GET: u16 = 70;
    pub const METHOD_BASIC_GET_OK: u16 = 71;
    pub const METHOD_BASIC_GET_EMPTY: u16 = 72;
    pub const METHOD_BASIC_ACK: u16 = 80;
    pub const METHOD_BASIC_REJECT: u16 = 90;
    pub const METHOD_BASIC_RECOVER: u16 = 100;
    pub const METHOD_BASIC_RECOVER_OK: u16 = 101;

    pub const METHOD_CHANNEL_OPEN: u16 = 10;
    pub const METHOD_CHANNEL_OPEN_OK: u16 = 11;
    pub const METHOD_CHANNEL_FLOW: u16 = 20;
    pub const METHOD_CHANNEL_FLOW_OK: u16 = 21;
    pub const METHOD_CHANNEL_ALERT: u16 = 30;
    pub const METHOD_CHANNEL_CLOSE: u16 = 40;
    pub const METHOD_CHANNEL_CLOSE_OK: u16 = 41;

    pub const METHOD_CONNECTION_START: u16 = 10;
    pub const METHOD_CONNECTION_START_OK: u16 = 11;
    pub const METHOD_CONNECTION_SECURE: u16 = 20;
    pub const METHOD_CONNECTION_SECURE_OK: u16 = 21;
    pub const METHOD_CONNECTION_TUNE: u16 = 30;
    pub const METHOD_CONNECTION_TUNE_OK: u16 = 31;
    pub const METHOD_CONNECTION_OPEN: u16 = 40;
    pub const METHOD_CONNECTION_OPEN_OK: u16 = 41;
    pub const METHOD_CONNECTION_REDIRECT: u16 = 50;
    pub const METHOD_CONNECTION_CLOSE: u16 = 60;
    pub const METHOD_CONNECTION_CLOSE_OK: u16 = 61;

    pub const METHOD_DTX_SELECT: u16 = 10;
    pub const METHOD_DTX_SELECT_OK: u16 = 11;
    pub const METHOD_DTX_START: u16 = 20;
    pub const METHOD_DTX_START_OK: u16 = 21;

    pub const METHOD_EXCHANGE_DECLARE: u16 = 10;
    pub const METHOD_EXCHANGE_DECLARE_OK: u16 = 11;
    pub const METHOD_EXCHANGE_DELETE: u16 = 20;
    pub const METHOD_EXCHANGE_DELETE_OK: u16 = 21;
    pub const METHOD_EXCHANGE_BOUND: u16 = 22;
    pub const METHOD_EXCHANGE_BOUND_OK: u16 = 23;

    pub const METHOD_FILE_QOS: u16 = 10;
    pub const METHOD_FILE_QOS_OK: u16 = 11;
    pub const METHOD_FILE_CONSUME: u16 = 20;
    pub const METHOD_FILE_CONSUME_OK: u16 = 21;
    pub const METHOD_FILE_CANCEL: u16 = 30;
    pub const METHOD_FILE_CANCEL_OK: u16 = 31;
    pub const METHOD_FILE_OPEN: u16 = 40;
    pub const METHOD_FILE_OPEN_OK: u16 = 41;
    pub const METHOD_FILE_STAGE: u16 = 50;
    pub const METHOD_FILE_PUBLISH: u16 = 60;
    pub const METHOD_FILE_RETURN: u16 = 70;
    pub const METHOD_FILE_DELIVER: u16 = 80;
    pub const METHOD_FILE_ACK: u16 = 90;
    pub const METHOD_FILE_REJECT: u16 = 100;

    pub const METHOD_QUEUE_DECLARE: u16 = 10;
    pub const METHOD_QUEUE_DECLARE_OK: u16 = 11;
    pub const METHOD_QUEUE_BIND: u16 = 20;
    pub const METHOD_QUEUE_BIND_OK: u16 = 21;
    pub const METHOD_QUEUE_PURGE: u16 = 30;
    pub const METHOD_QUEUE_PURGE_OK: u16 = 31;
    pub const METHOD_QUEUE_DELETE: u16 = 40;
    pub const METHOD_QUEUE_DELETE_OK: u16 = 41;

    pub const METHOD_STREAM_QOS: u16 = 10;
    pub const METHOD_STREAM_QOS_OK: u16 = 11;
    pub const METHOD_STREAM_CONSUME: u16 = 20;
    pub const METHOD_STREAM_CONSUME_OK: u16 = 21;
    pub const METHOD_STREAM_CANCEL: u16 = 30;
    pub const METHOD_STREAM_CANCEL_OK: u16 = 31;
    pub const METHOD_STREAM_PUBLISH: u16 = 40;
    pub const METHOD_STREAM_RETURN: u16 = 50;
    pub const METHOD_STREAM_DELIVER: u16 = 60;

    pub const METHOD_TEST_INTEGER: u16 = 10;
    pub const METHOD_TEST_INTEGER_OK: u16 = 11;
    pub const METHOD_TEST_STRING: u16 = 20;
    pub const METHOD_TEST_STRING_OK: u16 = 21;
    pub const METHOD_TEST_TABLE: u16 = 30;
    pub const METHOD_TEST_TABLE_OK: u16 = 31;
    pub const METHOD_TEST_CONTENT: u16 = 40;
    pub const METHOD_TEST_CONTENT_OK: u16 = 41;

    pub const METHOD_TUNNEL_REQUEST: u16 = 10;

    pub const METHOD_TX_SELECT: u16 = 10;
    pub const METHOD_TX_SELECT_OK: u16 = 11;
    pub const METHOD_TX_COMMIT: u16 = 20;
    pub const METHOD_TX_COMMIT_OK: u16 = 21;
    pub const METHOD_TX_ROLLBACK: u16 = 30;
    pub const METHOD_TX_ROLLBACK_OK: u16 = 31;
    pub mod access {

        // Class Modules
        pub struct Request<'a> {
            realm: ::std::borrow::Cow<'a, str>,
            exclusive: bool,
            passive: bool,
            active: bool,
            write: bool,
            read: bool,
        }
        impl<'a> Request<'a> {
            pub fn new<R>(realm: R,
                          exclusive: bool,
                          passive: bool,
                          active: bool,
                          write: bool,
                          read: bool)
                          -> Self
                where R: Into<::std::borrow::Cow<'a, str>>
            {
                Request {
                    realm: realm.into(),
                    exclusive: exclusive,
                    passive: passive,
                    active: active,
                    write: write,
                    read: read,
                }
            }
            pub fn realm(&self) -> &str {
                &*self.realm
            }
            pub fn exclusive(&self) -> bool {
                self.exclusive
            }
            pub fn passive(&self) -> bool {
                self.passive
            }
            pub fn active(&self) -> bool {
                self.active
            }
            pub fn write(&self) -> bool {
                self.write
            }
            pub fn read(&self) -> bool {
                self.read
            }
        }
        impl<'a> ::amqp0::Message for Request<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.realm.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct RequestOk {
            ticket: u16,
        }
        impl RequestOk {
            pub fn new(ticket: u16) -> Self {
                RequestOk { ticket: ticket }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
        }
        impl ::amqp0::Message for RequestOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                2
            }
        }
    }
    pub mod basic {

        // Class Modules
        pub struct Qos {
            prefetch_size: u32,
            prefetch_count: u16,
            global: bool,
        }
        impl Qos {
            pub fn new(prefetch_size: u32, prefetch_count: u16, global: bool) -> Self {
                Qos {
                    prefetch_size: prefetch_size,
                    prefetch_count: prefetch_count,
                    global: global,
                }
            }
            pub fn prefetch_size(&self) -> u32 {
                self.prefetch_size
            }
            pub fn prefetch_count(&self) -> u16 {
                self.prefetch_count
            }
            pub fn global(&self) -> bool {
                self.global
            }
        }
        impl ::amqp0::Message for Qos {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                7
            }
        }

        // Class Modules
        pub struct QosOk;
        impl QosOk {
            pub fn new() -> Self {
                QosOk
            }
        }
        impl ::amqp0::Message for QosOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Consume<'a> {
            ticket: u16,
            queue: ::std::borrow::Cow<'a, str>,
            consumer_tag: ::std::borrow::Cow<'a, str>,
            no_local: bool,
            no_ack: bool,
            exclusive: bool,
            nowait: bool,
            arguments: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
        }
        impl<'a> Consume<'a> {
            pub fn new<A, C, Q>(ticket: u16,
                                queue: Q,
                                consumer_tag: C,
                                no_local: bool,
                                no_ack: bool,
                                exclusive: bool,
                                nowait: bool,
                                arguments: A)
                                -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>,
                      C: Into<::std::borrow::Cow<'a, str>>,
                      A: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>
            {
                Consume {
                    ticket: ticket,
                    queue: queue.into(),
                    consumer_tag: consumer_tag.into(),
                    no_local: no_local,
                    no_ack: no_ack,
                    exclusive: exclusive,
                    nowait: nowait,
                    arguments: arguments.into(),
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
            pub fn no_local(&self) -> bool {
                self.no_local
            }
            pub fn no_ack(&self) -> bool {
                self.no_ack
            }
            pub fn exclusive(&self) -> bool {
                self.exclusive
            }
            pub fn nowait(&self) -> bool {
                self.nowait
            }
            pub fn arguments(&self) -> &::amqp0::value::Table {
                &*self.arguments
            }
        }
        impl<'a> ::amqp0::Message for Consume<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [5, self.queue.len(), self.consumer_tag.len(), self.arguments.amqp_size()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct ConsumeOk<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> ConsumeOk<'a> {
            pub fn new<C>(consumer_tag: C) -> Self
                where C: Into<::std::borrow::Cow<'a, str>>
            {
                ConsumeOk { consumer_tag: consumer_tag.into() }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
        }
        impl<'a> ::amqp0::Message for ConsumeOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [1, self.consumer_tag.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Cancel<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
            nowait: bool,
        }
        impl<'a> Cancel<'a> {
            pub fn new<C>(consumer_tag: C, nowait: bool) -> Self
                where C: Into<::std::borrow::Cow<'a, str>>
            {
                Cancel {
                    consumer_tag: consumer_tag.into(),
                    nowait: nowait,
                }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
            pub fn nowait(&self) -> bool {
                self.nowait
            }
        }
        impl<'a> ::amqp0::Message for Cancel<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.consumer_tag.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct CancelOk<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> CancelOk<'a> {
            pub fn new<C>(consumer_tag: C) -> Self
                where C: Into<::std::borrow::Cow<'a, str>>
            {
                CancelOk { consumer_tag: consumer_tag.into() }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
        }
        impl<'a> ::amqp0::Message for CancelOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [1, self.consumer_tag.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Publish<'a> {
            ticket: u16,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
            mandatory: bool,
            immediate: bool,
        }
        impl<'a> Publish<'a> {
            pub fn new<E, R>(ticket: u16,
                             exchange: E,
                             routing_key: R,
                             mandatory: bool,
                             immediate: bool)
                             -> Self
                where E: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, str>>
            {
                Publish {
                    ticket: ticket,
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                    mandatory: mandatory,
                    immediate: immediate,
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
            pub fn mandatory(&self) -> bool {
                self.mandatory
            }
            pub fn immediate(&self) -> bool {
                self.immediate
            }
        }
        impl<'a> ::amqp0::Message for Publish<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [5, self.exchange.len(), self.routing_key.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Return<'a> {
            reply_code: u16,
            reply_text: ::std::borrow::Cow<'a, str>,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Return<'a> {
            pub fn new<E, R, R0>(reply_code: u16,
                                 reply_text: R,
                                 exchange: E,
                                 routing_key: R0)
                                 -> Self
                where R: Into<::std::borrow::Cow<'a, str>>,
                      E: Into<::std::borrow::Cow<'a, str>>,
                      R0: Into<::std::borrow::Cow<'a, str>>
            {
                Return {
                    reply_code: reply_code,
                    reply_text: reply_text.into(),
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                }
            }
            pub fn reply_code(&self) -> u16 {
                self.reply_code
            }
            pub fn reply_text(&self) -> &str {
                &*self.reply_text
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
        }
        impl<'a> ::amqp0::Message for Return<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [5, self.reply_text.len(), self.exchange.len(), self.routing_key.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Deliver<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
            delivery_tag: u64,
            redelivered: bool,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Deliver<'a> {
            pub fn new<C, E, R>(consumer_tag: C,
                                delivery_tag: u64,
                                redelivered: bool,
                                exchange: E,
                                routing_key: R)
                                -> Self
                where C: Into<::std::borrow::Cow<'a, str>>,
                      E: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, str>>
            {
                Deliver {
                    consumer_tag: consumer_tag.into(),
                    delivery_tag: delivery_tag,
                    redelivered: redelivered,
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
            pub fn delivery_tag(&self) -> u64 {
                self.delivery_tag
            }
            pub fn redelivered(&self) -> bool {
                self.redelivered
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
        }
        impl<'a> ::amqp0::Message for Deliver<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [12, self.consumer_tag.len(), self.exchange.len(), self.routing_key.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Get<'a> {
            ticket: u16,
            queue: ::std::borrow::Cow<'a, str>,
            no_ack: bool,
        }
        impl<'a> Get<'a> {
            pub fn new<Q>(ticket: u16, queue: Q, no_ack: bool) -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>
            {
                Get {
                    ticket: ticket,
                    queue: queue.into(),
                    no_ack: no_ack,
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn no_ack(&self) -> bool {
                self.no_ack
            }
        }
        impl<'a> ::amqp0::Message for Get<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [4, self.queue.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct GetOk<'a> {
            delivery_tag: u64,
            redelivered: bool,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
            message_count: u32,
        }
        impl<'a> GetOk<'a> {
            pub fn new<E, R>(delivery_tag: u64,
                             redelivered: bool,
                             exchange: E,
                             routing_key: R,
                             message_count: u32)
                             -> Self
                where E: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, str>>
            {
                GetOk {
                    delivery_tag: delivery_tag,
                    redelivered: redelivered,
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                    message_count: message_count,
                }
            }
            pub fn delivery_tag(&self) -> u64 {
                self.delivery_tag
            }
            pub fn redelivered(&self) -> bool {
                self.redelivered
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
            pub fn message_count(&self) -> u32 {
                self.message_count
            }
        }
        impl<'a> ::amqp0::Message for GetOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [15, self.exchange.len(), self.routing_key.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct GetEmpty<'a> {
            cluster_id: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> GetEmpty<'a> {
            pub fn new<C>(cluster_id: C) -> Self
                where C: Into<::std::borrow::Cow<'a, str>>
            {
                GetEmpty { cluster_id: cluster_id.into() }
            }
            pub fn cluster_id(&self) -> &str {
                &*self.cluster_id
            }
        }
        impl<'a> ::amqp0::Message for GetEmpty<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [1, self.cluster_id.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Ack {
            delivery_tag: u64,
            multiple: bool,
        }
        impl Ack {
            pub fn new(delivery_tag: u64, multiple: bool) -> Self {
                Ack {
                    delivery_tag: delivery_tag,
                    multiple: multiple,
                }
            }
            pub fn delivery_tag(&self) -> u64 {
                self.delivery_tag
            }
            pub fn multiple(&self) -> bool {
                self.multiple
            }
        }
        impl ::amqp0::Message for Ack {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                9
            }
        }

        // Class Modules
        pub struct Reject {
            delivery_tag: u64,
            requeue: bool,
        }
        impl Reject {
            pub fn new(delivery_tag: u64, requeue: bool) -> Self {
                Reject {
                    delivery_tag: delivery_tag,
                    requeue: requeue,
                }
            }
            pub fn delivery_tag(&self) -> u64 {
                self.delivery_tag
            }
            pub fn requeue(&self) -> bool {
                self.requeue
            }
        }
        impl ::amqp0::Message for Reject {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                9
            }
        }

        // Class Modules
        pub struct Recover {
            requeue: bool,
        }
        impl Recover {
            pub fn new(requeue: bool) -> Self {
                Recover { requeue: requeue }
            }
            pub fn requeue(&self) -> bool {
                self.requeue
            }
        }
        impl ::amqp0::Message for Recover {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                1
            }
        }

        // Class Modules
        pub struct RecoverOk;
        impl RecoverOk {
            pub fn new() -> Self {
                RecoverOk
            }
        }
        impl ::amqp0::Message for RecoverOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }
    }
    pub mod channel {

        // Class Modules
        pub struct Open<'a> {
            out_of_band: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Open<'a> {
            pub fn new<O>(out_of_band: O) -> Self
                where O: Into<::std::borrow::Cow<'a, str>>
            {
                Open { out_of_band: out_of_band.into() }
            }
            pub fn out_of_band(&self) -> &str {
                &*self.out_of_band
            }
        }
        impl<'a> ::amqp0::Message for Open<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [1, self.out_of_band.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct OpenOk;
        impl OpenOk {
            pub fn new() -> Self {
                OpenOk
            }
        }
        impl ::amqp0::Message for OpenOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Flow {
            active: bool,
        }
        impl Flow {
            pub fn new(active: bool) -> Self {
                Flow { active: active }
            }
            pub fn active(&self) -> bool {
                self.active
            }
        }
        impl ::amqp0::Message for Flow {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                1
            }
        }

        // Class Modules
        pub struct FlowOk {
            active: bool,
        }
        impl FlowOk {
            pub fn new(active: bool) -> Self {
                FlowOk { active: active }
            }
            pub fn active(&self) -> bool {
                self.active
            }
        }
        impl ::amqp0::Message for FlowOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                1
            }
        }

        // Class Modules
        pub struct Alert<'a> {
            reply_code: u16,
            reply_text: ::std::borrow::Cow<'a, str>,
            details: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
        }
        impl<'a> Alert<'a> {
            pub fn new<D, R>(reply_code: u16, reply_text: R, details: D) -> Self
                where R: Into<::std::borrow::Cow<'a, str>>,
                      D: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>
            {
                Alert {
                    reply_code: reply_code,
                    reply_text: reply_text.into(),
                    details: details.into(),
                }
            }
            pub fn reply_code(&self) -> u16 {
                self.reply_code
            }
            pub fn reply_text(&self) -> &str {
                &*self.reply_text
            }
            pub fn details(&self) -> &::amqp0::value::Table {
                &*self.details
            }
        }
        impl<'a> ::amqp0::Message for Alert<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [3, self.reply_text.len(), self.details.amqp_size()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Close<'a> {
            reply_code: u16,
            reply_text: ::std::borrow::Cow<'a, str>,
            class_id: u16,
            method_id: u16,
        }
        impl<'a> Close<'a> {
            pub fn new<R>(reply_code: u16, reply_text: R, class_id: u16, method_id: u16) -> Self
                where R: Into<::std::borrow::Cow<'a, str>>
            {
                Close {
                    reply_code: reply_code,
                    reply_text: reply_text.into(),
                    class_id: class_id,
                    method_id: method_id,
                }
            }
            pub fn reply_code(&self) -> u16 {
                self.reply_code
            }
            pub fn reply_text(&self) -> &str {
                &*self.reply_text
            }
            pub fn class_id(&self) -> u16 {
                self.class_id
            }
            pub fn method_id(&self) -> u16 {
                self.method_id
            }
        }
        impl<'a> ::amqp0::Message for Close<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [7, self.reply_text.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct CloseOk;
        impl CloseOk {
            pub fn new() -> Self {
                CloseOk
            }
        }
        impl ::amqp0::Message for CloseOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }
    }
    pub mod connection {

        // Class Modules
        pub struct Start<'a> {
            version_major: u8,
            version_minor: u8,
            server_properties: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
            mechanisms: ::std::borrow::Cow<'a, [u8]>,
            locales: ::std::borrow::Cow<'a, [u8]>,
        }
        impl<'a> Start<'a> {
            pub fn new<L, M, S>(version_major: u8,
                                version_minor: u8,
                                server_properties: S,
                                mechanisms: M,
                                locales: L)
                                -> Self
                where S: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>,
                      M: Into<::std::borrow::Cow<'a, [u8]>>,
                      L: Into<::std::borrow::Cow<'a, [u8]>>
            {
                Start {
                    version_major: version_major,
                    version_minor: version_minor,
                    server_properties: server_properties.into(),
                    mechanisms: mechanisms.into(),
                    locales: locales.into(),
                }
            }
            pub fn version_major(&self) -> u8 {
                self.version_major
            }
            pub fn version_minor(&self) -> u8 {
                self.version_minor
            }
            pub fn server_properties(&self) -> &::amqp0::value::Table {
                &*self.server_properties
            }
            pub fn mechanisms(&self) -> &[u8] {
                &*self.mechanisms
            }
            pub fn locales(&self) -> &[u8] {
                &*self.locales
            }
        }
        impl<'a> ::amqp0::Message for Start<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [6, self.server_properties.amqp_size(), self.mechanisms.len(), self.locales.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct StartOk<'a> {
            client_properties: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
            mechanism: ::std::borrow::Cow<'a, str>,
            response: ::std::borrow::Cow<'a, [u8]>,
            locale: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> StartOk<'a> {
            pub fn new<C, L, M, R>(client_properties: C,
                                   mechanism: M,
                                   response: R,
                                   locale: L)
                                   -> Self
                where C: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>,
                      M: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, [u8]>>,
                      L: Into<::std::borrow::Cow<'a, str>>
            {
                StartOk {
                    client_properties: client_properties.into(),
                    mechanism: mechanism.into(),
                    response: response.into(),
                    locale: locale.into(),
                }
            }
            pub fn client_properties(&self) -> &::amqp0::value::Table {
                &*self.client_properties
            }
            pub fn mechanism(&self) -> &str {
                &*self.mechanism
            }
            pub fn response(&self) -> &[u8] {
                &*self.response
            }
            pub fn locale(&self) -> &str {
                &*self.locale
            }
        }
        impl<'a> ::amqp0::Message for StartOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [4,
                 self.client_properties.amqp_size(),
                 self.mechanism.len(),
                 self.response.len(),
                 self.locale.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Secure<'a> {
            challenge: ::std::borrow::Cow<'a, [u8]>,
        }
        impl<'a> Secure<'a> {
            pub fn new<C>(challenge: C) -> Self
                where C: Into<::std::borrow::Cow<'a, [u8]>>
            {
                Secure { challenge: challenge.into() }
            }
            pub fn challenge(&self) -> &[u8] {
                &*self.challenge
            }
        }
        impl<'a> ::amqp0::Message for Secure<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.challenge.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct SecureOk<'a> {
            response: ::std::borrow::Cow<'a, [u8]>,
        }
        impl<'a> SecureOk<'a> {
            pub fn new<R>(response: R) -> Self
                where R: Into<::std::borrow::Cow<'a, [u8]>>
            {
                SecureOk { response: response.into() }
            }
            pub fn response(&self) -> &[u8] {
                &*self.response
            }
        }
        impl<'a> ::amqp0::Message for SecureOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.response.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Tune {
            channel_max: u16,
            frame_max: u32,
            heartbeat: u16,
        }
        impl Tune {
            pub fn new(channel_max: u16, frame_max: u32, heartbeat: u16) -> Self {
                Tune {
                    channel_max: channel_max,
                    frame_max: frame_max,
                    heartbeat: heartbeat,
                }
            }
            pub fn channel_max(&self) -> u16 {
                self.channel_max
            }
            pub fn frame_max(&self) -> u32 {
                self.frame_max
            }
            pub fn heartbeat(&self) -> u16 {
                self.heartbeat
            }
        }
        impl ::amqp0::Message for Tune {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                8
            }
        }

        // Class Modules
        pub struct TuneOk {
            channel_max: u16,
            frame_max: u32,
            heartbeat: u16,
        }
        impl TuneOk {
            pub fn new(channel_max: u16, frame_max: u32, heartbeat: u16) -> Self {
                TuneOk {
                    channel_max: channel_max,
                    frame_max: frame_max,
                    heartbeat: heartbeat,
                }
            }
            pub fn channel_max(&self) -> u16 {
                self.channel_max
            }
            pub fn frame_max(&self) -> u32 {
                self.frame_max
            }
            pub fn heartbeat(&self) -> u16 {
                self.heartbeat
            }
        }
        impl ::amqp0::Message for TuneOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                8
            }
        }

        // Class Modules
        pub struct Open<'a> {
            virtual_host: ::std::borrow::Cow<'a, str>,
            capabilities: ::std::borrow::Cow<'a, str>,
            insist: bool,
        }
        impl<'a> Open<'a> {
            pub fn new<C, V>(virtual_host: V, capabilities: C, insist: bool) -> Self
                where V: Into<::std::borrow::Cow<'a, str>>,
                      C: Into<::std::borrow::Cow<'a, str>>
            {
                Open {
                    virtual_host: virtual_host.into(),
                    capabilities: capabilities.into(),
                    insist: insist,
                }
            }
            pub fn virtual_host(&self) -> &str {
                &*self.virtual_host
            }
            pub fn capabilities(&self) -> &str {
                &*self.capabilities
            }
            pub fn insist(&self) -> bool {
                self.insist
            }
        }
        impl<'a> ::amqp0::Message for Open<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [3, self.virtual_host.len(), self.capabilities.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct OpenOk<'a> {
            known_hosts: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> OpenOk<'a> {
            pub fn new<K>(known_hosts: K) -> Self
                where K: Into<::std::borrow::Cow<'a, str>>
            {
                OpenOk { known_hosts: known_hosts.into() }
            }
            pub fn known_hosts(&self) -> &str {
                &*self.known_hosts
            }
        }
        impl<'a> ::amqp0::Message for OpenOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [1, self.known_hosts.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Redirect<'a> {
            host: ::std::borrow::Cow<'a, str>,
            known_hosts: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Redirect<'a> {
            pub fn new<H, K>(host: H, known_hosts: K) -> Self
                where H: Into<::std::borrow::Cow<'a, str>>,
                      K: Into<::std::borrow::Cow<'a, str>>
            {
                Redirect {
                    host: host.into(),
                    known_hosts: known_hosts.into(),
                }
            }
            pub fn host(&self) -> &str {
                &*self.host
            }
            pub fn known_hosts(&self) -> &str {
                &*self.known_hosts
            }
        }
        impl<'a> ::amqp0::Message for Redirect<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.host.len(), self.known_hosts.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Close<'a> {
            reply_code: u16,
            reply_text: ::std::borrow::Cow<'a, str>,
            class_id: u16,
            method_id: u16,
        }
        impl<'a> Close<'a> {
            pub fn new<R>(reply_code: u16, reply_text: R, class_id: u16, method_id: u16) -> Self
                where R: Into<::std::borrow::Cow<'a, str>>
            {
                Close {
                    reply_code: reply_code,
                    reply_text: reply_text.into(),
                    class_id: class_id,
                    method_id: method_id,
                }
            }
            pub fn reply_code(&self) -> u16 {
                self.reply_code
            }
            pub fn reply_text(&self) -> &str {
                &*self.reply_text
            }
            pub fn class_id(&self) -> u16 {
                self.class_id
            }
            pub fn method_id(&self) -> u16 {
                self.method_id
            }
        }
        impl<'a> ::amqp0::Message for Close<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [7, self.reply_text.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct CloseOk;
        impl CloseOk {
            pub fn new() -> Self {
                CloseOk
            }
        }
        impl ::amqp0::Message for CloseOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }
    }
    pub mod dtx {

        // Class Modules
        pub struct Select;
        impl Select {
            pub fn new() -> Self {
                Select
            }
        }
        impl ::amqp0::Message for Select {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct SelectOk;
        impl SelectOk {
            pub fn new() -> Self {
                SelectOk
            }
        }
        impl ::amqp0::Message for SelectOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Start<'a> {
            dtx_identifier: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Start<'a> {
            pub fn new<D>(dtx_identifier: D) -> Self
                where D: Into<::std::borrow::Cow<'a, str>>
            {
                Start { dtx_identifier: dtx_identifier.into() }
            }
            pub fn dtx_identifier(&self) -> &str {
                &*self.dtx_identifier
            }
        }
        impl<'a> ::amqp0::Message for Start<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [1, self.dtx_identifier.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct StartOk;
        impl StartOk {
            pub fn new() -> Self {
                StartOk
            }
        }
        impl ::amqp0::Message for StartOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }
    }
    pub mod exchange {

        // Class Modules
        pub struct Declare<'a> {
            ticket: u16,
            exchange: ::std::borrow::Cow<'a, str>,
            ty: ::std::borrow::Cow<'a, str>,
            passive: bool,
            durable: bool,
            auto_delete: bool,
            internal: bool,
            nowait: bool,
            arguments: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
        }
        impl<'a> Declare<'a> {
            pub fn new<A, E, T>(ticket: u16,
                                exchange: E,
                                ty: T,
                                passive: bool,
                                durable: bool,
                                auto_delete: bool,
                                internal: bool,
                                nowait: bool,
                                arguments: A)
                                -> Self
                where E: Into<::std::borrow::Cow<'a, str>>,
                      T: Into<::std::borrow::Cow<'a, str>>,
                      A: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>
            {
                Declare {
                    ticket: ticket,
                    exchange: exchange.into(),
                    ty: ty.into(),
                    passive: passive,
                    durable: durable,
                    auto_delete: auto_delete,
                    internal: internal,
                    nowait: nowait,
                    arguments: arguments.into(),
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn ty(&self) -> &str {
                &*self.ty
            }
            pub fn passive(&self) -> bool {
                self.passive
            }
            pub fn durable(&self) -> bool {
                self.durable
            }
            pub fn auto_delete(&self) -> bool {
                self.auto_delete
            }
            pub fn internal(&self) -> bool {
                self.internal
            }
            pub fn nowait(&self) -> bool {
                self.nowait
            }
            pub fn arguments(&self) -> &::amqp0::value::Table {
                &*self.arguments
            }
        }
        impl<'a> ::amqp0::Message for Declare<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [5, self.exchange.len(), self.ty.len(), self.arguments.amqp_size()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct DeclareOk;
        impl DeclareOk {
            pub fn new() -> Self {
                DeclareOk
            }
        }
        impl ::amqp0::Message for DeclareOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Delete<'a> {
            ticket: u16,
            exchange: ::std::borrow::Cow<'a, str>,
            if_unused: bool,
            nowait: bool,
        }
        impl<'a> Delete<'a> {
            pub fn new<E>(ticket: u16, exchange: E, if_unused: bool, nowait: bool) -> Self
                where E: Into<::std::borrow::Cow<'a, str>>
            {
                Delete {
                    ticket: ticket,
                    exchange: exchange.into(),
                    if_unused: if_unused,
                    nowait: nowait,
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn if_unused(&self) -> bool {
                self.if_unused
            }
            pub fn nowait(&self) -> bool {
                self.nowait
            }
        }
        impl<'a> ::amqp0::Message for Delete<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [4, self.exchange.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct DeleteOk;
        impl DeleteOk {
            pub fn new() -> Self {
                DeleteOk
            }
        }
        impl ::amqp0::Message for DeleteOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Bound<'a> {
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
            queue: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Bound<'a> {
            pub fn new<E, Q, R>(exchange: E, routing_key: R, queue: Q) -> Self
                where E: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, str>>,
                      Q: Into<::std::borrow::Cow<'a, str>>
            {
                Bound {
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                    queue: queue.into(),
                }
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
        }
        impl<'a> ::amqp0::Message for Bound<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [3, self.exchange.len(), self.routing_key.len(), self.queue.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct BoundOk<'a> {
            reply_code: u16,
            reply_text: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> BoundOk<'a> {
            pub fn new<R>(reply_code: u16, reply_text: R) -> Self
                where R: Into<::std::borrow::Cow<'a, str>>
            {
                BoundOk {
                    reply_code: reply_code,
                    reply_text: reply_text.into(),
                }
            }
            pub fn reply_code(&self) -> u16 {
                self.reply_code
            }
            pub fn reply_text(&self) -> &str {
                &*self.reply_text
            }
        }
        impl<'a> ::amqp0::Message for BoundOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [3, self.reply_text.len()]
                    .iter()
                    .sum()
            }
        }
    }
    pub mod file {

        // Class Modules
        pub struct Qos {
            prefetch_size: u32,
            prefetch_count: u16,
            global: bool,
        }
        impl Qos {
            pub fn new(prefetch_size: u32, prefetch_count: u16, global: bool) -> Self {
                Qos {
                    prefetch_size: prefetch_size,
                    prefetch_count: prefetch_count,
                    global: global,
                }
            }
            pub fn prefetch_size(&self) -> u32 {
                self.prefetch_size
            }
            pub fn prefetch_count(&self) -> u16 {
                self.prefetch_count
            }
            pub fn global(&self) -> bool {
                self.global
            }
        }
        impl ::amqp0::Message for Qos {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                7
            }
        }

        // Class Modules
        pub struct QosOk;
        impl QosOk {
            pub fn new() -> Self {
                QosOk
            }
        }
        impl ::amqp0::Message for QosOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Consume<'a> {
            ticket: u16,
            queue: ::std::borrow::Cow<'a, str>,
            consumer_tag: ::std::borrow::Cow<'a, str>,
            no_local: bool,
            no_ack: bool,
            exclusive: bool,
            nowait: bool,
        }
        impl<'a> Consume<'a> {
            pub fn new<C, Q>(ticket: u16,
                             queue: Q,
                             consumer_tag: C,
                             no_local: bool,
                             no_ack: bool,
                             exclusive: bool,
                             nowait: bool)
                             -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>,
                      C: Into<::std::borrow::Cow<'a, str>>
            {
                Consume {
                    ticket: ticket,
                    queue: queue.into(),
                    consumer_tag: consumer_tag.into(),
                    no_local: no_local,
                    no_ack: no_ack,
                    exclusive: exclusive,
                    nowait: nowait,
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
            pub fn no_local(&self) -> bool {
                self.no_local
            }
            pub fn no_ack(&self) -> bool {
                self.no_ack
            }
            pub fn exclusive(&self) -> bool {
                self.exclusive
            }
            pub fn nowait(&self) -> bool {
                self.nowait
            }
        }
        impl<'a> ::amqp0::Message for Consume<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [5, self.queue.len(), self.consumer_tag.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct ConsumeOk<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> ConsumeOk<'a> {
            pub fn new<C>(consumer_tag: C) -> Self
                where C: Into<::std::borrow::Cow<'a, str>>
            {
                ConsumeOk { consumer_tag: consumer_tag.into() }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
        }
        impl<'a> ::amqp0::Message for ConsumeOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [1, self.consumer_tag.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Cancel<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
            nowait: bool,
        }
        impl<'a> Cancel<'a> {
            pub fn new<C>(consumer_tag: C, nowait: bool) -> Self
                where C: Into<::std::borrow::Cow<'a, str>>
            {
                Cancel {
                    consumer_tag: consumer_tag.into(),
                    nowait: nowait,
                }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
            pub fn nowait(&self) -> bool {
                self.nowait
            }
        }
        impl<'a> ::amqp0::Message for Cancel<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.consumer_tag.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct CancelOk<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> CancelOk<'a> {
            pub fn new<C>(consumer_tag: C) -> Self
                where C: Into<::std::borrow::Cow<'a, str>>
            {
                CancelOk { consumer_tag: consumer_tag.into() }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
        }
        impl<'a> ::amqp0::Message for CancelOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [1, self.consumer_tag.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Open<'a> {
            identifier: ::std::borrow::Cow<'a, str>,
            content_size: u64,
        }
        impl<'a> Open<'a> {
            pub fn new<I>(identifier: I, content_size: u64) -> Self
                where I: Into<::std::borrow::Cow<'a, str>>
            {
                Open {
                    identifier: identifier.into(),
                    content_size: content_size,
                }
            }
            pub fn identifier(&self) -> &str {
                &*self.identifier
            }
            pub fn content_size(&self) -> u64 {
                self.content_size
            }
        }
        impl<'a> ::amqp0::Message for Open<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [9, self.identifier.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct OpenOk {
            staged_size: u64,
        }
        impl OpenOk {
            pub fn new(staged_size: u64) -> Self {
                OpenOk { staged_size: staged_size }
            }
            pub fn staged_size(&self) -> u64 {
                self.staged_size
            }
        }
        impl ::amqp0::Message for OpenOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                8
            }
        }

        // Class Modules
        pub struct Stage;
        impl Stage {
            pub fn new() -> Self {
                Stage
            }
        }
        impl ::amqp0::Message for Stage {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Publish<'a> {
            ticket: u16,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
            mandatory: bool,
            immediate: bool,
            identifier: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Publish<'a> {
            pub fn new<E, I, R>(ticket: u16,
                                exchange: E,
                                routing_key: R,
                                mandatory: bool,
                                immediate: bool,
                                identifier: I)
                                -> Self
                where E: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, str>>,
                      I: Into<::std::borrow::Cow<'a, str>>
            {
                Publish {
                    ticket: ticket,
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                    mandatory: mandatory,
                    immediate: immediate,
                    identifier: identifier.into(),
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
            pub fn mandatory(&self) -> bool {
                self.mandatory
            }
            pub fn immediate(&self) -> bool {
                self.immediate
            }
            pub fn identifier(&self) -> &str {
                &*self.identifier
            }
        }
        impl<'a> ::amqp0::Message for Publish<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [6, self.exchange.len(), self.routing_key.len(), self.identifier.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Return<'a> {
            reply_code: u16,
            reply_text: ::std::borrow::Cow<'a, str>,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Return<'a> {
            pub fn new<E, R, R0>(reply_code: u16,
                                 reply_text: R,
                                 exchange: E,
                                 routing_key: R0)
                                 -> Self
                where R: Into<::std::borrow::Cow<'a, str>>,
                      E: Into<::std::borrow::Cow<'a, str>>,
                      R0: Into<::std::borrow::Cow<'a, str>>
            {
                Return {
                    reply_code: reply_code,
                    reply_text: reply_text.into(),
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                }
            }
            pub fn reply_code(&self) -> u16 {
                self.reply_code
            }
            pub fn reply_text(&self) -> &str {
                &*self.reply_text
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
        }
        impl<'a> ::amqp0::Message for Return<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [5, self.reply_text.len(), self.exchange.len(), self.routing_key.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Deliver<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
            delivery_tag: u64,
            redelivered: bool,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
            identifier: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Deliver<'a> {
            pub fn new<C, E, I, R>(consumer_tag: C,
                                   delivery_tag: u64,
                                   redelivered: bool,
                                   exchange: E,
                                   routing_key: R,
                                   identifier: I)
                                   -> Self
                where C: Into<::std::borrow::Cow<'a, str>>,
                      E: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, str>>,
                      I: Into<::std::borrow::Cow<'a, str>>
            {
                Deliver {
                    consumer_tag: consumer_tag.into(),
                    delivery_tag: delivery_tag,
                    redelivered: redelivered,
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                    identifier: identifier.into(),
                }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
            pub fn delivery_tag(&self) -> u64 {
                self.delivery_tag
            }
            pub fn redelivered(&self) -> bool {
                self.redelivered
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
            pub fn identifier(&self) -> &str {
                &*self.identifier
            }
        }
        impl<'a> ::amqp0::Message for Deliver<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [13,
                 self.consumer_tag.len(),
                 self.exchange.len(),
                 self.routing_key.len(),
                 self.identifier.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Ack {
            delivery_tag: u64,
            multiple: bool,
        }
        impl Ack {
            pub fn new(delivery_tag: u64, multiple: bool) -> Self {
                Ack {
                    delivery_tag: delivery_tag,
                    multiple: multiple,
                }
            }
            pub fn delivery_tag(&self) -> u64 {
                self.delivery_tag
            }
            pub fn multiple(&self) -> bool {
                self.multiple
            }
        }
        impl ::amqp0::Message for Ack {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                9
            }
        }

        // Class Modules
        pub struct Reject {
            delivery_tag: u64,
            requeue: bool,
        }
        impl Reject {
            pub fn new(delivery_tag: u64, requeue: bool) -> Self {
                Reject {
                    delivery_tag: delivery_tag,
                    requeue: requeue,
                }
            }
            pub fn delivery_tag(&self) -> u64 {
                self.delivery_tag
            }
            pub fn requeue(&self) -> bool {
                self.requeue
            }
        }
        impl ::amqp0::Message for Reject {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                9
            }
        }
    }
    pub mod queue {

        // Class Modules
        pub struct Declare<'a> {
            ticket: u16,
            queue: ::std::borrow::Cow<'a, str>,
            passive: bool,
            durable: bool,
            exclusive: bool,
            auto_delete: bool,
            nowait: bool,
            arguments: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
        }
        impl<'a> Declare<'a> {
            pub fn new<A, Q>(ticket: u16,
                             queue: Q,
                             passive: bool,
                             durable: bool,
                             exclusive: bool,
                             auto_delete: bool,
                             nowait: bool,
                             arguments: A)
                             -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>,
                      A: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>
            {
                Declare {
                    ticket: ticket,
                    queue: queue.into(),
                    passive: passive,
                    durable: durable,
                    exclusive: exclusive,
                    auto_delete: auto_delete,
                    nowait: nowait,
                    arguments: arguments.into(),
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn passive(&self) -> bool {
                self.passive
            }
            pub fn durable(&self) -> bool {
                self.durable
            }
            pub fn exclusive(&self) -> bool {
                self.exclusive
            }
            pub fn auto_delete(&self) -> bool {
                self.auto_delete
            }
            pub fn nowait(&self) -> bool {
                self.nowait
            }
            pub fn arguments(&self) -> &::amqp0::value::Table {
                &*self.arguments
            }
        }
        impl<'a> ::amqp0::Message for Declare<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [4, self.queue.len(), self.arguments.amqp_size()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct DeclareOk<'a> {
            queue: ::std::borrow::Cow<'a, str>,
            message_count: u32,
            consumer_count: u32,
        }
        impl<'a> DeclareOk<'a> {
            pub fn new<Q>(queue: Q, message_count: u32, consumer_count: u32) -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>
            {
                DeclareOk {
                    queue: queue.into(),
                    message_count: message_count,
                    consumer_count: consumer_count,
                }
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn message_count(&self) -> u32 {
                self.message_count
            }
            pub fn consumer_count(&self) -> u32 {
                self.consumer_count
            }
        }
        impl<'a> ::amqp0::Message for DeclareOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [9, self.queue.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Bind<'a> {
            ticket: u16,
            queue: ::std::borrow::Cow<'a, str>,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
            nowait: bool,
            arguments: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
        }
        impl<'a> Bind<'a> {
            pub fn new<A, E, Q, R>(ticket: u16,
                                   queue: Q,
                                   exchange: E,
                                   routing_key: R,
                                   nowait: bool,
                                   arguments: A)
                                   -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>,
                      E: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, str>>,
                      A: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>
            {
                Bind {
                    ticket: ticket,
                    queue: queue.into(),
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                    nowait: nowait,
                    arguments: arguments.into(),
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
            pub fn nowait(&self) -> bool {
                self.nowait
            }
            pub fn arguments(&self) -> &::amqp0::value::Table {
                &*self.arguments
            }
        }
        impl<'a> ::amqp0::Message for Bind<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [6,
                 self.queue.len(),
                 self.exchange.len(),
                 self.routing_key.len(),
                 self.arguments.amqp_size()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct BindOk;
        impl BindOk {
            pub fn new() -> Self {
                BindOk
            }
        }
        impl ::amqp0::Message for BindOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Purge<'a> {
            ticket: u16,
            queue: ::std::borrow::Cow<'a, str>,
            nowait: bool,
        }
        impl<'a> Purge<'a> {
            pub fn new<Q>(ticket: u16, queue: Q, nowait: bool) -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>
            {
                Purge {
                    ticket: ticket,
                    queue: queue.into(),
                    nowait: nowait,
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn nowait(&self) -> bool {
                self.nowait
            }
        }
        impl<'a> ::amqp0::Message for Purge<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [4, self.queue.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct PurgeOk {
            message_count: u32,
        }
        impl PurgeOk {
            pub fn new(message_count: u32) -> Self {
                PurgeOk { message_count: message_count }
            }
            pub fn message_count(&self) -> u32 {
                self.message_count
            }
        }
        impl ::amqp0::Message for PurgeOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                4
            }
        }

        // Class Modules
        pub struct Delete<'a> {
            ticket: u16,
            queue: ::std::borrow::Cow<'a, str>,
            if_unused: bool,
            if_empty: bool,
            nowait: bool,
        }
        impl<'a> Delete<'a> {
            pub fn new<Q>(ticket: u16,
                          queue: Q,
                          if_unused: bool,
                          if_empty: bool,
                          nowait: bool)
                          -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>
            {
                Delete {
                    ticket: ticket,
                    queue: queue.into(),
                    if_unused: if_unused,
                    if_empty: if_empty,
                    nowait: nowait,
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn if_unused(&self) -> bool {
                self.if_unused
            }
            pub fn if_empty(&self) -> bool {
                self.if_empty
            }
            pub fn nowait(&self) -> bool {
                self.nowait
            }
        }
        impl<'a> ::amqp0::Message for Delete<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [4, self.queue.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct DeleteOk {
            message_count: u32,
        }
        impl DeleteOk {
            pub fn new(message_count: u32) -> Self {
                DeleteOk { message_count: message_count }
            }
            pub fn message_count(&self) -> u32 {
                self.message_count
            }
        }
        impl ::amqp0::Message for DeleteOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                4
            }
        }
    }
    pub mod stream {

        // Class Modules
        pub struct Qos {
            prefetch_size: u32,
            prefetch_count: u16,
            consume_rate: u32,
            global: bool,
        }
        impl Qos {
            pub fn new(prefetch_size: u32,
                       prefetch_count: u16,
                       consume_rate: u32,
                       global: bool)
                       -> Self {
                Qos {
                    prefetch_size: prefetch_size,
                    prefetch_count: prefetch_count,
                    consume_rate: consume_rate,
                    global: global,
                }
            }
            pub fn prefetch_size(&self) -> u32 {
                self.prefetch_size
            }
            pub fn prefetch_count(&self) -> u16 {
                self.prefetch_count
            }
            pub fn consume_rate(&self) -> u32 {
                self.consume_rate
            }
            pub fn global(&self) -> bool {
                self.global
            }
        }
        impl ::amqp0::Message for Qos {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                11
            }
        }

        // Class Modules
        pub struct QosOk;
        impl QosOk {
            pub fn new() -> Self {
                QosOk
            }
        }
        impl ::amqp0::Message for QosOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Consume<'a> {
            ticket: u16,
            queue: ::std::borrow::Cow<'a, str>,
            consumer_tag: ::std::borrow::Cow<'a, str>,
            no_local: bool,
            exclusive: bool,
            nowait: bool,
        }
        impl<'a> Consume<'a> {
            pub fn new<C, Q>(ticket: u16,
                             queue: Q,
                             consumer_tag: C,
                             no_local: bool,
                             exclusive: bool,
                             nowait: bool)
                             -> Self
                where Q: Into<::std::borrow::Cow<'a, str>>,
                      C: Into<::std::borrow::Cow<'a, str>>
            {
                Consume {
                    ticket: ticket,
                    queue: queue.into(),
                    consumer_tag: consumer_tag.into(),
                    no_local: no_local,
                    exclusive: exclusive,
                    nowait: nowait,
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
            pub fn no_local(&self) -> bool {
                self.no_local
            }
            pub fn exclusive(&self) -> bool {
                self.exclusive
            }
            pub fn nowait(&self) -> bool {
                self.nowait
            }
        }
        impl<'a> ::amqp0::Message for Consume<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [5, self.queue.len(), self.consumer_tag.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct ConsumeOk<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> ConsumeOk<'a> {
            pub fn new<C>(consumer_tag: C) -> Self
                where C: Into<::std::borrow::Cow<'a, str>>
            {
                ConsumeOk { consumer_tag: consumer_tag.into() }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
        }
        impl<'a> ::amqp0::Message for ConsumeOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [1, self.consumer_tag.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Cancel<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
            nowait: bool,
        }
        impl<'a> Cancel<'a> {
            pub fn new<C>(consumer_tag: C, nowait: bool) -> Self
                where C: Into<::std::borrow::Cow<'a, str>>
            {
                Cancel {
                    consumer_tag: consumer_tag.into(),
                    nowait: nowait,
                }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
            pub fn nowait(&self) -> bool {
                self.nowait
            }
        }
        impl<'a> ::amqp0::Message for Cancel<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.consumer_tag.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct CancelOk<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> CancelOk<'a> {
            pub fn new<C>(consumer_tag: C) -> Self
                where C: Into<::std::borrow::Cow<'a, str>>
            {
                CancelOk { consumer_tag: consumer_tag.into() }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
        }
        impl<'a> ::amqp0::Message for CancelOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [1, self.consumer_tag.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Publish<'a> {
            ticket: u16,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
            mandatory: bool,
            immediate: bool,
        }
        impl<'a> Publish<'a> {
            pub fn new<E, R>(ticket: u16,
                             exchange: E,
                             routing_key: R,
                             mandatory: bool,
                             immediate: bool)
                             -> Self
                where E: Into<::std::borrow::Cow<'a, str>>,
                      R: Into<::std::borrow::Cow<'a, str>>
            {
                Publish {
                    ticket: ticket,
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                    mandatory: mandatory,
                    immediate: immediate,
                }
            }
            pub fn ticket(&self) -> u16 {
                self.ticket
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
            pub fn mandatory(&self) -> bool {
                self.mandatory
            }
            pub fn immediate(&self) -> bool {
                self.immediate
            }
        }
        impl<'a> ::amqp0::Message for Publish<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [5, self.exchange.len(), self.routing_key.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Return<'a> {
            reply_code: u16,
            reply_text: ::std::borrow::Cow<'a, str>,
            exchange: ::std::borrow::Cow<'a, str>,
            routing_key: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Return<'a> {
            pub fn new<E, R, R0>(reply_code: u16,
                                 reply_text: R,
                                 exchange: E,
                                 routing_key: R0)
                                 -> Self
                where R: Into<::std::borrow::Cow<'a, str>>,
                      E: Into<::std::borrow::Cow<'a, str>>,
                      R0: Into<::std::borrow::Cow<'a, str>>
            {
                Return {
                    reply_code: reply_code,
                    reply_text: reply_text.into(),
                    exchange: exchange.into(),
                    routing_key: routing_key.into(),
                }
            }
            pub fn reply_code(&self) -> u16 {
                self.reply_code
            }
            pub fn reply_text(&self) -> &str {
                &*self.reply_text
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn routing_key(&self) -> &str {
                &*self.routing_key
            }
        }
        impl<'a> ::amqp0::Message for Return<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [5, self.reply_text.len(), self.exchange.len(), self.routing_key.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Deliver<'a> {
            consumer_tag: ::std::borrow::Cow<'a, str>,
            delivery_tag: u64,
            exchange: ::std::borrow::Cow<'a, str>,
            queue: ::std::borrow::Cow<'a, str>,
        }
        impl<'a> Deliver<'a> {
            pub fn new<C, E, Q>(consumer_tag: C, delivery_tag: u64, exchange: E, queue: Q) -> Self
                where C: Into<::std::borrow::Cow<'a, str>>,
                      E: Into<::std::borrow::Cow<'a, str>>,
                      Q: Into<::std::borrow::Cow<'a, str>>
            {
                Deliver {
                    consumer_tag: consumer_tag.into(),
                    delivery_tag: delivery_tag,
                    exchange: exchange.into(),
                    queue: queue.into(),
                }
            }
            pub fn consumer_tag(&self) -> &str {
                &*self.consumer_tag
            }
            pub fn delivery_tag(&self) -> u64 {
                self.delivery_tag
            }
            pub fn exchange(&self) -> &str {
                &*self.exchange
            }
            pub fn queue(&self) -> &str {
                &*self.queue
            }
        }
        impl<'a> ::amqp0::Message for Deliver<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [11, self.consumer_tag.len(), self.exchange.len(), self.queue.len()]
                    .iter()
                    .sum()
            }
        }
    }
    pub mod test {

        // Class Modules
        pub struct Integer {
            integer_1: u8,
            integer_2: u16,
            integer_3: u32,
            integer_4: u64,
            operation: u8,
        }
        impl Integer {
            pub fn new(integer_1: u8,
                       integer_2: u16,
                       integer_3: u32,
                       integer_4: u64,
                       operation: u8)
                       -> Self {
                Integer {
                    integer_1: integer_1,
                    integer_2: integer_2,
                    integer_3: integer_3,
                    integer_4: integer_4,
                    operation: operation,
                }
            }
            pub fn integer_1(&self) -> u8 {
                self.integer_1
            }
            pub fn integer_2(&self) -> u16 {
                self.integer_2
            }
            pub fn integer_3(&self) -> u32 {
                self.integer_3
            }
            pub fn integer_4(&self) -> u64 {
                self.integer_4
            }
            pub fn operation(&self) -> u8 {
                self.operation
            }
        }
        impl ::amqp0::Message for Integer {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                16
            }
        }

        // Class Modules
        pub struct IntegerOk {
            result: u64,
        }
        impl IntegerOk {
            pub fn new(result: u64) -> Self {
                IntegerOk { result: result }
            }
            pub fn result(&self) -> u64 {
                self.result
            }
        }
        impl ::amqp0::Message for IntegerOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                8
            }
        }

        // Class Modules
        pub struct String<'a> {
            string_1: ::std::borrow::Cow<'a, str>,
            string_2: ::std::borrow::Cow<'a, [u8]>,
            operation: u8,
        }
        impl<'a> String<'a> {
            pub fn new<S, S0>(string_1: S, string_2: S0, operation: u8) -> Self
                where S: Into<::std::borrow::Cow<'a, str>>,
                      S0: Into<::std::borrow::Cow<'a, [u8]>>
            {
                String {
                    string_1: string_1.into(),
                    string_2: string_2.into(),
                    operation: operation,
                }
            }
            pub fn string_1(&self) -> &str {
                &*self.string_1
            }
            pub fn string_2(&self) -> &[u8] {
                &*self.string_2
            }
            pub fn operation(&self) -> u8 {
                self.operation
            }
        }
        impl<'a> ::amqp0::Message for String<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [4, self.string_1.len(), self.string_2.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct StringOk<'a> {
            result: ::std::borrow::Cow<'a, [u8]>,
        }
        impl<'a> StringOk<'a> {
            pub fn new<R>(result: R) -> Self
                where R: Into<::std::borrow::Cow<'a, [u8]>>
            {
                StringOk { result: result.into() }
            }
            pub fn result(&self) -> &[u8] {
                &*self.result
            }
        }
        impl<'a> ::amqp0::Message for StringOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.result.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Table<'a> {
            table: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
            integer_op: u8,
            string_op: u8,
        }
        impl<'a> Table<'a> {
            pub fn new<T>(table: T, integer_op: u8, string_op: u8) -> Self
                where T: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>
            {
                Table {
                    table: table.into(),
                    integer_op: integer_op,
                    string_op: string_op,
                }
            }
            pub fn table(&self) -> &::amqp0::value::Table {
                &*self.table
            }
            pub fn integer_op(&self) -> u8 {
                self.integer_op
            }
            pub fn string_op(&self) -> u8 {
                self.string_op
            }
        }
        impl<'a> ::amqp0::Message for Table<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [2, self.table.amqp_size()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct TableOk<'a> {
            integer_result: u64,
            string_result: ::std::borrow::Cow<'a, [u8]>,
        }
        impl<'a> TableOk<'a> {
            pub fn new<S>(integer_result: u64, string_result: S) -> Self
                where S: Into<::std::borrow::Cow<'a, [u8]>>
            {
                TableOk {
                    integer_result: integer_result,
                    string_result: string_result.into(),
                }
            }
            pub fn integer_result(&self) -> u64 {
                self.integer_result
            }
            pub fn string_result(&self) -> &[u8] {
                &*self.string_result
            }
        }
        impl<'a> ::amqp0::Message for TableOk<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [10, self.string_result.len()]
                    .iter()
                    .sum()
            }
        }

        // Class Modules
        pub struct Content;
        impl Content {
            pub fn new() -> Self {
                Content
            }
        }
        impl ::amqp0::Message for Content {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct ContentOk {
            content_checksum: u32,
        }
        impl ContentOk {
            pub fn new(content_checksum: u32) -> Self {
                ContentOk { content_checksum: content_checksum }
            }
            pub fn content_checksum(&self) -> u32 {
                self.content_checksum
            }
        }
        impl ::amqp0::Message for ContentOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                4
            }
        }
    }
    pub mod tunnel {

        // Class Modules
        pub struct Request<'a> {
            meta_data: ::std::borrow::Cow<'a, ::amqp0::value::Table>,
        }
        impl<'a> Request<'a> {
            pub fn new<M>(meta_data: M) -> Self
                where M: Into<::std::borrow::Cow<'a, ::amqp0::value::Table>>
            {
                Request { meta_data: meta_data.into() }
            }
            pub fn meta_data(&self) -> &::amqp0::value::Table {
                &*self.meta_data
            }
        }
        impl<'a> ::amqp0::Message for Request<'a> {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                [0, self.meta_data.amqp_size()]
                    .iter()
                    .sum()
            }
        }
    }
    pub mod tx {

        // Class Modules
        pub struct Select;
        impl Select {
            pub fn new() -> Self {
                Select
            }
        }
        impl ::amqp0::Message for Select {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct SelectOk;
        impl SelectOk {
            pub fn new() -> Self {
                SelectOk
            }
        }
        impl ::amqp0::Message for SelectOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Commit;
        impl Commit {
            pub fn new() -> Self {
                Commit
            }
        }
        impl ::amqp0::Message for Commit {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct CommitOk;
        impl CommitOk {
            pub fn new() -> Self {
                CommitOk
            }
        }
        impl ::amqp0::Message for CommitOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct Rollback;
        impl Rollback {
            pub fn new() -> Self {
                Rollback
            }
        }
        impl ::amqp0::Message for Rollback {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }

        // Class Modules
        pub struct RollbackOk;
        impl RollbackOk {
            pub fn new() -> Self {
                RollbackOk
            }
        }
        impl ::amqp0::Message for RollbackOk {
            fn write_amqp_message<W>(&self, _: &mut W) -> ::std::io::Result<()>
                where W: ::std::io::Write
            {
                ::std::result::Result::Ok(())
            }
            fn amqp_message_size(&self) -> usize {
                0
            }
        }
    }
}

#[allow(non_camel_case_types)]
pub struct Qpid8_0;
impl Spec for Qpid8_0 {}
